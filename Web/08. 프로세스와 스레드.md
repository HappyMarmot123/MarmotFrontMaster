# 프로세스와 스레드

## 개요

프로세스와 스레드는 운영체제에서 프로그램 실행을 관리하는 기본 단위입니다. 웹 개발에서 성능 최적화와 동시성 처리를 이해하는 데 중요한 개념입니다.

## 프로세스 (Process)

### 1. 프로세스의 정의

프로세스는 실행 중인 프로그램의 인스턴스로, 독립적인 메모리 공간과 시스템 자원을 가집니다. 운영체제는 각 프로세스에게 고유한 프로세스 ID(PID)를 할당하고, 프로세스 간 격리를 통해 안전한 실행 환경을 제공합니다.

**프로세스의 핵심 개념:**

- **독립성**: 각 프로세스는 독립적인 메모리 공간을 가짐
- **자원 관리**: CPU, 메모리, 파일 등의 시스템 자원을 할당받음
- **생명주기**: 생성, 실행, 대기, 종료 등의 상태를 가짐
- **보안**: 프로세스 간 격리로 보안성 향상

**프로세스가 독립적인 이유:**
프로세스는 서로 다른 메모리 공간을 사용하기 때문에, 한 프로세스에서 발생한 오류나 충돌이 다른 프로세스에 영향을 주지 않습니다. 이는 시스템의 안정성과 보안을 크게 향상시킵니다. 예를 들어, 웹 브라우저에서 하나의 탭이 충돌해도 다른 탭은 정상적으로 작동할 수 있습니다.

### 2. 프로세스 구조

```
프로세스
├── 코드 영역 (Text Segment)
│   └── 실행 가능한 기계어 코드
├── 데이터 영역 (Data Segment)
│   ├── 전역 변수
│   └── 정적 변수
├── 힙 영역 (Heap Segment)
│   └── 동적 할당 메모리
├── 스택 영역 (Stack Segment)
│   ├── 지역 변수
│   ├── 함수 매개변수
│   └── 반환 주소
└── 프로세스 제어 블록 (PCB)
    ├── 프로세스 ID
    ├── 상태 정보
    ├── CPU 레지스터
    └── 자원 정보
```

### 3. 프로세스 상태 전이

```
     생성
      ↓
   [New] → [Ready] → [Running] → [Terminated]
              ↑         ↓
           [Waiting] ← [Blocked]
```

- **New**: 프로세스가 생성되었지만 아직 메모리에 로드되지 않음
- **Ready**: CPU 할당을 기다리는 상태
- **Running**: CPU에서 실행 중인 상태
- **Waiting**: I/O 완료나 다른 이벤트를 기다리는 상태
- **Terminated**: 프로세스 실행 완료

## 스레드 (Thread)

### 1. 스레드의 정의

스레드는 프로세스 내에서 실행되는 실행 단위로, 같은 프로세스 내의 다른 스레드와 메모리와 자원을 공유합니다.

#### 특징

- **경량성**: 프로세스보다 생성/전환 비용이 적음
- **공유**: 같은 프로세스 내 스레드들은 메모리와 자원을 공유
- **동시성**: 여러 스레드가 동시에 실행 가능
- **통신**: 공유 메모리를 통한 빠른 통신

### 2. 스레드 구조

```
프로세스
├── 공유 자원
│   ├── 코드 영역
│   ├── 데이터 영역
│   ├── 힙 영역
│   └── 파일 디스크립터
└── 스레드들
    ├── 스레드 1
    │   ├── 스택
    │   ├── 레지스터
    │   └── 상태
    ├── 스레드 2
    │   ├── 스택
    │   ├── 레지스터
    │   └── 상태
    └── 스레드 3
        ├── 스택
        ├── 레지스터
        └── 상태
```

### 3. 스레드 상태

```
     생성
      ↓
   [New] → [Runnable] → [Running] → [Terminated]
              ↑           ↓
           [Blocked] ← [Waiting]
```

- **New**: 스레드가 생성되었지만 아직 시작되지 않음
- **Runnable**: 실행 가능한 상태
- **Running**: CPU에서 실행 중
- **Blocked**: 동기화 블록이나 I/O 대기
- **Waiting**: 다른 스레드의 신호 대기
- **Terminated**: 스레드 실행 완료

## 프로세스 vs 스레드 비교

### 1. 메모리 공유

```javascript
// 프로세스: 독립적인 메모리 공간
const { spawn } = require("child_process");

const process1 = spawn("node", ["worker1.js"]);
const process2 = spawn("node", ["worker2.js"]);

// 각 프로세스는 독립적인 메모리 공간을 가짐
// process1과 process2는 서로의 변수에 접근할 수 없음
```

```javascript
// 스레드: 공유 메모리 공간
const { Worker } = require("worker_threads");

// Node.js에서 Worker는 별도 스레드로 실행
const worker = new Worker(`
  const { parentPort } = require('worker_threads');
  
  // 부모 스레드와 메시지 통신
  parentPort.on('message', (data) => {
    parentPort.postMessage('Processed: ' + data);
  });
`);

worker.on("message", (result) => {
  console.log(result);
});

worker.postMessage("Hello from main thread");
```

### 2. 생성 및 전환 비용

```javascript
// 프로세스 생성 (비용 높음)
const { spawn } = require("child_process");

console.time("process-creation");
const processes = [];

for (let i = 0; i < 10; i++) {
  const proc = spawn("node", ["-e", 'console.log("Process", process.pid)']);
  processes.push(proc);
}

Promise.all(
  processes.map((p) => new Promise((resolve) => p.on("close", resolve)))
).then(() => {
  console.timeEnd("process-creation");
});
```

```javascript
// 스레드 생성 (비용 낮음)
const { Worker } = require("worker_threads");

console.time("thread-creation");
const workers = [];

for (let i = 0; i < 10; i++) {
  const worker = new Worker(`
    const { parentPort } = require('worker_threads');
    parentPort.postMessage('Thread ${i} created');
  `);
  workers.push(worker);
}

Promise.all(
  workers.map((w) => new Promise((resolve) => w.on("message", resolve)))
).then(() => {
  console.timeEnd("thread-creation");
  workers.forEach((w) => w.terminate());
});
```

## 웹 개발에서의 활용

### 1. Node.js 이벤트 루프

```javascript
// Node.js는 단일 스레드 이벤트 루프 모델
console.log("1. Start");

setTimeout(() => {
  console.log("2. Timer callback");
}, 0);

Promise.resolve().then(() => {
  console.log("3. Promise callback");
});

console.log("4. End");

// 출력 순서: 1, 4, 3, 2
// 이벤트 루프가 비동기 작업을 처리
```

### 2. Worker Threads 활용

```javascript
const {
  Worker,
  isMainThread,
  parentPort,
  workerData,
} = require("worker_threads");

if (isMainThread) {
  // 메인 스레드
  console.log("Main thread started");

  // CPU 집약적 작업을 별도 스레드로 실행
  const worker = new Worker(__filename, {
    workerData: { number: 1000000 },
  });

  worker.on("message", (result) => {
    console.log("Result:", result);
  });

  worker.on("error", (error) => {
    console.error("Worker error:", error);
  });

  worker.on("exit", (code) => {
    if (code !== 0) {
      console.error(`Worker stopped with exit code ${code}`);
    }
  });
} else {
  // 워커 스레드
  console.log("Worker thread started");

  // CPU 집약적 작업 (소수 찾기)
  function findPrimes(max) {
    const primes = [];
    for (let i = 2; i <= max; i++) {
      let isPrime = true;
      for (let j = 2; j <= Math.sqrt(i); j++) {
        if (i % j === 0) {
          isPrime = false;
          break;
        }
      }
      if (isPrime) primes.push(i);
    }
    return primes;
  }

  const result = findPrimes(workerData.number);
  parentPort.postMessage({
    count: result.length,
    primes: result.slice(0, 10), // 처음 10개만 전송
  });
}
```

### 3. 클러스터 모듈 (프로세스 기반)

```javascript
const cluster = require("cluster");
const http = require("http");
const numCPUs = require("os").cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  // CPU 코어 수만큼 워커 프로세스 생성
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on("exit", (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    // 워커가 죽으면 새로운 워커 생성
    cluster.fork();
  });
} else {
  // 워커 프로세스
  http
    .createServer((req, res) => {
      res.writeHead(200);
      res.end(`Hello from worker ${process.pid}`);
    })
    .listen(8000);

  console.log(`Worker ${process.pid} started`);
}
```

## 동시성 문제와 해결

### 1. 레이스 컨디션

```javascript
// 문제가 있는 코드
let counter = 0;

// 여러 스레드가 동시에 실행할 수 있음
function increment() {
  const current = counter;
  // 여기서 다른 스레드가 실행될 수 있음
  counter = current + 1;
}

// 해결 방법 1: 뮤텍스 (Node.js에서는 별도 구현 필요)
class Mutex {
  constructor() {
    this.locked = false;
    this.queue = [];
  }

  async acquire() {
    return new Promise((resolve) => {
      if (!this.locked) {
        this.locked = true;
        resolve();
      } else {
        this.queue.push(resolve);
      }
    });
  }

  release() {
    this.locked = false;
    if (this.queue.length > 0) {
      const next = this.queue.shift();
      this.locked = true;
      next();
    }
  }
}

// 해결 방법 2: 원자적 연산
const { Atomics } = require("worker_threads");
const sharedArray = new SharedArrayBuffer(4);
const counter = new Int32Array(sharedArray);

function increment() {
  Atomics.add(counter, 0, 1);
}
```

### 2. 데드락 방지

```javascript
// 데드락이 발생할 수 있는 코드
class BankAccount {
  constructor(id, balance) {
    this.id = id;
    this.balance = balance;
    this.lock = new Mutex();
  }

  async transfer(to, amount) {
    // 데드락 가능성: 계좌 순서에 따라 잠금 순서가 달라질 수 있음
    await this.lock.acquire();
    await to.lock.acquire();

    try {
      this.balance -= amount;
      to.balance += amount;
    } finally {
      to.lock.release();
      this.lock.release();
    }
  }
}

// 해결 방법: 일관된 잠금 순서
class BankAccount {
  constructor(id, balance) {
    this.id = id;
    this.balance = balance;
    this.lock = new Mutex();
  }

  async transfer(to, amount) {
    // ID 순서로 잠금 순서 보장
    const first = this.id < to.id ? this : to;
    const second = this.id < to.id ? to : this;

    await first.lock.acquire();
    await second.lock.acquire();

    try {
      this.balance -= amount;
      to.balance += amount;
    } finally {
      second.lock.release();
      first.lock.release();
    }
  }
}
```

## 성능 최적화 팁

### 1. 적절한 동시성 모델 선택

```javascript
// I/O 집약적 작업: 이벤트 루프 활용
async function handleMultipleRequests() {
  const promises = urls.map((url) => fetch(url));
  const results = await Promise.all(promises);
  return results;
}

// CPU 집약적 작업: Worker Threads 활용
const { Worker } = require("worker_threads");

function runCPUIntensiveTask(data) {
  return new Promise((resolve, reject) => {
    const worker = new Worker(
      `
      const { parentPort } = require('worker_threads');
      const result = heavyComputation(workerData);
      parentPort.postMessage(result);
    `,
      { workerData: data }
    );

    worker.on("message", resolve);
    worker.on("error", reject);
  });
}

// 대량의 독립적 작업: 클러스터 모듈
const cluster = require("cluster");
if (cluster.isMaster) {
  // CPU 코어 수만큼 워커 프로세스 생성
  for (let i = 0; i < require("os").cpus().length; i++) {
    cluster.fork();
  }
}
```

### 2. 메모리 관리

```javascript
// 스레드 간 공유 메모리 사용
const { Worker, SharedArrayBuffer } = require("worker_threads");

// 공유 메모리 버퍼 생성
const sharedBuffer = new SharedArrayBuffer(1024);
const sharedArray = new Int32Array(sharedBuffer);

const worker = new Worker(
  `
  const { parentPort, workerData } = require('worker_threads');
  const sharedArray = new Int32Array(workerData.buffer);
  
  // 공유 메모리에 직접 쓰기
  sharedArray[0] = 42;
  parentPort.postMessage('Updated shared memory');
`,
  { workerData: { buffer: sharedBuffer } }
);

worker.on("message", () => {
  console.log("Shared array value:", sharedArray[0]); // 42
});
```

## 요약

프로세스와 스레드는 웹 개발에서 성능과 동시성을 관리하는 핵심 개념입니다. 각각의 특징과 장단점을 이해하고, 작업의 특성에 맞는 적절한 동시성 모델을 선택하는 것이 중요합니다.
