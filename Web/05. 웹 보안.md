# 웹 보안

## 개요

웹 보안은 웹 애플리케이션과 웹사이트를 다양한 공격으로부터 보호하는 것입니다. 사용자 데이터 보호와 서비스 안정성을 위해 필수적입니다.

**웹 보안이 현대 웹 개발에서 중요한 이유:**
웹 보안은 단순한 기술적 요구사항을 넘어서 사용자 신뢰와 비즈니스 지속가능성을 보장하는 핵심 요소입니다. 보안 취약점은 사용자의 개인정보 유출, 금융적 손실, 브랜드 이미지 훼손 등 심각한 결과를 초래할 수 있으며, 이는 웹 애플리케이션의 성공과 실패를 가르는 중요한 기준이 됩니다.

**웹 보안의 다층적 접근:**
웹 보안은 단일 기술이나 도구로 해결할 수 있는 문제가 아닙니다. 애플리케이션 레벨, 네트워크 레벨, 인프라 레벨 등 다양한 계층에서의 보안 조치가 필요하며, 각 계층은 서로 보완적인 역할을 합니다. 개발자는 이러한 다층적 보안 구조를 이해하고, 각 계층에 적절한 보안 조치를 구현해야 합니다.

**보안과 사용자 경험의 균형:**
보안 조치가 과도하면 사용자 경험이 저하될 수 있습니다. 따라서 보안성과 사용 편의성 사이의 적절한 균형을 찾는 것이 중요합니다. 사용자 인증, 데이터 암호화, 접근 제어 등의 보안 기능을 구현하면서도, 사용자가 불편함을 느끼지 않도록 하는 것이 현대 웹 개발의 핵심 과제입니다.

**지속적인 보안 관리의 필요성:**
웹 보안은 한 번 구현하면 끝나는 것이 아닙니다. 새로운 보안 위협이 지속적으로 등장하고, 기존 보안 조치의 취약점이 발견될 수 있습니다. 따라서 정기적인 보안 점검, 업데이트, 모니터링을 통한 지속적인 보안 관리가 필수적입니다.

## 주요 보안 위협

### 1. OWASP Top 10

- **Injection**: SQL, NoSQL, OS 명령어 주입
- **Broken Authentication**: 인증 취약점
- **Sensitive Data Exposure**: 민감 데이터 노출
- **XML External Entities (XXE)**: XML 외부 엔티티 공격
- **Broken Access Control**: 접근 제어 취약점
- **Security Misconfiguration**: 보안 설정 오류
- **Cross-Site Scripting (XSS)**: 크로스 사이트 스크립팅
- **Insecure Deserialization**: 안전하지 않은 역직렬화
- **Using Components with Known Vulnerabilities**: 알려진 취약점이 있는 컴포넌트 사용
- **Insufficient Logging & Monitoring**: 불충분한 로깅 및 모니터링

## SQL Injection 방어

### 1. SQL Injection 공격 예시

```sql
-- 취약한 쿼리
SELECT * FROM users WHERE username = '$username' AND password = '$password'

-- 공격자가 입력한 값
username: admin' --
password: anything

-- 결과적으로 실행되는 쿼리
SELECT * FROM users WHERE username = 'admin' --' AND password = 'anything'
-- 주석 처리되어 admin 계정으로 로그인 성공
```

### 2. 방어 방법

```javascript
// Node.js - Prepared Statement 사용
const mysql = require("mysql2");

const connection = mysql.createConnection({
  host: "localhost",
  user: "username",
  password: "password",
  database: "database",
});

// 안전한 방법
const query = "SELECT * FROM users WHERE username = ? AND password = ?";
connection.execute(query, [username, password], (err, results) => {
  if (err) throw err;
  console.log(results);
});

// Express.js - ORM 사용
const { User } = require("./models");

// Sequelize ORM
const user = await User.findOne({
  where: {
    username: username,
    password: password,
  },
});
```

## XSS (Cross-Site Scripting) 방어

### 1. XSS 공격 유형

```html
<!-- Stored XSS -->
<script>
  alert("XSS");
</script>
<img src="x" onerror="alert('XSS')" />
<svg onload="alert('XSS')">
  <!-- Reflected XSS -->
  https://example.com/search?q=
  <script>
    alert('XSS')
  </script>

  <!-- DOM-based XSS -->
  document.getElementById('search').innerHTML = location.hash.substring(1);
</svg>
```

### 2. 방어 방법

```javascript
// 1. 입력 데이터 검증 및 이스케이프
const validator = require("validator");

function sanitizeInput(input) {
  return validator.escape(input);
}

// 2. 출력 시 이스케이프
const escapeHtml = require("escape-html");

app.get("/search", (req, res) => {
  const query = req.query.q;
  const sanitizedQuery = escapeHtml(query);
  res.send(`검색 결과: ${sanitizedQuery}`);
});

// 3. Content Security Policy 설정
app.use((req, res, next) => {
  res.setHeader(
    "Content-Security-Policy",
    "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"
  );
  next();
});
```

## CSRF (Cross-Site Request Forgery) 방어

### 1. CSRF 공격 예시

```html
<!-- 악의적인 사이트에서 실행되는 코드 -->
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="amount" value="1000" />
  <input type="hidden" name="to" value="attacker" />
  <input type="submit" value="클릭하세요" />
</form>

<script>
  document.forms[0].submit();
</script>
```

### 2. 방어 방법

```javascript
// 1. CSRF 토큰 사용
const csrf = require("csurf");
const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get("/form", (req, res) => {
  res.render("form", { csrfToken: req.csrfToken() });
});

app.post("/transfer", csrfProtection, (req, res) => {
  // CSRF 토큰 검증
  res.send("Transfer successful");
});

// 2. SameSite 쿠키 설정
app.use(
  session({
    secret: "your-secret",
    cookie: {
      secure: true,
      httpOnly: true,
      sameSite: "strict",
    },
  })
);

// 3. Referer 헤더 검증
app.use((req, res, next) => {
  const referer = req.get("Referer");
  if (referer && !referer.startsWith("https://yourdomain.com")) {
    return res.status(403).send("Forbidden");
  }
  next();
});
```

## 인증 및 권한 관리

### 1. 안전한 비밀번호 정책

```javascript
const bcrypt = require("bcrypt");
const passwordValidator = require("password-validator");

const schema = new passwordValidator();

schema
  .is()
  .min(8)
  .is()
  .max(100)
  .has()
  .uppercase()
  .has()
  .lowercase()
  .has()
  .digits()
  .has()
  .symbols()
  .has()
  .not()
  .spaces();

function validatePassword(password) {
  return schema.validate(password);
}

async function hashPassword(password) {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
}

async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash);
}
```

### 2. JWT 토큰 관리

```javascript
const jwt = require("jsonwebtoken");

// 토큰 생성
function generateToken(user) {
  return jwt.sign(
    {
      userId: user.id,
      email: user.email,
      role: user.role,
    },
    process.env.JWT_SECRET,
    {
      expiresIn: "1h",
      issuer: "your-app",
      audience: "your-app-users",
    }
  );
}

// 토큰 검증
function verifyToken(token) {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    throw new Error("Invalid token");
  }
}

// 권한 검증 미들웨어
function requireRole(role) {
  return (req, res, next) => {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) {
      return res.status(401).json({ message: "Token required" });
    }

    try {
      const decoded = verifyToken(token);
      if (decoded.role !== role && decoded.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      req.user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({ message: "Invalid token" });
    }
  };
}
```

## 파일 업로드 보안

### 1. 안전한 파일 업로드

```javascript
const multer = require("multer");
const path = require("path");

// 파일 타입 검증
const fileFilter = (req, file, cb) => {
  const allowedTypes = ["image/jpeg", "image/png", "image/gif"];

  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error("Invalid file type"), false);
  }
};

// 파일 크기 제한
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/");
  },
  filename: (req, file, cb) => {
    // 원본 파일명 대신 안전한 파일명 생성
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
    files: 1,
  },
});

// 파일 확장자 검증
function validateFileExtension(filename) {
  const allowedExtensions = [".jpg", ".jpeg", ".png", ".gif"];
  const ext = path.extname(filename).toLowerCase();
  return allowedExtensions.includes(ext);
}
```

## 보안 헤더 설정

### 1. 보안 헤더 미들웨어

```javascript
const helmet = require("helmet");

app.use(helmet());

// 추가 보안 헤더
app.use((req, res, next) => {
  // XSS 방지
  res.setHeader("X-XSS-Protection", "1; mode=block");

  // 클릭재킹 방지
  res.setHeader("X-Frame-Options", "DENY");

  // MIME 타입 스니핑 방지
  res.setHeader("X-Content-Type-Options", "nosniff");

  // HSTS (HTTPS 강제)
  res.setHeader(
    "Strict-Transport-Security",
    "max-age=31536000; includeSubDomains"
  );

  // Content Security Policy
  res.setHeader(
    "Content-Security-Policy",
    "default-src 'self'; " +
      "script-src 'self' 'unsafe-inline'; " +
      "style-src 'self' 'unsafe-inline'; " +
      "img-src 'self' data: https:; " +
      "font-src 'self'; " +
      "connect-src 'self';"
  );

  next();
});
```

### 2. CORS 설정

```javascript
const cors = require("cors");

const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = [
      "https://yourdomain.com",
      "https://app.yourdomain.com",
    ];

    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"],
};

app.use(cors(corsOptions));
```

## 로깅 및 모니터링

### 1. 보안 이벤트 로깅

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'security.log' }),
    new winston.transports.Console()
  ]
});

// 로그인 시도 로깅
app.post('/login', (req, res) => {
  const { username, ip } = req.body;

  logger.info('Login attempt', {
    username,
    ip,
    timestamp: new Date(),
    userAgent: req.get('User-Agent')
  });

  // 로그인 로직...
});

// 실패한 로그인 시도 모니터링
function monitorFailedLogins(username, ip) {
  const key = `failed_login:${username}:${ip}`;
  const failedCount = await redis.incr(key);

  if (failedCount === 1) {
    await redis.expire(key, 3600); // 1시간 후 만료
  }

  if (failedCount >= 5) {
    logger.warn('Multiple failed login attempts', { username, ip, count: failedCount });
    // 계정 잠금 또는 추가 보안 조치
  }
}
```

### 2. Rate Limiting

```javascript
const rateLimit = require("express-rate-limit");

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 5, // 최대 5번 시도
  message: "Too many login attempts, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    logger.warn("Rate limit exceeded", {
      ip: req.ip,
      endpoint: req.path,
    });
    res.status(429).json({
      error: "Too many requests",
      retryAfter: Math.ceil((15 * 60) / 1000),
    });
  },
});

app.use("/login", loginLimiter);
```

## 요약

웹 보안은 지속적인 학습과 업데이트가 필요한 분야입니다. OWASP 가이드라인을 따르고, 최신 보안 위협에 대한 정보를 습득하며, 보안 테스트를 정기적으로 수행하는 것이 중요합니다.
