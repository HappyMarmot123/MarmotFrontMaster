# DOM (Document Object Model)

## 개요

DOM(Document Object Model)은 HTML 문서의 구조를 객체로 표현한 모델입니다. 웹 페이지의 모든 요소를 JavaScript로 조작할 수 있게 해주는 인터페이스입니다.

**DOM의 중요성과 역할:**
DOM은 웹 개발의 핵심으로, 정적인 HTML 문서를 동적이고 인터랙티브한 웹 애플리케이션으로 변환하는 기반이 됩니다. 사용자의 클릭, 입력, 스크롤 등의 이벤트에 반응하여 페이지 내용을 실시간으로 변경할 수 있게 해주며, 이는 현대적인 웹 사용자 경험의 핵심입니다.

**DOM의 구조적 특징:**
DOM은 트리 구조로 구성되어 있어, 각 HTML 요소는 노드(Node)로 표현되고 부모-자식 관계를 가집니다. 이 구조는 문서의 계층적 관계를 명확하게 표현하며, JavaScript를 통해 특정 요소를 쉽게 찾고 조작할 수 있게 해줍니다. 또한 DOM의 변경은 즉시 화면에 반영되어 사용자에게 실시간 피드백을 제공합니다.

**DOM과 웹 성능의 관계:**
DOM 조작은 웹 성능에 직접적인 영향을 미칩니다. 과도한 DOM 변경은 리플로우와 리페인트를 발생시켜 페이지가 버벅이거나 느려질 수 있습니다. 따라서 효율적인 DOM 조작 방법을 이해하고 적용하는 것이 중요합니다. 특히 대량의 데이터를 처리하거나 복잡한 애니메이션을 구현할 때는 DOM 최적화가 필수적입니다.

## DOM 구조

### 1. DOM 트리

```
Document
├── html
    ├── head
    │   ├── title
    │   ├── meta
    │   └── link
    └── body
        ├── header
        ├── main
        │   ├── section
        │   └── article
        └── footer
```

### 2. 노드 타입

- **Element Node**: HTML 요소 (`<div>`, `<p>` 등)
- **Text Node**: 텍스트 내용
- **Attribute Node**: 속성
- **Comment Node**: 주석
- **Document Node**: 문서 전체

## DOM 조작 기본

### 1. 요소 선택

DOM 요소 선택은 DOM 조작의 첫 번째 단계로, 원하는 요소를 찾아서 조작할 수 있게 해줍니다. 다양한 선택 방법이 있으며, 각각의 성능과 사용법이 다릅니다.

**요소 선택의 핵심 원칙:**

- **ID 선택자**: 가장 빠르지만 페이지당 하나의 요소만 선택 가능
- **클래스 선택자**: 여러 요소를 그룹으로 선택할 때 유용
- **태그 선택자**: 특정 태그를 가진 모든 요소를 선택
- **CSS 선택자**: 복잡한 조건으로 요소를 선택할 수 있지만 성능이 상대적으로 느림

**선택자 성능 고려사항:**
`getElementById`는 가장 빠른 방법이지만, `querySelector`와 `querySelectorAll`은 CSS 선택자를 사용하여 더 유연한 선택이 가능합니다. 대량의 요소를 처리할 때는 성능을 고려하여 적절한 선택자를 사용해야 합니다.

**실제 적용 예시:**

```javascript
// ID로 선택 (가장 빠름)
const element = document.getElementById("myId");

// 클래스로 선택
const elements = document.getElementsByClassName("myClass");

// 태그로 선택
const divs = document.getElementsByTagName("div");

// CSS 선택자로 선택 (유연하지만 상대적으로 느림)
const element = document.querySelector(".myClass");
const elements = document.querySelectorAll(".myClass");
```

### 2. 요소 생성 및 추가

DOM 요소 생성 및 추가는 동적으로 웹페이지 내용을 변경하는 핵심 기능입니다. 사용자 상호작용이나 데이터 변경에 따라 페이지를 실시간으로 업데이트할 수 있게 해줍니다.

**요소 생성의 핵심 원칙:**

- **효율적인 생성**: 필요한 속성과 내용을 한 번에 설정하여 DOM 조작 횟수 최소화
- **적절한 추가 위치**: `appendChild`, `insertBefore` 등을 사용하여 올바른 위치에 요소 배치
- **메모리 관리**: 더 이상 필요하지 않은 요소는 적절히 제거하여 메모리 누수 방지

**성능 최적화 전략:**
DOM 조작은 비용이 큰 작업이므로, 여러 요소를 한 번에 처리하거나 DocumentFragment를 사용하여 일괄 처리하는 것이 좋습니다. 또한 DOM 쿼리 결과를 캐싱하여 반복적인 조회를 방지해야 합니다.

**실제 적용 예시:**

```javascript
// 요소 생성 및 속성 설정
const div = document.createElement("div");
div.textContent = "새로운 div";
div.className = "new-div";

// 요소 추가
document.body.appendChild(div);

// 특정 위치에 추가
const parent = document.querySelector(".parent");
const newElement = document.createElement("span");
parent.insertBefore(newElement, parent.firstChild);
```

### 3. 요소 수정

```javascript
const element = document.querySelector(".target");

// 텍스트 내용 변경
element.textContent = "새로운 텍스트";
element.innerHTML = "<strong>강조된 텍스트</strong>";

// 속성 변경
element.setAttribute("class", "new-class");
element.className = "new-class";
element.id = "new-id";

// 스타일 변경
element.style.backgroundColor = "red";
element.style.fontSize = "16px";
```

### 4. 요소 제거

```javascript
const element = document.querySelector(".target");

// 요소 제거
element.remove();

// 부모에서 자식 제거
const parent = element.parentNode;
parent.removeChild(element);
```

## 이벤트 처리

### 1. 이벤트 리스너 추가

```javascript
const button = document.querySelector("button");

// 클릭 이벤트
button.addEventListener("click", function (event) {
  console.log("버튼이 클릭되었습니다!");
  console.log("이벤트 객체:", event);
});

// 마우스 이벤트
button.addEventListener("mouseenter", function () {
  this.style.backgroundColor = "yellow";
});

button.addEventListener("mouseleave", function () {
  this.style.backgroundColor = "";
});
```

### 2. 이벤트 위임

```javascript
// 부모 요소에 이벤트 리스너 추가
document.querySelector(".parent").addEventListener("click", function (event) {
  // 클릭된 요소가 button인지 확인
  if (event.target.tagName === "BUTTON") {
    console.log("버튼이 클릭되었습니다:", event.target.textContent);
  }
});
```

### 3. 이벤트 리스너 제거

```javascript
const button = document.querySelector("button");

function handleClick() {
  console.log("클릭!");
}

button.addEventListener("click", handleClick);

// 이벤트 리스너 제거
button.removeEventListener("click", handleClick);
```

## DOM 트래버싱

### 1. 부모-자식 관계

```javascript
const element = document.querySelector(".target");

// 부모 요소
const parent = element.parentNode;
const parentElement = element.parentElement;

// 자식 요소들
const children = element.childNodes; // 모든 노드
const childElements = element.children; // 요소 노드만

// 첫 번째/마지막 자식
const firstChild = element.firstChild;
const lastChild = element.lastChild;
const firstElementChild = element.firstElementChild;
const lastElementChild = element.lastElementChild;
```

### 2. 형제 관계

```javascript
const element = document.querySelector(".target");

// 이전/다음 형제
const previousSibling = element.previousSibling;
const nextSibling = element.nextSibling;
const previousElementSibling = element.previousElementSibling;
const nextElementSibling = element.nextElementSibling;
```

## 성능 최적화

### 1. DOM 조작 최소화

```javascript
// 나쁜 예: 반복적인 DOM 조작
for (let i = 0; i < 1000; i++) {
  const div = document.createElement("div");
  div.textContent = `Item ${i}`;
  document.body.appendChild(div);
}

// 좋은 예: DocumentFragment 사용
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement("div");
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
document.body.appendChild(fragment);
```

### 2. 이벤트 리스너 최적화

```javascript
// 나쁜 예: 각 요소마다 이벤트 리스너
const buttons = document.querySelectorAll("button");
buttons.forEach((button) => {
  button.addEventListener("click", handleClick);
});

// 좋은 예: 이벤트 위임
document.addEventListener("click", function (event) {
  if (event.target.tagName === "BUTTON") {
    handleClick(event);
  }
});
```

### 3. DOM 쿼리 최적화

```javascript
// 나쁜 예: 반복적인 DOM 쿼리
for (let i = 0; i < 100; i++) {
  const element = document.querySelector(".target");
  element.style.color = "red";
}

// 좋은 예: DOM 쿼리 결과 캐싱
const element = document.querySelector(".target");
for (let i = 0; i < 100; i++) {
  element.style.color = "red";
}
```

## 모던 DOM API

### 1. Intersection Observer

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      entry.target.classList.add("visible");
    }
  });
});

// 관찰할 요소들
document.querySelectorAll(".observe").forEach((el) => {
  observer.observe(el);
});
```

### 2. Mutation Observer

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.type === "childList") {
      console.log("DOM이 변경되었습니다");
    }
  });
});

observer.observe(document.body, {
  childList: true,
  subtree: true,
});
```

### 3. Resize Observer

```javascript
const observer = new ResizeObserver((entries) => {
  entries.forEach((entry) => {
    console.log("요소 크기가 변경되었습니다:", entry.contentRect);
  });
});

observer.observe(document.querySelector(".resizable"));
```

## 요약

DOM은 웹 페이지를 동적으로 조작하는 핵심 기술입니다. 효율적인 DOM 조작과 이벤트 처리를 통해 사용자 경험을 향상시킬 수 있습니다. 성능 최적화를 고려한 코딩 습관이 중요합니다.
