# 실행 컨텍스트 (Execution Context)

## 📖 개요

실행 컨텍스트는 자바스크립트 코드가 실행되는 환경을 추상화한 개념입니다. 하나의 함수가 실행될 때 참조해야 하는 (변수 객체, 스코프 체인, this) 값들의 집합입니다. **"코드가 실행될 때 필요한 모든 정보"**를 담고 있는 특별한 객체라고 생각하면 이해하기 쉽습니다.

참조값을 모두 찾고, 값이 존재하지 않을 때 렉시컬 환경의 외부 환경 참조를 합니다. 자바스크립트 코드의 환경과 순서 보장을 위함입니다.

## 🏗️ 실행 컨텍스트의 핵심 구성 요소

자바스크립트 엔진이 코드를 실행할 때마다 실행 컨텍스트가 생성되며, 이는 크게 세 가지 구성 요소를 가집니다.

### 1. 변수 환경 (Variable Environment)

- `var`로 선언된 변수나 함수 선언문 같은 정보를 저장합니다.
- `let`, `const`로 선언된 변수는 이 환경에 속하지만, 초기화되기 전까지는 접근할 수 없습니다.

### 2. 렉시컬 환경 (Lexical Environment)

- **실행 중인 코드가 접근할 수 있는 식별자(변수, 함수 선언 등)를 관리**합니다.
- **환경 레코드(Environment Record)**: 현재 스코프의 변수와 함수를 저장하는 공간입니다.
- **외부 렉시컬 환경 참조(Outer Lexical Environment Reference)**: 상위 스코프에 대한 참조를 담고 있습니다. 이 참조를 통해 스코프 체인(Scope Chain)이 형성되어 상위 스코프의 변수에 접근할 수 있게 됩니다.

### 3. `this` 바인딩 (This Binding)

- 코드가 실행될 때 `this` 키워드가 가리키는 객체를 결정합니다.
- `this`의 값은 함수가 어떻게 호출되었는지에 따라 동적으로 바뀝니다.

## 🔄 실행 컨텍스트의 작동 방식

실행 컨텍스트는 **실행 컨텍스트 스택(Execution Context Stack)**이라는 자료 구조에 쌓였다가 제거되는 방식으로 작동합니다.

### 스택 구조의 동작 원리

1. **전역 실행 컨텍스트**: 코드를 실행하면 가장 먼저 전역 실행 컨텍스트가 스택에 들어갑니다. 이는 애플리케이션의 전체 생명주기를 관리합니다.
2. **함수 실행 컨텍스트**: 함수가 호출될 때마다 새로운 함수 실행 컨텍스트가 생성되어 스택의 맨 위에 쌓입니다.
3. **실행과 제거**: 스택의 맨 위에 있는 실행 컨텍스트가 실행을 마친 후, 스택에서 제거됩니다.

### 실제 동작 예시

```javascript
function first() {
  console.log("첫 번째 함수");
  second();
  console.log("다시 첫 번째 함수");
}

function second() {
  console.log("두 번째 함수");
}

first();
```

위 코드를 실행할 때, 실행 컨텍스트 스택은 다음과 같이 변합니다.

1. **[Global Context]**: 코드가 시작되면 전역 컨텍스트가 스택에 들어갑니다.
2. **[Global, first]**: `first()` 함수가 호출되어 `first` 함수의 컨텍스트가 스택에 추가됩니다.
3. **[Global, first, second]**: `first` 함수 내부에서 `second()`가 호출되어 `second` 함수의 컨텍스트가 추가됩니다.
4. **[Global, first]**: `second` 함수가 실행을 마치고 스택에서 제거됩니다.
5. **[Global]**: `first` 함수가 실행을 마치고 스택에서 제거됩니다.
6. **[]**: 모든 코드가 실행되면 전역 컨텍스트도 제거됩니다.

## 💡 실행 컨텍스트 과정

```javascript
function example() {
  var x = 10;
  let y = 20;

  function inner() {
    console.log(x + y);
  }

  return inner;
}
```

**생성 단계에서 일어나는 일**:

1. **렉시컬 환경 생성**: 현재 스코프의 변수와 함수 정보 수집
2. **환경 레코드 생성**: 식별자들을 미리 등록
3. **외부 환경 참조 설정**: 상위 스코프와의 연결 설정
4. **this 바인딩**: 함수 호출 방식에 따른 this 값 결정

**실행 단계에서 일어나는 일**:

1. **코드 실행**: 실제 JavaScript 코드가 순차적으로 실행
2. **변수 할당**: 선언된 변수에 실제 값 할당
3. **함수 호출**: 함수가 호출될 때마다 새로운 실행 컨텍스트 생성

## 🔍 실행 컨텍스트와 스코프 체인

### 스코프 체인 형성

```javascript
const globalVar = "전역 변수";

function outer() {
  const outerVar = "외부 함수 변수";

  function inner() {
    const innerVar = "내부 함수 변수";

    console.log(globalVar + outerVar + innerVar);
  }

  return inner;
}

const innerFunc = outer();
innerFunc();
```

**실행 컨텍스트 스택과 스코프 체인**:

```
실행 컨텍스트 스택:
[Global Context] ← [outer Context] ← [inner Context]

스코프 체인:
inner → outer → Global
```

### 변수 검색 과정

1. **현재 실행 컨텍스트**의 렉시컬 환경에서 변수 검색
2. **찾지 못한 경우** 외부 렉시컬 환경 참조를 따라 상위 스코프로 이동
3. **전역 스코프까지** 검색하여 변수를 찾거나 `ReferenceError` 발생

## ⚡ 실행 컨텍스트의 실제 활용

### 1. 클로저와 실행 컨텍스트

```javascript
function createCounter() {
  let count = 0; // 이 변수는 createCounter의 실행 컨텍스트에 저장

  return function () {
    count++; // 외부 실행 컨텍스트의 변수에 접근
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

**클로저 동작 원리**:

- 내부 함수가 반환될 때, 외부 함수의 실행 컨텍스트에 대한 참조를 유지
- 외부 함수의 실행 컨텍스트가 종료되어도 렉시컬 환경은 메모리에 보존
- 내부 함수가 외부 변수에 계속 접근 가능

**호이스팅 메커니즘**:

- **생성 단계**: 모든 변수와 함수 선언을 환경 레코드에 미리 등록
- **실행 단계**: 실제 값 할당 및 코드 실행

**this 바인딩 과정**:

1. **메서드 호출**: `obj.method()`로 호출 시 `this`는 `obj` 객체
2. **화살표 함수**: 렉시컬 환경의 `this`를 상속받아 `obj` 객체 유지

## 📚 실행 컨텍스트의 중요성

이처럼 실행 컨텍스트는 코드가 실행되는 순서를 관리하고, 각 스코프의 변수와 `this` 같은 중요한 정보를 추적하는 역할을 합니다. 이 개념을 이해하면 스코프, 클로저, 호이스팅, `this` 바인딩 등 자바스크립트의 핵심 메커니즘을 더 깊이 이해할 수 있습니다.

### 핵심 역할

1. **코드 실행 관리**: 함수 호출과 반환의 순서 제어
2. **변수 관리**: 각 스코프별 변수의 생명주기 관리
3. **스코프 체인**: 상위 스코프로의 체계적인 변수 검색
4. **this 바인딩**: 함수 호출 방식에 따른 this 값 결정
