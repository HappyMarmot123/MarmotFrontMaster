# 객체와 히든 클래스 (Objects and Hidden Classes)

## 📖 개요

히든 클래스와 딕셔너리 모드는 자바스크립트 V8 엔진이 일반 객체(`{}`)의 성능을 최적화하기 위해 사용하는 내부 메커니즘입니다. 이 둘은 객체의 속성 접근 속도에 직접적인 영향을 미칩니다.

## 🏗️ 히든 클래스의 기본 개념

### 히든 클래스란?

히든 클래스는 V8 엔진이 객체의 구조를 효율적으로 관리하기 위해 내부적으로 생성하는 클래스입니다. 자바스크립트는 객체의 속성을 런타임에 동적으로 추가하거나 삭제할 수 있어, C++ 같은 정적 언어보다 속성 접근이 느립니다. V8 엔진은 이 문제를 해결하기 위해, 객체의 속성들이 추가되는 순서와 구조를 기록하는 히든 클래스를 만들어 최적화를 시도합니다.

### 딕셔너리 모드란?

딕셔너리 모드는 히든 클래스를 통한 최적화가 불가능하거나 비효율적일 때 V8 엔진이 사용하는 차선책입니다. 객체의 속성 구조가 지나치게 자주, 불규칙하게 변경되면 V8은 객체를 딕셔너리 모드로 전환합니다.

## 🎯 V8 엔진의 내부 최적화 원리

V8 엔진의 내부 최적화 원리를 이해하고 코드를 작성하면, 자바스크립트 애플리케이션의 성능을 한 단계 끌어올릴 수 있습니다.

### 핵심 최적화 원칙

1. **동일 순서로 속성 추가**: 반복적으로 생성되는 객체는 항상 같은 순서로 속성을 추가해 V8이 같은 히든 클래스를 재사용하도록 유도합니다.
2. **동적 속성 피하기**: 런타임에 속성 이름이 결정되는 코드는 딕셔너리 모드를 유발하여 성능 저하를 가져올 수 있으므로, 되도록 정적인 속성 이름을 사용하세요.

## 💡 최적화된 객체 생성 방법

### 1. 동일한 순서로 속성 추가하기 (O) vs. 다른 순서로 추가하기 (X)

V8 엔진은 객체에 속성이 추가되는 순서에 따라 **히든 클래스(Hidden Class)**를 생성합니다. 따라서 동일한 구조의 객체를 여러 개 만들 때는 같은 순서로 속성을 추가하는 것이 효율적입니다.

#### 비효율적인 예시 (X): 다른 순서로 속성 추가

```javascript
// 두 객체 user1과 user2의 속성을 다른 순서로 추가하면,
// V8 엔진은 이 둘을 다른 구조로 인식하고 각각 별개의 히든 클래스를 생성합니다.

const user1 = {};
user1.name = "철수";
user1.age = 30;
// V8: 히든 클래스 H1 생성 (name, age)

const user2 = {};
user2.age = 25;
user2.name = "영희";
// V8: 히든 클래스 H2 생성 (age, name)

// H1과 H2는 다른 클래스이므로 최적화 효과가 떨어짐
```

#### 효율적인 예시 (O): 동일한 순서로 속성 추가

```javascript
// 속성을 동일한 순서로 추가하면, V8 엔진은 두 객체가
// 동일한 히든 클래스를 공유한다고 판단하여 최적화합니다.

function createUser(name, age) {
  const user = {};
  user.name = name; // 항상 첫 번째 속성
  user.age = age; // 항상 두 번째 속성
  return user;
}

const user1 = createUser("철수", 30);
const user2 = createUser("영희", 25);
// V8: 동일한 히든 클래스 H1 공유 (name, age)
```

### 2. 동적 속성 할당 피하기 (O) vs. 동적 속성 할당하기 (X)

객체의 속성 이름이 런타임에 동적으로 결정되면, V8 엔진은 히든 클래스 최적화를 포기하고 **딕셔너리 모드(Dictionary Mode)**로 전환합니다. 딕셔너리 모드는 속성 접근 속도가 느립니다.

#### 비효율적인 예시 (X): 동적 속성 할당

```javascript
// 아래 코드는 속성 이름을 변수로 할당하여 동적으로 만듭니다.

const user = {};
const key = "name";
user[key] = "보람";
// V8: 이 객체는 히든 클래스로 관리할 수 없다고 판단하고 딕셔너리 모드로 전환
// 'name'이라는 속성이 존재할지 안 할지 예측할 수 없기 때문입니다.

// 추가적인 동적 속성 할당
const dynamicKey = "age";
user[dynamicKey] = 25;
user["email"] = "boram@example.com";
// 계속해서 딕셔너리 모드 유지
```

#### 효율적인 예시 (O): 정적 속성 할당

```javascript
// 속성을 동적으로 할당하는 대신, 가능한 한 정적으로 속성 이름을 지정하는 것이 좋습니다.

const user = {
  name: "보람",
  age: 25,
  email: "boram@example.com",
};
// V8: 정적 구조로 인식하여 히든 클래스 최적화 적용

// 또는 함수로 생성하되 일관된 순서 유지
function createUser(name, age, email) {
  const user = {};
  user.name = name; // 항상 첫 번째
  user.age = age; // 항상 두 번째
  user.email = email; // 항상 세 번째
  return user;
}
```
