# 객체와 히든 클래스 (Objects and Hidden Classes)

## 📖 개요

히든 클래스와 딕셔너리 모드는 자바스크립트 V8 엔진이 일반 객체(`{}`)의 성능을 최적화하기 위해 사용하는 내부 메커니즘입니다. 이 둘은 객체의 속성 접근 속도에 직접적인 영향을 미칩니다.

## 🏗️ 히든 클래스의 기본 개념

### 히든 클래스란?

히든 클래스는 V8 엔진이 객체의 구조를 효율적으로 관리하기 위해 내부적으로 생성하는 클래스입니다. 자바스크립트는 객체의 속성을 런타임에 동적으로 추가하거나 삭제할 수 있어, C++ 같은 정적 언어보다 속성 접근이 느립니다. V8 엔진은 이 문제를 해결하기 위해, 객체의 속성들이 추가되는 순서와 구조를 기록하는 히든 클래스를 만들어 최적화를 시도합니다.

### 딕셔너리 모드란?

딕셔너리 모드는 히든 클래스를 통한 최적화가 불가능하거나 비효율적일 때 V8 엔진이 사용하는 차선책입니다. 객체의 속성 구조가 지나치게 자주, 불규칙하게 변경되면 V8은 객체를 딕셔너리 모드로 전환합니다.

## 🎯 V8 엔진의 내부 최적화 원리

V8 엔진의 내부 최적화 원리를 이해하고 코드를 작성하면, 자바스크립트 애플리케이션의 성능을 한 단계 끌어올릴 수 있습니다.

### 핵심 최적화 원칙

1. **동일 순서로 속성 추가**: 반복적으로 생성되는 객체는 항상 같은 순서로 속성을 추가해 V8이 같은 히든 클래스를 재사용하도록 유도합니다.
2. **동적 속성 피하기**: 런타임에 속성 이름이 결정되는 코드는 딕셔너리 모드를 유발하여 성능 저하를 가져올 수 있으므로, 되도록 정적인 속성 이름을 사용하세요.

## 💡 최적화된 객체 생성 방법

### 1. 동일한 순서로 속성 추가하기 (O) vs. 다른 순서로 추가하기 (X)

V8 엔진은 객체에 속성이 추가되는 순서에 따라 **히든 클래스(Hidden Class)**를 생성합니다. 따라서 동일한 구조의 객체를 여러 개 만들 때는 같은 순서로 속성을 추가하는 것이 효율적입니다.

#### 비효율적인 예시 (X): 다른 순서로 속성 추가

```javascript
// 두 객체 user1과 user2의 속성을 다른 순서로 추가하면,
// V8 엔진은 이 둘을 다른 구조로 인식하고 각각 별개의 히든 클래스를 생성합니다.

const user1 = {};
user1.name = "철수";
user1.age = 30;
// V8: 히든 클래스 H1 생성 (name, age)

const user2 = {};
user2.age = 25;
user2.name = "영희";
// V8: 히든 클래스 H2 생성 (age, name)

// H1과 H2는 다른 클래스이므로 최적화 효과가 떨어짐
```

#### 효율적인 예시 (O): 동일한 순서로 속성 추가

```javascript
// 속성을 동일한 순서로 추가하면, V8 엔진은 두 객체가
// 동일한 히든 클래스를 공유한다고 판단하여 최적화합니다.

function createUser(name, age) {
  const user = {};
  user.name = name; // 항상 첫 번째 속성
  user.age = age; // 항상 두 번째 속성
  return user;
}

const user1 = createUser("철수", 30);
const user2 = createUser("영희", 25);
// V8: 동일한 히든 클래스 H1 공유 (name, age)
```

### 2. 동적 속성 할당 피하기 (O) vs. 동적 속성 할당하기 (X)

객체의 속성 이름이 런타임에 동적으로 결정되면, V8 엔진은 히든 클래스 최적화를 포기하고 **딕셔너리 모드(Dictionary Mode)**로 전환합니다. 딕셔너리 모드는 속성 접근 속도가 느립니다.

#### 비효율적인 예시 (X): 동적 속성 할당

```javascript
// 아래 코드는 속성 이름을 변수로 할당하여 동적으로 만듭니다.

const user = {};
const key = "name";
user[key] = "보람";
// V8: 이 객체는 히든 클래스로 관리할 수 없다고 판단하고 딕셔너리 모드로 전환
// 'name'이라는 속성이 존재할지 안 할지 예측할 수 없기 때문입니다.

// 추가적인 동적 속성 할당
const dynamicKey = "age";
user[dynamicKey] = 25;
user["email"] = "boram@example.com";
// 계속해서 딕셔너리 모드 유지
```

#### 효율적인 예시 (O): 정적 속성 할당

```javascript
// 속성을 동적으로 할당하는 대신, 가능한 한 정적으로 속성 이름을 지정하는 것이 좋습니다.

const user = {
  name: "보람",
  age: 25,
  email: "boram@example.com",
};
// V8: 정적 구조로 인식하여 히든 클래스 최적화 적용

// 또는 함수로 생성하되 일관된 순서 유지
function createUser(name, age, email) {
  const user = {};
  user.name = name; // 항상 첫 번째
  user.age = age; // 항상 두 번째
  user.email = email; // 항상 세 번째
  return user;
}
```

## ⚡ 성능 최적화 기법

### 1. 객체 팩토리 패턴

```javascript
// 최적화된 객체 생성 함수
function createProduct(id, name, price, category) {
  const product = {};
  product.id = id; // 항상 첫 번째
  product.name = name; // 항상 두 번째
  product.price = price; // 항상 세 번째
  product.category = category; // 항상 네 번째
  return product;
}

// 대량의 객체 생성
const products = [];
for (let i = 0; i < 10000; i++) {
  products.push(createProduct(i, `Product ${i}`, i * 10, "electronics"));
}
```

### 2. 클래스 기반 객체 생성

```javascript
class User {
  constructor(name, age, email) {
    this.name = name; // 항상 같은 순서
    this.age = age;
    this.email = email;
  }

  // 메서드 추가
  getInfo() {
    return `${this.name} (${this.age}) - ${this.email}`;
  }
}

// 클래스 인스턴스는 자동으로 최적화됨
const users = [];
for (let i = 0; i < 1000; i++) {
  users.push(new User(`User ${i}`, 20 + i, `user${i}@example.com`));
}
```

### 3. 객체 리터럴 최적화

```javascript
// 객체 리터럴은 이미 최적화됨
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3,
  debug: false,
};

// 동일한 구조의 객체를 여러 개 생성할 때
const configs = [
  { apiUrl: "https://dev.example.com", timeout: 1000, retries: 1, debug: true },
  {
    apiUrl: "https://staging.example.com",
    timeout: 3000,
    retries: 2,
    debug: false,
  },
  {
    apiUrl: "https://prod.example.com",
    timeout: 5000,
    retries: 3,
    debug: false,
  },
];
```

## ⚠️ 성능 저하를 유발하는 패턴

### 1. 동적 속성 이름 사용

```javascript
// ❌ 성능 저하 패턴
function createDynamicObject(properties) {
  const obj = {};
  for (const [key, value] of Object.entries(properties)) {
    obj[key] = value; // 동적 속성 할당
  }
  return obj;
}

const dynamicObj = createDynamicObject({
  prop1: "value1",
  prop2: "value2",
  prop3: "value3",
});
// V8: 딕셔너리 모드로 전환
```

### 2. 속성 삭제

```javascript
// ❌ 속성 삭제는 히든 클래스 변경을 유발
const user = {
  name: "철수",
  age: 30,
  email: "chulsoo@example.com",
};

delete user.email; // 히든 클래스 변경
// V8: 새로운 히든 클래스 생성 필요
```

### 3. 속성 순서 변경

```javascript
// ❌ 속성 순서가 변경되면 히든 클래스가 달라짐
const user1 = { name: "철수", age: 30 };
const user2 = { age: 25, name: "영희" };

// user1과 user2는 다른 히든 클래스를 가짐
```
