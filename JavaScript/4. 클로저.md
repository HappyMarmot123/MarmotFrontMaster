# 클로저 (Closure)

**클로저**는 함수와 그 함수가 선언될 당시의 **렉시컬 환경(Lexical Environment)**의 조합을 의미합니다. 간단히 말해, 함수가 자신의 외부 스코프에 있는 변수들을 기억하고 접근하는 능력을 말합니다.

## 클로저는 왜 생기는가?

클로저는 **내부 함수가 외부 함수의 변수에 접근할 수 있는 모든 경우에 생성**됩니다. 함수가 반환되어 어딘가에 바인딩될 때뿐만 아니라, 그 밖의 다양한 상황에서도 발생할 수 있습니다. 클로저는 함수가 외부로 반환되든, 콜백으로 전달되든, 또는 다른 방식으로 외부 스코프를 벗어나든 상관없이 형성될 수 있습니다.

## 메모리 관리와 클로저

클로저는 강력하지만 **잘못 사용하면 메모리 누수가 발생**할 수 있습니다. 클로저가 참조하는 외부 변수들은 가비지 컬렉션의 대상이 되지 않아, 필요 이상으로 오래 유지되어 불필요한 메모리를 점유하게 됩니다.

### 메모리 누수의 예시

```javascript
// ❌ 나쁜 예: 큰 배열을 클로저로 참조
function createMemoryLeak() {
  const hugeArray = new Array(1000000).fill("data"); // 100만 개의 문자열

  return function () {
    // 실제로는 hugeArray[0]만 사용하지만
    // 전체 배열이 메모리에 계속 유지됨
    console.log(hugeArray[0]);
  };
}

const leakyFunction = createMemoryLeak();
// hugeArray는 여전히 메모리에 존재하며 가비지 컬렉션되지 않음
```

### 메모리 효율적인 클로저

```javascript
// ✅ 좋은 예: 필요한 데이터만 참조
function createEfficientObj() {
  const array = new Array(100000).fill("data");
  const useful = array[0]; // 필요한 데이터만 추출

  return function () {
    console.log(useful); // 작은 데이터만 참조
  };
}

let arrFunc = createEfficientObj();
// array는 가비지 컬렉션의 대상이 될 수 있음
// useful만 클로저에 의해 유지됨
```

### 기본 클로저 예시

```javascript
function makeCounter() {
  let count = 0; // 💡 렉시컬 환경의 일부

  function counter() {
    count++; // 외부 스코프의 count 변수에 접근
    console.log(count);
  }

  return counter;
}

const myCounter = makeCounter();
myCounter(); // 1
myCounter(); // 2
```

### 클로저의 동작 원리

`makeCounter()` 함수는 `counter()` 함수를 반환하고 생을 마감합니다. 하지만 `myCounter()`를 호출할 때마다 `count` 변수가 계속해서 증가하는 것을 볼 수 있습니다. 이는 `counter()` 함수가 반환될 때, 자신이 선언된 당시의 렉시컬 환경(Lexical Environment), 즉 `count` 변수를 캡처하여 기억하고 있기 때문입니다.

이처럼 클로저는 함수가 자신이 선언될 때의 환경을 기억함으로써, 이미 실행이 끝난 외부 함수의 변수에 접근할 수 있게 해주는 강력한 기능입니다. 이 덕분에 상태를 유지하거나, 정보 은닉(private 변수)과 같은 패턴을 구현할 수 있습니다.

## 클로저의 장단점

#### 장점

- **데이터 프라이버시**: 외부에서 직접 접근할 수 없는 private 변수 생성
- **상태 유지**: 함수 호출 간에도 데이터 상태를 유지
- **모듈화**: 관련된 기능을 하나의 스코프로 묶어 관리

#### 주의사항

- **메모리 사용**: 클로저가 참조하는 변수는 메모리에 계속 유지
- **디버깅 복잡성**: 스코프 체인이 복잡해질 수 있음
- **성능 영향**: 과도한 클로저 사용은 메모리 누수 가능성
