# JWT (JSON Web Token)

## 📖 개요

**JWT (JSON Web Token)**는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 컴팩트하고 독립적인 방법을 정의한 개방형 표준(RFC 7519)입니다. JWT는 인증, 정보 교환, 세션 관리 등 다양한 용도로 사용되며, 특히 RESTful API에서 토큰 기반 인증의 표준으로 자리잡고 있습니다.

**JWT가 현대 웹 개발에서 중요한 이유:**

- **무상태성**: 서버가 사용자 세션을 저장할 필요가 없어 확장성이 뛰어납니다
- **표준화**: RFC 7519로 표준화되어 다양한 언어와 플랫폼에서 지원됩니다
- **효율성**: HTTP 헤더나 URL 파라미터로 쉽게 전송할 수 있습니다
- **자체 포함**: 필요한 모든 정보가 토큰 내부에 포함되어 있어 별도 조회가 불필요합니다

## 🏗️ JWT 구조

JWT는 세 부분으로 구성되며, 각 부분은 점(.)으로 구분됩니다:

```
Header.Payload.Signature
```

### 1. **Header (헤더)**

토큰의 타입과 사용된 서명 알고리즘을 정의합니다.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**주요 필드:**

- **alg**: 서명 알고리즘 (HS256, RS256, ES256 등)
- **typ**: 토큰 타입 (항상 "JWT")
- **kid**: 키 ID (여러 키를 사용할 때)

### 2. **Payload (페이로드)**

실제 데이터를 포함하는 부분으로, 클레임(claim)이라고 불립니다.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622
}
```

**표준 클레임 (Registered Claims):**

- **sub**: 주체 (Subject) - 토큰의 주인
- **iss**: 발급자 (Issuer) - 토큰을 발급한 주체
- **aud**: 대상 (Audience) - 토큰의 수신자
- **exp**: 만료 시간 (Expiration Time) - 토큰의 만료 시점
- **nbf**: 시작 시간 (Not Before) - 토큰이 유효해지는 시점
- **iat**: 발급 시간 (Issued At) - 토큰이 발급된 시점
- **jti**: JWT ID - 토큰의 고유 식별자

**사용자 정의 클레임 (Custom Claims):**

```json
{
  "sub": "1234567890",
  "role": "admin",
  "permissions": ["read", "write", "delete"],
  "department": "engineering"
}
```

### 3. **Signature (서명)**

헤더와 페이로드의 무결성을 보장하는 서명입니다.

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

## 🔐 JWT 서명 알고리즘

### 1. **HMAC (대칭키 암호화)**

- **HS256**: HMAC SHA-256
- **HS384**: HMAC SHA-384
- **HS512**: HMAC SHA-512

**특징:**

- 동일한 비밀키로 서명 생성 및 검증
- 빠른 처리 속도
- 키 관리의 복잡성

**사용 예시:**

```javascript
const jwt = require("jsonwebtoken");

// 토큰 생성
const token = jwt.sign({ userId: 123, role: "user" }, "your-secret-key", {
  algorithm: "HS256",
  expiresIn: "1h",
});

// 토큰 검증
const decoded = jwt.verify(token, "your-secret-key");
```

### 2. **RSA (비대칭키 암호화)**

- **RS256**: RSA SHA-256
- **RS384**: RSA SHA-384
- **RS512**: RSA SHA-512

**특징:**

- 공개키로 검증, 개인키로 서명
- 높은 보안성
- 키 관리의 용이성

**사용 예시:**

```javascript
const jwt = require("jsonwebtoken");
const fs = require("fs");

// 개인키와 공개키 로드
const privateKey = fs.readFileSync("private.key");
const publicKey = fs.readFileSync("public.key");

// 토큰 생성 (개인키 사용)
const token = jwt.sign({ userId: 123, role: "user" }, privateKey, {
  algorithm: "RS256",
  expiresIn: "1h",
});

// 토큰 검증 (공개키 사용)
const decoded = jwt.verify(token, publicKey);
```

## 💡 프론트엔드 활용 아이디어

### 1. **토큰 저장 및 관리**

```javascript
// JWT 토큰 관리 클래스
class TokenManager {
  constructor() {
    this.accessToken = null;
  }

  // 토큰 저장
  setTokens(accessToken, refreshToken) {
    this.accessToken = accessToken;
    this.setHttpOnlyCookie("refresh_token", refreshToken);
  }

  // 토큰 유효성 검사
  isTokenValid(token) {
    if (!token) return false;
    try {
      const decoded = this.decodeToken(token);
      return decoded.exp > Date.now() / 1000;
    } catch (error) {
      return false;
    }
  }

  // HttpOnly 쿠키 설정
  setHttpOnlyCookie(name, value) {
    document.cookie = `${name}=${value}; HttpOnly; Secure; SameSite=Strict`;
  }
}
```

### 2. **API 요청 인터셉터**

```javascript
// Axios 인터셉터를 사용한 JWT 자동 처리
class JWTInterceptor {
  constructor(apiClient, tokenManager) {
    this.apiClient = apiClient;
    this.tokenManager = tokenManager;
    this.setupInterceptors();
  }

  setupInterceptors() {
    // 요청 인터셉터: 토큰 자동 추가
    this.apiClient.interceptors.request.use((config) => {
      const token = this.tokenManager.accessToken;
      if (token && this.tokenManager.isTokenValid(token)) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // 응답 인터셉터: 토큰 만료 처리
    this.apiClient.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          const newToken = await this.refreshToken();
          if (newToken) {
            error.config.headers.Authorization = `Bearer ${newToken}`;
            return this.apiClient.request(error.config);
          }
        }
        return Promise.reject(error);
      }
    );
  }
}
```

### 3. **React Context를 사용한 인증 상태 관리**

```javascript
// React Context를 사용한 JWT 인증 상태 관리
import React, { createContext, useContext, useReducer, useEffect } from "react";

const AuthContext = createContext();

const authReducer = (state, action) => {
  switch (action.type) {
    case "LOGIN":
      return {
        ...state,
        isAuthenticated: true,
        user: action.payload.user,
        accessToken: action.payload.accessToken,
      };
    case "LOGOUT":
      return {
        ...state,
        isAuthenticated: false,
        user: null,
        accessToken: null,
      };
    default:
      return state;
  }
};

export const AuthProvider = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, {
    isAuthenticated: false,
    user: null,
    accessToken: null,
  });

  const login = async (credentials) => {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });

      if (response.ok) {
        const { user, accessToken } = await response.json();
        localStorage.setItem("access_token", accessToken);
        dispatch({ type: "LOGIN", payload: { user, accessToken } });
        return { success: true };
      }
    } catch (error) {
      return { success: false, error: "Network error" };
    }
  };

  return (
    <AuthContext.Provider value={{ ...state, login }}>
      {children}
    </AuthContext.Provider>
  );
};
```

## 🔧 백엔드/전체 활용 아이디어

### 1. **JWT 미들웨어 구현**

```javascript
// Express.js JWT 미들웨어
class JWTMiddleware {
  constructor(secretKey) {
    this.secretKey = secretKey;
  }

  // 토큰 검증 미들웨어
  verifyToken(req, res, next) {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return res.status(401).json({ error: "Access token required" });
    }

    const token = authHeader.split(" ")[1]; // "Bearer TOKEN"

    if (!token) {
      return res.status(401).json({ error: "Invalid token format" });
    }

    try {
      const decoded = jwt.verify(token, this.secretKey);
      req.user = decoded;
      next();
    } catch (error) {
      if (error.name === "TokenExpiredError") {
        return res.status(401).json({ error: "Token expired" });
      } else if (error.name === "JsonWebTokenError") {
        return res.status(401).json({ error: "Invalid token" });
      }

      return res.status(500).json({ error: "Token verification failed" });
    }
  }

  // 역할 기반 권한 검증
  requireRole(requiredRole) {
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      if (req.user.role !== requiredRole && req.user.role !== "admin") {
        return res.status(403).json({ error: "Insufficient permissions" });
      }

      next();
    };
  }

  // 커스텀 클레임 검증
  requireClaim(claimName, claimValue) {
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      if (req.user[claimName] !== claimValue) {
        return res.status(403).json({ error: "Required claim not satisfied" });
      }

      next();
    };
  }
}

// 사용 예시
const jwtMiddleware = new JWTMiddleware(process.env.JWT_SECRET);

app.get(
  "/api/admin/users",
  jwtMiddleware.verifyToken,
  jwtMiddleware.requireRole("admin"),
  (req, res) => {
    // 관리자만 접근 가능한 사용자 목록 API
  }
);
```

### 2. **토큰 블랙리스트 관리**

```javascript
// JWT 토큰 블랙리스트 관리
class TokenBlacklist {
  constructor() {
    this.blacklistedTokens = new Set();
    this.redis = null; // Redis 연결 (선택사항)
  }

  // Redis 연결 설정
  async connectRedis() {
    try {
      this.redis = await redis.createClient();
      console.log("Redis connected for token blacklist");
    } catch (error) {
      console.warn("Redis not available, using in-memory storage");
    }
  }

  // 토큰 블랙리스트 추가
  async blacklistToken(token, expiresAt) {
    const tokenId = this.extractTokenId(token);

    if (this.redis) {
      // Redis에 저장 (TTL 자동 설정)
      const ttl = Math.floor((expiresAt * 1000 - Date.now()) / 1000);
      await this.redis.setex(`blacklist:${tokenId}`, ttl, "1");
    } else {
      // 메모리에 저장
      this.blacklistedTokens.add(tokenId);

      // 만료 시간에 자동 제거
      setTimeout(() => {
        this.blacklistedTokens.delete(tokenId);
      }, expiresAt * 1000 - Date.now());
    }
  }

  // 토큰이 블랙리스트에 있는지 확인
  async isTokenBlacklisted(token) {
    const tokenId = this.extractTokenId(token);

    if (this.redis) {
      const result = await this.redis.get(`blacklist:${tokenId}`);
      return result === "1";
    } else {
      return this.blacklistedTokens.has(tokenId);
    }
  }

  // 토큰 ID 추출 (jti 클레임 또는 토큰 해시)
  extractTokenId(token) {
    try {
      const decoded = jwt.decode(token);
      return decoded.jti || this.hashToken(token);
    } catch (error) {
      return this.hashToken(token);
    }
  }

  // 토큰 해시 생성
  hashToken(token) {
    return crypto.createHash("sha256").update(token).digest("hex");
  }
}

// 로그아웃 시 토큰 블랙리스트 추가
app.post("/api/auth/logout", jwtMiddleware.verifyToken, async (req, res) => {
  try {
    const token = req.headers.authorization.split(" ")[1];
    const decoded = jwt.decode(token);

    // 토큰을 블랙리스트에 추가
    await tokenBlacklist.blacklistToken(token, decoded.exp);

    res.json({ message: "Logged out successfully" });
  } catch (error) {
    res.status(500).json({ error: "Logout failed" });
  }
});
```

### 3. **JWT 토큰 갱신 시스템**

```javascript
// JWT 토큰 갱신 서비스
class TokenRefreshService {
  constructor(secretKey, refreshSecretKey) {
    this.secretKey = secretKey;
    this.refreshSecretKey = refreshSecretKey;
  }

  // 액세스 토큰 생성
  generateAccessToken(user) {
    return jwt.sign(
      {
        userId: user.id,
        email: user.email,
        role: user.role,
        permissions: user.permissions,
      },
      this.secretKey,
      {
        expiresIn: "15m", // 짧은 만료 시간
        issuer: "your-app",
        audience: "your-app-users",
      }
    );
  }

  // 리프레시 토큰 생성
  generateRefreshToken(user) {
    return jwt.sign(
      {
        userId: user.id,
        tokenVersion: user.tokenVersion || 0,
      },
      this.refreshSecretKey,
      {
        expiresIn: "7d", // 긴 만료 시간
        issuer: "your-app",
        audience: "your-app-users",
      }
    );
  }

  // 토큰 갱신
  async refreshTokens(refreshToken) {
    try {
      // 리프레시 토큰 검증
      const decoded = jwt.verify(refreshToken, this.refreshSecretKey);

      // 사용자 정보 조회
      const user = await this.getUserById(decoded.userId);

      // 토큰 버전 확인 (토큰 무효화를 위한)
      if (user.tokenVersion !== decoded.tokenVersion) {
        throw new Error("Token version mismatch");
      }

      // 새로운 토큰 생성
      const newAccessToken = this.generateAccessToken(user);
      const newRefreshToken = this.generateRefreshToken(user);

      return {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
        },
      };
    } catch (error) {
      throw new Error("Invalid refresh token");
    }
  }

  // 토큰 무효화 (보안 강화)
  async invalidateUserTokens(userId) {
    try {
      // 사용자의 토큰 버전 증가
      await this.updateUserTokenVersion(userId);

      // 기존 토큰들을 블랙리스트에 추가
      // (실제 구현에서는 더 정교한 관리 필요)

      return true;
    } catch (error) {
      throw new Error("Token invalidation failed");
    }
  }
}

// 토큰 갱신 API
app.post("/api/auth/refresh", async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return res.status(400).json({ error: "Refresh token required" });
    }

    const tokenService = new TokenRefreshService(
      process.env.JWT_SECRET,
      process.env.JWT_REFRESH_SECRET
    );

    const newTokens = await tokenService.refreshTokens(refreshToken);

    res.json(newTokens);
  } catch (error) {
    res.status(401).json({ error: "Token refresh failed" });
  }
});
```

## 🛡️ JWT 보안 고려사항

### 1. **토큰 크기 제한**

JWT는 헤더에 포함되므로 크기가 제한적입니다.

**권장사항:**

- 페이로드에 필요한 최소한의 정보만 포함
- 민감한 정보는 토큰에 포함하지 않음
- 사용자 ID, 역할, 권한 등 핵심 정보만 포함

### 2. **토큰 만료 시간 관리**

```javascript
// 토큰 만료 시간 설정 가이드
const tokenExpiration = {
  accessToken: "15m", // 짧은 만료 시간 (보안 강화)
  refreshToken: "7d", // 긴 만료 시간 (사용자 편의성)
  rememberMe: "30d", // 자동 로그인 토큰
};

// 토큰 만료 시간에 따른 자동 갱신
setInterval(async () => {
  const token = tokenManager.getAccessToken();
  if (token && tokenManager.isTokenExpiringSoon(token)) {
    await tokenManager.refreshToken();
  }
}, 60000); // 1분마다 체크
```

### 3. **HTTPS 사용 필수**

JWT는 평문으로 전송되므로 반드시 HTTPS를 사용해야 합니다.

```javascript
// 보안 헤더 설정
app.use(
  helmet({
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  })
);

// 쿠키 보안 설정
app.use(
  session({
    cookie: {
      secure: true, // HTTPS에서만 전송
      httpOnly: true, // JavaScript 접근 방지
      sameSite: "strict", // CSRF 공격 방지
    },
  })
);
```

## 🎯 결론

JWT는 현대적인 웹 애플리케이션에서 토큰 기반 인증의 표준으로 자리잡고 있으며, 올바르게 구현하면 안전하고 확장 가능한 인증 시스템을 구축할 수 있습니다.

**성공적인 JWT 구현을 위한 핵심 요소:**

1. **적절한 알고리즘 선택**: 보안 요구사항에 맞는 서명 알고리즘 사용
2. **토큰 만료 시간 관리**: 보안과 사용자 경험의 균형 유지
3. **보안 헤더 설정**: HTTPS, HttpOnly 쿠키 등 보안 강화
4. **토큰 무효화**: 로그아웃 시 토큰 블랙리스트 관리
5. **정기적 보안 검토**: 알려진 취약점에 대한 지속적 모니터링

JWT는 강력한 도구이지만, 보안을 고려한 신중한 구현이 필요합니다. 개발자는 JWT의 특성을 이해하고, 애플리케이션의 보안 요구사항에 맞는 적절한 구현을 통해 안전하고 효율적인 인증 시스템을 구축해야 합니다.
