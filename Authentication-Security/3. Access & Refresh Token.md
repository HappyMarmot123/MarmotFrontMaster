# Access & Refresh Token

## 📖 개요

**Access Token과 Refresh Token**은 JWT 기반 인증 시스템에서 보안과 사용자 경험을 모두 고려한 이중 토큰 구조입니다. Access Token은 API 요청 시 사용자의 인증을 확인하는 단기 토큰이고, Refresh Token은 Access Token을 갱신하는 장기 토큰입니다.

**Access & Refresh Token이 중요한 이유:**

- **보안 강화**: Access Token의 짧은 수명으로 토큰 탈취 시 피해 최소화
- **사용자 경험**: 자동 토큰 갱신으로 사용자가 반복 로그인할 필요 없음
- **토큰 무효화**: Refresh Token을 통해 특정 사용자의 모든 세션을 즉시 종료 가능
- **확장성**: 마이크로서비스 환경에서 효율적인 인증 관리

## 🏗️ 토큰 구조와 동작 원리

### 1. **토큰의 역할과 특징**

**Access Token:**

- **용도**: API 요청 시 인증 및 권한 확인
- **수명**: 짧음 (15분 ~ 1시간)
- **저장 위치**: 메모리 또는 안전한 클라이언트 저장소
- **보안 수준**: 높음 (자주 교체)

**Refresh Token:**

- **용도**: Access Token 갱신
- **수명**: 김 (7일 ~ 30일)
- **저장 위치**: HttpOnly 쿠키 또는 안전한 서버 저장소
- **보안 수준**: 매우 높음 (안전한 저장소 사용)

### 2. **토큰 플로우**

```
1. 사용자 로그인
   ↓
2. Access Token + Refresh Token 발급
   ↓
3. API 요청 시 Access Token 사용
   ↓
4. Access Token 만료 시 Refresh Token으로 갱신
   ↓
5. 새로운 Access Token 발급
   ↓
6. Refresh Token 만료 시 재로그인 필요
```

## 💡 프론트엔드 활용 아이디어

### 1. **토큰 자동 갱신 시스템**

```javascript
// 자동 토큰 갱신 관리자
class TokenRefreshManager {
  constructor(apiClient, tokenManager) {
    this.apiClient = apiClient;
    this.tokenManager = tokenManager;
    this.isRefreshing = false;
    this.failedQueue = [];
    this.setupInterceptors();
  }

  setupInterceptors() {
    // 응답 인터셉터: 401 에러 시 자동 토큰 갱신
    this.apiClient.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401 && !error.config._retry) {
          if (this.isRefreshing) {
            return new Promise((resolve, reject) => {
              this.failedQueue.push({ resolve, reject });
            });
          }

          error.config._retry = true;
          this.isRefreshing = true;

          try {
            const newToken = await this.refreshAccessToken();
            this.processQueue(null, newToken);
            error.config.headers.Authorization = `Bearer ${newToken}`;
            return this.apiClient.request(error.config);
          } catch (refreshError) {
            this.processQueue(refreshError, null);
            return Promise.reject(refreshError);
          } finally {
            this.isRefreshing = false;
          }
        }
        return Promise.reject(error);
      }
    );
  }
}
```

### 2. **토큰 만료 시간 모니터링**

```javascript
// 토큰 만료 시간 모니터링 및 자동 갱신
class TokenExpirationMonitor {
  constructor(tokenManager, refreshManager) {
    this.tokenManager = tokenManager;
    this.refreshManager = refreshManager;
    this.monitoringInterval = null;
    this.warningThreshold = 5 * 60 * 1000; // 5분 전 경고
  }

  startMonitoring() {
    this.monitoringInterval = setInterval(() => {
      this.checkTokenExpiration();
    }, 30000); // 30초마다 체크
  }

  checkTokenExpiration() {
    const accessToken = this.tokenManager.getAccessToken();
    if (!accessToken) return;

    try {
      const decoded = this.tokenManager.decodeToken(accessToken);
      const timeUntilExpiry = (decoded.exp - Date.now() / 1000) * 1000;

      if (timeUntilExpiry <= 0) {
        this.handleTokenExpiration();
      } else if (timeUntilExpiry <= this.warningThreshold) {
        this.refreshTokenProactively();
      }
    } catch (error) {
      console.error("Token expiration check failed:", error);
    }
  }
}
```

### 3. **React Hook을 사용한 토큰 관리**

```javascript
// React Hook을 사용한 토큰 상태 관리
import { useState, useEffect, useCallback } from "react";

export const useTokenManagement = () => {
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  // 토큰 저장
  const setTokens = useCallback((newAccessToken, newRefreshToken) => {
    setAccessToken(newAccessToken);
    setRefreshToken(newRefreshToken);
    setIsAuthenticated(true);

    if (newAccessToken) {
      sessionStorage.setItem("access_token", newAccessToken);
    }
    if (newRefreshToken) {
      localStorage.setItem("refresh_token", newRefreshToken);
    }
  }, []);

  // 토큰 갱신
  const refreshTokens = useCallback(async () => {
    try {
      const response = await fetch("/api/auth/refresh", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refreshToken }),
      });

      if (response.ok) {
        const { accessToken: newAccessToken, refreshToken: newRefreshToken } =
          await response.json();
        setTokens(newAccessToken, newRefreshToken);
        return newAccessToken;
      }
    } catch (error) {
      console.error("Token refresh failed:", error);
      return null;
    }
  }, [refreshToken, setTokens]);

  return {
    accessToken,
    refreshToken,
    isAuthenticated,
    setTokens,
    refreshTokens,
  };
};
```

## 🔧 백엔드/전체 활용 아이디어

### 1. **토큰 발급 및 검증 서비스**

```javascript
// 토큰 발급 및 검증 서비스
class TokenService {
  constructor(accessSecret, refreshSecret) {
    this.accessSecret = accessSecret;
    this.refreshSecret = refreshSecret;
    this.refreshTokenStore = new Map(); // 실제로는 Redis 사용 권장
  }

  // Access Token 생성
  generateAccessToken(user) {
    const payload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      permissions: user.permissions,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 15 * 60, // 15분
      jti: this.generateTokenId(),
    };

    return jwt.sign(payload, this.accessSecret, { algorithm: "HS256" });
  }

  // Refresh Token 생성
  generateRefreshToken(user) {
    const payload = {
      sub: user.id,
      tokenVersion: user.tokenVersion || 0,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 7 * 24 * 60 * 60, // 7일
      jti: this.generateTokenId(),
    };

    const refreshToken = jwt.sign(payload, this.refreshSecret, {
      algorithm: "HS256",
    });

    // Refresh Token을 저장소에 저장
    this.refreshTokenStore.set(payload.jti, {
      userId: user.id,
      tokenVersion: user.tokenVersion,
      expiresAt: payload.exp,
    });

    return refreshToken;
  }

  // Access Token 검증
  verifyAccessToken(token) {
    try {
      const decoded = jwt.verify(token, this.accessSecret);
      return { valid: true, payload: decoded };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  // Refresh Token 검증
  verifyRefreshToken(token) {
    try {
      const decoded = jwt.verify(token, this.refreshSecret);

      // 저장소에서 토큰 확인
      const storedToken = this.refreshTokenStore.get(decoded.jti);
      if (!storedToken) {
        return { valid: false, error: "Token not found in store" };
      }

      // 사용자 ID와 토큰 버전 확인
      if (
        storedToken.userId !== decoded.sub ||
        storedToken.tokenVersion !== decoded.tokenVersion
      ) {
        return { valid: false, error: "Token version mismatch" };
      }

      return { valid: true, payload: decoded };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  // 토큰 쌍 생성
  generateTokenPair(user) {
    const accessToken = this.generateAccessToken(user);
    const refreshToken = this.generateRefreshToken(user);

    return { accessToken, refreshToken };
  }

  // 토큰 무효화
  invalidateRefreshToken(tokenId) {
    this.refreshTokenStore.delete(tokenId);
  }

  // 사용자의 모든 토큰 무효화
  invalidateUserTokens(userId) {
    for (const [tokenId, tokenData] of this.refreshTokenStore.entries()) {
      if (tokenData.userId === userId) {
        this.refreshTokenStore.delete(tokenId);
      }
    }
  }

  // 토큰 ID 생성
  generateTokenId() {
    return crypto.randomBytes(32).toString("hex");
  }
}
```

### 2. **토큰 갱신 API 구현**

```javascript
// Express.js 토큰 갱신 API
class TokenRefreshController {
  constructor(tokenService, userService) {
    this.tokenService = tokenService;
    this.userService = userService;
  }

  // 토큰 갱신 엔드포인트
  async refreshTokens(req, res) {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        return res.status(400).json({ error: "Refresh token required" });
      }

      // Refresh Token 검증
      const verification = this.tokenService.verifyRefreshToken(refreshToken);

      if (!verification.valid) {
        return res.status(401).json({ error: "Invalid refresh token" });
      }

      const { payload } = verification;

      // 사용자 정보 조회
      const user = await this.userService.findById(payload.sub);

      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }

      // 새로운 토큰 쌍 생성
      const newTokens = this.tokenService.generateTokenPair(user);

      // 기존 Refresh Token 무효화
      this.tokenService.invalidateRefreshToken(payload.jti);

      res.json({
        accessToken: newTokens.accessToken,
        refreshToken: newTokens.refreshToken,
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
        },
      });
    } catch (error) {
      console.error("Token refresh error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  }

  // 로그아웃 엔드포인트
  async logout(req, res) {
    try {
      const authHeader = req.headers.authorization;

      if (authHeader) {
        const token = authHeader.split(" ")[1];
        const decoded = jwt.decode(token);

        if (decoded && decoded.jti) {
          // Access Token을 블랙리스트에 추가 (선택사항)
          // this.tokenService.blacklistAccessToken(decoded.jti);
        }
      }

      // Refresh Token 무효화
      const { refreshToken } = req.body;
      if (refreshToken) {
        const decoded = jwt.decode(refreshToken);
        if (decoded && decoded.jti) {
          this.tokenService.invalidateRefreshToken(decoded.jti);
        }
      }

      res.json({ message: "Logged out successfully" });
    } catch (error) {
      console.error("Logout error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  }

  // 모든 세션 종료
  async logoutAllSessions(req, res) {
    try {
      const userId = req.user.id;

      // 사용자의 모든 Refresh Token 무효화
      this.tokenService.invalidateUserTokens(userId);

      // 토큰 버전 증가 (선택사항)
      await this.userService.incrementTokenVersion(userId);

      res.json({ message: "All sessions terminated" });
    } catch (error) {
      console.error("Logout all sessions error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  }
}

// 라우터 설정
const tokenController = new TokenRefreshController(tokenService, userService);

app.post("/api/auth/refresh", (req, res) =>
  tokenController.refreshTokens(req, res)
);
app.post("/api/auth/logout", authMiddleware, (req, res) =>
  tokenController.logout(req, res)
);
app.post("/api/auth/logout-all", authMiddleware, (req, res) =>
  tokenController.logoutAllSessions(req, res)
);
```

### 3. **토큰 보안 미들웨어**

```javascript
// 토큰 보안 미들웨어
class TokenSecurityMiddleware {
  constructor(tokenService) {
    this.tokenService = tokenService;
    this.rateLimitStore = new Map();
  }

  // 토큰 검증 미들웨어
  verifyAccessToken(req, res, next) {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return res.status(401).json({ error: "Access token required" });
    }

    const token = authHeader.split(" ")[1];

    if (!token) {
      return res.status(401).json({ error: "Invalid token format" });
    }

    // 토큰 검증
    const verification = this.tokenService.verifyAccessToken(token);

    if (!verification.valid) {
      if (verification.error === "jwt expired") {
        return res.status(401).json({ error: "Token expired" });
      }
      return res.status(401).json({ error: "Invalid token" });
    }

    // 요청에 사용자 정보 추가
    req.user = verification.payload;
    next();
  }

  // 토큰 사용량 제한
  rateLimitTokens(req, res, next) {
    const userId = req.user?.id || req.ip;
    const now = Date.now();
    const windowMs = 15 * 60 * 1000; // 15분
    const maxRequests = 100; // 최대 100개 요청

    const userRequests = this.rateLimitStore.get(userId) || [];

    // 윈도우 시간 밖의 요청 제거
    const validRequests = userRequests.filter((time) => now - time < windowMs);

    if (validRequests.length >= maxRequests) {
      return res.status(429).json({ error: "Rate limit exceeded" });
    }

    // 현재 요청 추가
    validRequests.push(now);
    this.rateLimitStore.set(userId, validRequests);

    next();
  }

  // 토큰 블랙리스트 확인
  checkTokenBlacklist(req, res, next) {
    const token = req.headers.authorization?.split(" ")[1];

    if (token) {
      const decoded = jwt.decode(token);

      if (decoded && decoded.jti) {
        // 블랙리스트 확인 (Redis 등 사용 권장)
        const isBlacklisted = this.checkBlacklist(decoded.jti);

        if (isBlacklisted) {
          return res.status(401).json({ error: "Token has been revoked" });
        }
      }
    }

    next();
  }

  // 블랙리스트 확인 (구현 필요)
  checkBlacklist(tokenId) {
    // Redis 또는 데이터베이스에서 확인
    return false;
  }
}

// 미들웨어 적용
const tokenSecurity = new TokenSecurityMiddleware(tokenService);

app.use("/api", tokenSecurity.checkTokenBlacklist);
app.use("/api", tokenSecurity.rateLimitTokens);
```

## 🛡️ 보안 고려사항

### 1. **토큰 저장 보안**

**클라이언트 측:**

```javascript
// 안전한 토큰 저장 전략
class SecureTokenStorage {
  constructor() {
    this.accessToken = null; // 메모리에만 저장
  }

  // Access Token 저장 (메모리)
  setAccessToken(token) {
    this.accessToken = token;
  }

  // Access Token 가져오기
  getAccessToken() {
    return this.accessToken;
  }

  // Refresh Token 저장 (HttpOnly 쿠키)
  setRefreshToken(token) {
    document.cookie = `refresh_token=${token}; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=${
      7 * 24 * 60 * 60
    }`;
  }

  // Refresh Token 가져오기 (서버에서만 접근 가능)
  getRefreshToken() {
    // HttpOnly 쿠키는 JavaScript에서 직접 접근 불가
    // 서버에서 쿠키를 읽어서 처리
    return null;
  }

  // 토큰 제거
  clearTokens() {
    this.accessToken = null;
    document.cookie =
      "refresh_token=; HttpOnly; Secure; SameSite=Strict; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT";
  }
}
```

**서버 측:**

```javascript
// 서버 측 토큰 저장소 (Redis 권장)
class ServerTokenStorage {
  constructor(redisClient) {
    this.redis = redisClient;
    this.prefix = "refresh_token:";
  }

  // Refresh Token 저장
  async storeRefreshToken(tokenId, tokenData, expiresIn) {
    const key = this.prefix + tokenId;
    await this.redis.setex(key, expiresIn, JSON.stringify(tokenData));
  }

  // Refresh Token 조회
  async getRefreshToken(tokenId) {
    const key = this.prefix + tokenId;
    const data = await this.redis.get(key);
    return data ? JSON.parse(data) : null;
  }

  // Refresh Token 삭제
  async removeRefreshToken(tokenId) {
    const key = this.prefix + tokenId;
    await this.redis.del(key);
  }

  // 사용자의 모든 토큰 삭제
  async removeUserTokens(userId) {
    const pattern = this.prefix + "*";
    const keys = await this.redis.keys(pattern);

    for (const key of keys) {
      const data = await this.redis.get(key);
      if (data) {
        const tokenData = JSON.parse(data);
        if (tokenData.userId === userId) {
          await this.redis.del(key);
        }
      }
    }
  }
}
```

### 2. **토큰 만료 시간 최적화**

**권장 설정:**

```javascript
// 토큰 만료 시간 설정 가이드
const tokenExpirationConfig = {
  // 개발 환경
  development: {
    accessToken: "1h", // 1시간
    refreshToken: "7d", // 7일
  },

  // 프로덕션 환경
  production: {
    accessToken: "15m", // 15분
    refreshToken: "7d", // 7일
  },

  // 높은 보안이 필요한 환경
  highSecurity: {
    accessToken: "5m", // 5분
    refreshToken: "1d", // 1일
  },
};

// 환경에 따른 설정 적용
const getTokenExpiration = () => {
  const env = process.env.NODE_ENV || "development";
  const securityLevel = process.env.SECURITY_LEVEL || "normal";

  if (securityLevel === "high") {
    return tokenExpirationConfig.highSecurity;
  }

  return tokenExpirationConfig[env] || tokenExpirationConfig.development;
};
```

## 🎯 결론

Access Token과 Refresh Token의 이중 구조는 현대적인 웹 애플리케이션에서 보안과 사용자 경험을 모두 만족시키는 효과적인 인증 방식입니다.

**성공적인 구현을 위한 핵심 요소:**

1. **적절한 토큰 수명**: 보안 요구사항과 사용자 경험의 균형
2. **안전한 토큰 저장**: HttpOnly 쿠키와 메모리 저장의 적절한 조합
3. **자동 토큰 갱신**: 사용자 개입 없이 원활한 인증 유지
4. **토큰 무효화**: 보안 사고 시 즉시 모든 세션 종료 가능
5. **정기적 보안 검토**: 토큰 구조와 보안 정책의 지속적 개선

이러한 토큰 시스템을 통해 개발자는 안전하고 사용자 친화적인 인증 시스템을 구축할 수 있으며, 이는 웹 애플리케이션의 전반적인 보안 수준을 크게 향상시킵니다.
