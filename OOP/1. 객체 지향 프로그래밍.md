# 객체 지향 프로그래밍 (Object-Oriented Programming)

## 📖 개요

**객체 지향 프로그래밍(OOP)**은 현대 소프트웨어 개발의 핵심 패러다임 중 하나입니다. 데이터와 그 데이터를 조작하는 메서드를 하나의 단위(객체)로 묶어 프로그램을 구성하는 방식으로, 코드의 재사용성, 유지보수성, 확장성을 크게 향상시킵니다.

## 🔍 객체 지향 프로그래밍의 핵심 개념

### 1. 클래스(Class)와 객체(Object)

**클래스**는 객체를 생성하기 위한 템플릿으로, 객체가 가져야 할 속성과 메서드를 정의합니다.

**객체**는 클래스의 인스턴스로, 실제 메모리에 할당되어 동작하는 실체입니다.

### 2. 객체 지향의 4대 원칙

#### 캡슐화(Encapsulation)

- **데이터 은닉**: 객체의 내부 상태를 외부로부터 숨김
- **정보 은닉**: 구현 세부사항을 외부에 노출하지 않음
- **접근 제어**: public, private, protected 등의 접근 제한자 사용

#### 상속(Inheritance)

- **코드 재사용**: 기존 클래스의 기능을 새로운 클래스에서 재사용
- **계층 구조**: 부모-자식 관계를 통한 클래스 계층 구조 형성
- **다형성 기반**: 상속을 통한 다형성 구현

#### 다형성(Polymorphism)

- **인터페이스 통일**: 동일한 인터페이스를 통해 다양한 객체 조작
- **오버라이딩**: 자식 클래스에서 부모 클래스의 메서드 재정의
- **오버로딩**: 동일한 이름의 메서드를 다른 매개변수로 정의

#### 추상화(Abstraction)

- **복잡성 감소**: 복잡한 시스템을 단순한 모델로 표현
- **핵심 기능**: 중요한 기능만 추출하여 인터페이스로 정의
- **구현 분리**: 추상화된 인터페이스와 구체적인 구현을 분리

## 🏗️ GoF 디자인 패턴 (Gang of Four Design Patterns)

### 📚 Design Patterns: Elements of Reusable Object-Oriented Software

**Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides**가 집필한 이 책은 소프트웨어 디자인 패턴의 바이블로 불리며, 23가지의 핵심 디자인 패턴을 체계적으로 정리했습니다.

## 🔧 생성 패턴 (Creational Patterns)

### 1. 추상 팩토리 (Abstract Factory)

**목적**: 관련된 객체들을 생성하는 인터페이스를 제공하여 구체적인 클래스를 명시하지 않고도 객체를 생성할 수 있게 합니다.

**구조**:

- **AbstractFactory**: 추상 팩토리 인터페이스
- **ConcreteFactory**: 구체적인 팩토리 클래스
- **AbstractProduct**: 추상 제품 인터페이스
- **ConcreteProduct**: 구체적인 제품 클래스

**장점**:

- 구체적인 클래스와 클라이언트 코드를 분리
- 새로운 제품군을 쉽게 추가 가능
- 제품 간의 일관성 보장

**단점**:

- 새로운 제품 종류를 추가하기 어려움
- 복잡한 클래스 구조

**사용 시기**:

- 관련된 객체들을 일관되게 생성해야 할 때
- 시스템이 제품의 구현보다는 인터페이스에 의존해야 할 때

### 2. 빌더 (Builder)

**목적**: 복잡한 객체의 생성 과정을 단계별로 분리하여 다양한 표현을 생성할 수 있게 합니다.

**구조**:

- **Builder**: 제품 생성 단계를 정의하는 추상 인터페이스
- **ConcreteBuilder**: Builder 인터페이스를 구현하는 구체 클래스
- **Director**: Builder를 사용하여 제품을 생성하는 클래스
- **Product**: 생성될 복잡한 객체

**장점**:

- 객체 생성 과정을 세밀하게 제어
- 생성 과정과 표현을 분리
- 다양한 표현을 생성 가능

**단점**:

- 클래스 수 증가
- 복잡한 객체에만 적합

**사용 시기**:

- 복잡한 객체를 단계별로 생성해야 할 때
- 생성 과정이 복잡하고 다양한 표현이 필요할 때

### 3. 팩토리 메서드 (Factory Method)

**목적**: 객체를 생성하는 인터페이스를 정의하되, 어떤 클래스의 인스턴스를 생성할지는 하위 클래스가 결정하도록 합니다.

**구조**:

- **Creator**: 팩토리 메서드를 선언하는 추상 클래스
- **ConcreteCreator**: Creator를 구현하는 구체 클래스
- **Product**: 팩토리 메서드가 생성할 객체의 인터페이스
- **ConcreteProduct**: Product를 구현하는 구체 클래스

**장점**:

- 클라이언트와 구체적인 제품 클래스 분리
- 새로운 제품 추가 시 Creator만 수정
- 확장에는 열려있고 수정에는 닫혀있는 구조

**단점**:

- 클래스 수 증가
- 상속을 통한 구현

**사용 시기**:

- 클래스가 생성할 객체의 클래스를 예측할 수 없을 때
- 클래스가 하위 클래스에게 객체 생성을 위임하고 싶을 때

### 4. 프로토타입 (Prototype)

**목적**: 생성할 객체의 종류를 명시하는 데 원형이 되는 인스턴스를 사용하고, 이 원형을 복사해서 새로운 객체를 생성합니다.

**구조**:

- **Prototype**: 자신을 복제하는 인터페이스
- **ConcretePrototype**: Prototype을 구현하는 구체 클래스
- **Client**: Prototype을 복제하는 클라이언트

**장점**:

- 객체 생성 비용 감소
- 동적 객체 생성
- 복잡한 객체 생성 과정 단순화

**단점**:

- 깊은 복사와 얕은 복사의 문제
- 순환 참조 처리 복잡성

**사용 시기**:

- 객체 생성 비용이 높을 때
- 런타임에 생성할 객체의 종류를 결정해야 할 때

### 5. 싱글톤 (Singleton)

**목적**: 클래스의 인스턴스가 오직 하나만 생성되도록 보장하고, 이 인스턴스에 대한 전역적인 접근점을 제공합니다.

**구조**:

- **Singleton**: 인스턴스가 하나만 존재함을 보장하는 클래스
- **getInstance()**: 유일한 인스턴스에 접근할 수 있는 정적 메서드

**장점**:

- 메모리 효율성
- 전역 상태 관리
- 객체 생성 제어

**단점**:

- 전역 상태로 인한 테스트 어려움
- 멀티스레드 환경에서 동기화 문제
- 의존성 결합도 증가

**사용 시기**:

- 클래스의 인스턴스가 하나만 존재해야 할 때
- 전역 상태를 관리해야 할 때

## 🔄 구조 패턴 (Structural Patterns)

### 1. 어댑터 (Adapter)

**목적**: 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하여, 호환성 문제를 해결합니다.

**구조**:

- **Target**: 클라이언트가 기대하는 인터페이스
- **Adaptee**: 적응이 필요한 기존 클래스
- **Adapter**: Target과 Adaptee를 연결하는 클래스

**장점**:

- 기존 코드 재사용
- 클라이언트 코드 수정 없이 호환성 확보
- 다중 상속 문제 해결

**단점**:

- 클래스 수 증가
- 복잡한 어댑터 구현

**사용 시기**:

- 기존 클래스를 다른 인터페이스로 사용하고 싶을 때
- 호환되지 않는 인터페이스를 가진 클래스들을 함께 사용해야 할 때

### 2. 브리지 (Bridge)

**목적**: 추상화와 구현을 분리하여, 이들이 독립적으로 변화할 수 있도록 합니다.

**구조**:

- **Abstraction**: 추상화의 인터페이스
- **RefinedAbstraction**: Abstraction을 확장한 클래스
- **Implementor**: 구현의 인터페이스
- **ConcreteImplementor**: Implementor를 구현한 클래스

**장점**:

- 추상화와 구현의 독립적 변화
- 확장성 향상
- 구현 세부사항 숨김

**단점**:

- 클래스 수 증가
- 복잡한 구조

**사용 시기**:

- 추상화와 구현이 독립적으로 확장되어야 할 때
- 구현이 런타임에 바뀌어야 할 때

### 3. 컴포지트 (Composite)

**목적**: 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하고, 클라이언트가 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 합니다.

**구조**:

- **Component**: 복합 객체와 개별 객체를 위한 공통 인터페이스
- **Leaf**: 개별 객체를 나타내는 클래스
- **Composite**: 자식들을 가지는 복합 객체

**장점**:

- 일관된 인터페이스
- 새로운 컴포넌트 타입 추가 용이
- 클라이언트 코드 단순화

**단점**:

- 타입 안전성 제한
- 리소스 관리 복잡성

**사용 시기**:

- 부분-전체 계층을 표현해야 할 때
- 클라이언트가 개별 객체와 복합 객체를 동일하게 다루어야 할 때

### 4. 데코레이터 (Decorator)

**목적**: 객체에 추가적인 책임을 동적으로 부여하여, 기능 확장을 위한 유연한 대안을 제공합니다.

**구조**:

- **Component**: 동적으로 추가할 수 있는 기능들의 공통 인터페이스
- **ConcreteComponent**: 기본 기능을 구현하는 클래스
- **Decorator**: Component를 참조하고 Component 인터페이스를 구현
- **ConcreteDecorator**: 구체적인 데코레이터 클래스

**장점**:

- 상속보다 유연한 기능 확장
- 런타임에 기능 조합
- 단일 책임 원칙 준수

**단점**:

- 작은 객체들이 많이 생성
- 복잡한 객체 구조
- 디버깅 어려움

**사용 시기**:

- 개별 객체에 동적으로 책임을 추가해야 할 때
- 상속을 통한 기능 확장이 비효율적일 때

### 5. 퍼사드 (Facade)

**목적**: 서브시스템의 복잡한 인터페이스를 단순화된 고수준 인터페이스로 제공합니다.

**구조**:

- **Facade**: 서브시스템의 복잡한 인터페이스를 단순화
- **Subsystem Classes**: 서브시스템을 구성하는 클래스들

**장점**:

- 서브시스템과 클라이언트의 결합도 감소
- 서브시스템 사용 단순화
- 서브시스템 변경 시 클라이언트 영향 최소화

**단점**:

- 모든 기능을 제공하지 못할 수 있음
- 서브시스템에 대한 제한된 접근

**사용 시기**:

- 복잡한 서브시스템을 단순화하고 싶을 때
- 서브시스템과 클라이언트 간의 결합도를 낮추고 싶을 때

### 6. 플라이웨이트 (Flyweight)

**목적**: 공유를 통해 많은 수의 객체를 효율적으로 지원합니다.

**구조**:

- **Flyweight**: 플라이웨이트가 받아들일 수 있는 모든 요청의 인터페이스
- **ConcreteFlyweight**: 플라이웨이트 인터페이스를 구현
- **FlyweightFactory**: 플라이웨이트 객체를 생성하고 관리
- **Client**: 플라이웨이트에 대한 참조를 유지

**장점**:

- 메모리 사용량 감소
- 객체 생성 비용 절약
- 공유 객체 관리

**단점**:

- 복잡한 상태 관리
- 동시성 문제
- 디버깅 어려움

**사용 시기**:

- 많은 수의 객체를 생성해야 할 때
- 객체의 상태가 대부분 공유될 수 있을 때

### 7. 프록시 (Proxy)

**목적**: 다른 객체에 대한 접근을 제어하거나 대리자 역할을 하는 객체를 제공합니다.

**구조**:

- **Subject**: RealSubject와 Proxy가 공통으로 구현하는 인터페이스
- **RealSubject**: Proxy가 대표하는 실제 객체
- **Proxy**: Subject에 대한 참조를 유지하고 RealSubject에 대한 접근을 제어

**장점**:

- 접근 제어
- 지연 로딩
- 로깅 및 모니터링

**단점**:

- 응답 시간 증가
- 복잡한 구현
- 디버깅 어려움

**사용 시기**:

- 객체에 대한 접근을 제어해야 할 때
- 객체 생성 비용이 높아 지연 로딩이 필요할 때

## 🎯 행동 패턴 (Behavioral Patterns)

### 1. 책임 연쇄 (Chain of Responsibility)

**목적**: 요청을 처리할 수 있는 객체들을 연결하여, 요청이 처리될 때까지 객체 체인을 따라 전달합니다.

**구조**:

- **Handler**: 요청을 처리하는 인터페이스
- **ConcreteHandler**: 구체적인 핸들러 클래스
- **Client**: 체인의 첫 번째 핸들러에 요청을 보내는 클라이언트

**장점**:

- 요청 발신자와 수신자의 결합도 감소
- 새로운 핸들러 추가 용이
- 요청 처리 순서 유연성

**단점**:

- 요청이 처리되지 않을 수 있음
- 디버깅 어려움
- 성능 오버헤드

**사용 시기**:

- 요청을 처리할 수 있는 객체가 여러 개일 때
- 요청을 처리할 객체를 명시하지 않고 싶을 때

### 2. 커맨드 (Command)

**목적**: 요청을 객체로 캡슐화하여, 서로 다른 요청으로 클라이언트를 매개변수화하고, 요청을 대기시키거나 로깅할 수 있게 합니다.

**구조**:

- **Command**: 요청을 캡슐화하는 인터페이스
- **ConcreteCommand**: Command를 구현하는 구체 클래스
- **Client**: ConcreteCommand를 생성하고 Receiver를 설정
- **Invoker**: 명령의 실행을 요청
- **Receiver**: 요청과 관련된 작업을 수행하는 방법을 알고 있는 클래스

**장점**:

- 요청 발신자와 수신자의 결합도 감소
- 요청의 대기, 로깅, 취소 가능
- 새로운 명령 추가 용이

**단점**:

- 클래스 수 증가
- 복잡한 명령 체인

**사용 시기**:

- 요청을 객체로 매개변수화하고 싶을 때
- 요청을 대기시키거나 로깅하고 싶을 때

### 3. 인터프리터 (Interpreter)

**목적**: 문법을 표현하는 방법을 정의하고, 해당 언어로 작성된 문장을 해석하는 방법을 제공합니다.

**구조**:

- **AbstractExpression**: 추상 구문 트리의 모든 노드에 공통된 인터페이스
- **TerminalExpression**: 문법의 말단 표현을 구현
- **NonterminalExpression**: 문법의 비말단 표현을 구현
- **Context**: 인터프리터에 필요한 전역 정보를 포함

**장점**:

- 문법 변경 시 클래스만 수정
- 새로운 표현식 추가 용이
- 문법 구조의 명확한 표현

**단점\*\***

- 복잡한 문법에 대한 클래스 수 증가
- 복잡한 문법의 경우 파서 생성기가 더 효율적
- 디버깅 어려움

**사용 시기**:

- 간단한 언어를 해석해야 할 때
- 문법이 간단하고 성능이 중요하지 않을 때

### 4. 이터레이터 (Iterator)

**목적**: 내부 표현을 노출하지 않고 객체의 원소에 순차적으로 접근할 수 있는 방법을 제공합니다.

**구조**:

- **Iterator**: 원소에 접근하고 순회하는 인터페이스
- **ConcreteIterator**: Iterator를 구현하는 구체 클래스
- **Aggregate**: Iterator 객체를 생성하는 인터페이스
- **ConcreteAggregate**: Aggregate를 구현하는 구체 클래스

**장점**:

- 집합 객체의 내부 표현 노출 방지
- 집합 객체와 순회 알고리즘의 분리
- 다양한 순회 알고리즘 지원

**단점**:

- 클래스 수 증가
- 단순한 집합에 대한 오버헤드

**사용 시기**:

- 집합 객체의 내부 표현을 노출하지 않고 순회하고 싶을 때
- 다양한 순회 알고리즘을 지원하고 싶을 때

### 5. 메디에이터 (Mediator)

**목적**: 객체들 간의 상호작용을 캡슐화하여, 객체들이 서로를 직접 참조하지 않도록 합니다.

**구조**:

- **Mediator**: Colleague 객체들과 통신하는 인터페이스
- **ConcreteMediator**: Colleague 객체들과의 협력을 조정
- **Colleague**: Mediator와 통신하는 객체들의 인터페이스
- **ConcreteColleague**: Mediator와 통신하는 구체 클래스

**장점**:

- 객체 간의 결합도 감소
- 중앙 집중식 제어
- 새로운 Colleague 추가 용이

**단점\*\***

- Mediator의 복잡성 증가
- 단일 실패 지점
- 성능 병목 가능성

**사용 시기**:

- 객체들 간의 복잡한 상호작용이 있을 때
- 객체들이 서로를 직접 참조하지 않게 하고 싶을 때

### 6. 메멘토 (Memento)

**목적**: 객체의 내부 상태를 저장하여, 나중에 이 상태로 복원할 수 있게 합니다.

**구조**:

- **Memento**: Originator의 내부 상태를 저장
- **Originator**: 현재 상태를 저장하고 복원하는 객체
- **Caretaker**: Memento 객체를 보관하지만 조작하지 않음

**장점**:

- 객체의 캡슐화 유지
- 상태 복원 기능
- 히스토리 관리

**단점**:

- 메모리 사용량 증가
- 복잡한 상태 관리
- 성능 오버헤드

**사용 시기**:

- 객체의 상태를 저장하고 복원해야 할 때
- 객체의 캡슐화를 깨뜨리지 않고 상태를 저장하고 싶을 때

### 7. 옵저버 (Observer)

**목적**: 객체들 간의 일대다 의존성을 정의하여, 한 객체의 상태가 변경될 때 모든 의존자들이 자동으로 통지받고 업데이트되도록 합니다.

**구조**:

- **Subject**: Observer 객체들을 알고 있는 객체
- **Observer**: Subject의 상태 변화를 통지받는 객체들의 인터페이스
- **ConcreteSubject**: ConcreteObserver에게 통지하는 구체 클래스
- **ConcreteObserver**: Subject의 상태 변화에 대한 응답을 정의

**장점**:

- 느슨한 결합
- 일대다 관계 지원
- 자동 통지

**단점\*\***

- 예상치 못한 업데이트
- 메모리 누수 가능성
- 순환 참조 위험

**사용 시기**:

- 객체의 상태 변화를 다른 객체들에게 통지해야 할 때
- 객체들 간의 느슨한 결합을 원할 때

### 8. 상태 (State)

**목적**: 객체의 내부 상태에 따라 객체의 행동을 변경할 수 있게 합니다.

**구조**:

- **Context**: 클라이언트가 관심을 가지는 인터페이스를 정의
- **State**: 상태를 캡슐화하는 인터페이스
- **ConcreteState**: State를 구현하는 구체 클래스

**장점**:

- 상태 전환 로직 단순화
- 새로운 상태 추가 용이
- 상태별 행동 캡슐화

**단점\*\***

- 클래스 수 증가
- 상태 전환 복잡성
- 디버깅 어려움

**사용 시기**:

- 객체의 행동이 상태에 따라 달라져야 할 때
- 상태 전환 로직이 복잡할 때

### 9. 전략 (Strategy)

**목적**: 알고리즘을 정의하고, 각각을 캡슐화하며, 이들을 서로 교환해서 사용할 수 있게 합니다.

**구조**:

- **Strategy**: 알고리즘을 캡슐화하는 인터페이스
- **ConcreteStrategy**: Strategy를 구현하는 구체 클래스
- **Context**: Strategy 객체에 대한 참조를 유지

**장점**:

- 알고리즘의 교환 가능
- 새로운 알고리즘 추가 용이
- 조건문 제거

**단점\*\***

- 클래스 수 증가
- 모든 전략이 동일한 인터페이스 구현 필요
- 클라이언트가 전략을 알아야 함

**사용 시기**:

- 관련된 알고리즘들이 클래스 계층구조를 이루고 있을 때
- 런타임에 알고리즘을 선택해야 할 때

### 10. 템플릿 메서드 (Template Method)

**목적**: 알고리즘의 골격을 정의하고, 일부 단계를 하위 클래스에서 구현하도록 합니다.

**구조**:

- **AbstractClass**: 템플릿 메서드를 정의하는 추상 클래스
- **ConcreteClass**: 구체적인 하위 클래스

**장점**:

- 코드 재사용
- 알고리즘 구조 일관성
- 하위 클래스에서 특정 단계만 구현

**단점\*\***

- 상속을 통한 구현
- 하위 클래스의 자유도 제한
- 리스코프 치환 원칙 위반 가능성

**사용 시기**:

- 알고리즘의 구조를 재사용하고 싶을 때
- 하위 클래스에서 알고리즘의 특정 단계만 구현하고 싶을 때

### 11. 비지터 (Visitor)

**목적**: 객체 구조에 속한 요소에 수행할 연산을 표현합니다.

**구조**:

- **Visitor**: 각 ConcreteElement 클래스에 대한 visit 연산을 선언
- **ConcreteVisitor**: 각 ConcreteElement 클래스에 대한 visit 연산을 구현
- **Element**: Visitor가 방문할 수 있는 인터페이스
- **ConcreteElement**: Element를 구현하는 구체 클래스

**장점**:

- 새로운 연산 추가 용이
- 관련된 연산들을 한 클래스에 모음
- 객체 구조와 연산 분리

**단점\*\***

- 새로운 ConcreteElement 추가 시 모든 Visitor 수정
- 캡슐화 위반
- 복잡한 구조

**사용 시기**:

- 객체 구조에 새로운 연산을 추가하고 싶을 때
- 객체 구조와 연산을 분리하고 싶을 때

## 🎯 디자인 패턴의 실제 활용

### 1. 패턴 선택 기준

**생성 패턴 선택**:

- **싱글톤**: 전역 상태 관리가 필요할 때
- **팩토리 메서드**: 객체 생성 로직을 하위 클래스에 위임하고 싶을 때
- **빌더**: 복잡한 객체를 단계별로 생성해야 할 때

**구조 패턴 선택**:

- **어댑터**: 기존 코드와 새로운 인터페이스 간 호환성이 필요할 때
- **데코레이터**: 런타임에 기능을 추가해야 할 때
- **프록시**: 객체 접근을 제어해야 할 때

**행동 패턴 선택**:

- **옵저버**: 객체 간 느슨한 결합이 필요할 때
- **전략**: 런타임에 알고리즘을 선택해야 할 때
- **커맨드**: 요청을 객체로 캡슐화해야 할 때

### 2. 패턴 조합

**MVC 아키텍처**:

- **Model**: 데이터와 비즈니스 로직
- **View**: 사용자 인터페이스
- **Controller**: 사용자 입력 처리

**Repository 패턴**:

- **Repository**: 데이터 접근 추상화
- **Unit of Work**: 트랜잭션 관리
- **Specification**: 복잡한 쿼리 조건

### 3. 안티패턴과 주의사항

**God Object**: 너무 많은 책임을 가진 객체
**Anemic Domain Model**: 데이터만 가지고 행동이 없는 객체
**Circular Dependency**: 객체 간 순환 참조

## 📚 학습 포인트

1. **패턴의 목적과 구조**: 각 패턴이 해결하는 문제와 구현 방법
2. **패턴 간의 관계**: 패턴들이 어떻게 연결되고 상호작용하는지
3. **적용 시기**: 언제 어떤 패턴을 사용해야 하는지
4. **구현 세부사항**: 실제 코드에서 패턴을 어떻게 구현하는지
5. **성능과 유지보수성**: 패턴 사용의 장단점과 트레이드오프

## 🎯 실제 활용 시 고려사항

1. **문제의 본질**: 패턴을 사용하기 전에 문제를 정확히 파악
2. **복잡성 관리**: 패턴 사용이 코드를 더 복잡하게 만들지 않는지 확인
3. **팀 이해도**: 팀원들이 패턴을 이해하고 사용할 수 있는지 고려
4. **유지보수성**: 장기적인 관점에서 코드의 유지보수성 향상
5. **성능**: 패턴 사용이 성능에 미치는 영향 고려

## 🔍 디자인 패턴의 미래

- **함수형 프로그래밍**: 함수형 패러다임과의 융합
- **마이크로서비스**: 분산 시스템에서의 패턴 적용
- **클라우드 네이티브**: 클라우드 환경에 최적화된 패턴
- **AI/ML**: 머신러닝 시스템에서의 패턴 활용
- **도메인 주도 설계**: 비즈니스 도메인에 특화된 패턴
