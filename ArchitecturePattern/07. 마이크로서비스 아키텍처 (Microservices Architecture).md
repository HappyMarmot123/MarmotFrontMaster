# 마이크로서비스 아키텍처 (Microservices Architecture)

## 📖 개요

**마이크로서비스 아키텍처(Microservices Architecture)**는 하나의 거대한 애플리케이션을 여러 개의 독립적인 작은 서비스로 나누는 방식입니다. 각 서비스는 자체 데이터베이스를 가질 수 있고, 독립적으로 개발, 배포, 확장할 수 있습니다. Node.js, Java, Python 등 다양한 언어에서 사용됩니다.

## 🏗️ 마이크로서비스의 등장 배경

### 1. 모놀리식 아키텍처의 한계

**기존 모놀리식 시스템의 문제점**:

- **단일 장애점**: 하나의 컴포넌트 오류가 전체 시스템 다운을 야기
- **기술 종속성**: 전체 애플리케이션이 하나의 기술 스택에 제약
- **확장성 한계**: 일부 기능만 확장하려 해도 전체 시스템을 확장해야 함
- **배포 복잡성**: 작은 변경에도 전체 애플리케이션 재배포 필요

**대규모 조직에서의 어려움**:

- **팀 간 의존성**: 여러 팀이 하나의 코드베이스에서 작업 시 충돌 발생
- **릴리즈 병목**: 하나의 기능 지연이 전체 릴리즈에 영향
- **코드베이스 비대화**: 수백만 줄의 코드로 인한 개발 속도 저하
- **신기술 도입 어려움**: 기존 아키텍처와의 호환성 문제

### 2. 클라우드 네이티브 시대의 요구사항

**현대적 애플리케이션의 특징**:

- **높은 가용성**: 24/7 서비스 운영과 무중단 배포
- **탄력적 확장**: 트래픽에 따른 자동 스케일링
- **글로벌 분산**: 전 세계 사용자를 위한 지리적 분산
- **빠른 혁신**: 시장 변화에 대한 신속한 대응

### 3. DevOps와 애자일의 발전

**개발 방법론의 변화**:

- **지속적 통합/배포(CI/CD)**: 자동화된 빌드와 배포 파이프라인
- **Infrastructure as Code**: 인프라의 코드화와 버전 관리
- **컨테이너 기술**: Docker와 Kubernetes의 대중화
- **클라우드 서비스**: AWS, Azure, GCP의 관리형 서비스 활용

### 4. 성공 사례와 대중화

**선구자 기업들의 경험**:

- **Netflix**: 수천 개의 마이크로서비스로 글로벌 스트리밍 서비스 운영
- **Amazon**: 각 팀이 독립적인 서비스를 소유하고 운영하는 조직 구조
- **Uber**: 실시간 위치 추적과 결제 시스템의 독립적 확장
- **Spotify**: 음악 스트리밍과 추천 시스템의 분리된 마이크로서비스

## 🏗️ 마이크로서비스 아키텍처 구조

### 핵심 구성 요소

```
┌─────────────────────────────────────────────────────────────┐
│                    API Gateway                              │ ← 단일 진입점
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   User      │  │   Product   │  │   Order     │        │ ← 독립적 서비스
│  │  Service    │  │   Service   │  │   Service   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   User      │  │   Product   │  │   Order     │        │ ← 독립적 데이터베이스
│  │  Database   │  │  Database   │  │  Database   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 특징

- **독립성**: 각 서비스가 독립적으로 개발, 배포, 확장 가능
- **자율성**: 각 서비스가 자체 데이터베이스와 비즈니스 로직 보유
- **다양성**: 서비스별로 다른 기술 스택 사용 가능
- **장애 격리**: 하나의 서비스 장애가 전체 시스템에 영향 최소화

## 🔍 마이크로서비스 구현 예시

### 1. API Gateway

```typescript
// src/gateway/APIGateway.ts
export class APIGateway {
  private app: express.Application;
  private port: number;

  constructor(port: number = 3000) {
    this.app = express();
    this.port = port;
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupRoutes(): void {
    // User Service Proxy
    this.app.use(
      "/api/users",
      authenticateToken,
      createProxyMiddleware({
        target: process.env.USER_SERVICE_URL || "http://localhost:3001",
        changeOrigin: true,
      })
    );

    // Product Service Proxy
    this.app.use(
      "/api/products",
      createProxyMiddleware({
        target: process.env.PRODUCT_SERVICE_URL || "http://localhost:3002",
        changeOrigin: true,
      })
    );
  }

  public start(): void {
    this.app.listen(this.port, () => {
      console.log(`API Gateway is running on port ${this.port}`);
    });
  }
}
```

### 2. User Service

```typescript
// src/services/UserService.ts
export class UserService {
  private app: express.Application;
  private port: number;

  constructor(port: number = 3001) {
    this.app = express();
    this.port = port;
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupRoutes(): void {
    const userController = new UserController(
      new UserRepository(),
      new JwtService(),
      new PasswordHasher(),
      new EmailService()
    );

    this.app.post(
      "/api/users/register",
      userController.register.bind(userController)
    );
    this.app.post(
      "/api/users/login",
      userController.login.bind(userController)
    );
    this.app.get(
      "/api/users/profile",
      userController.getProfile.bind(userController)
    );
  }

  public start(): void {
    this.app.listen(this.port, () => {
      console.log(`User Service is running on port ${this.port}`);
    });
  }
}

// src/controllers/UserController.ts
export class UserController {
  constructor(
    private userRepository: UserRepository,
    private jwtService: JwtService,
    private passwordHasher: PasswordHasher,
    private emailService: EmailService
  ) {}

  async register(req: Request, res: Response): Promise<void> {
    try {
      const userData: CreateUserDto = req.body;

      // 이메일 중복 확인
      const existingUser = await this.userRepository.findByEmail(
        userData.email
      );
      if (existingUser) {
        res.status(409).json({ error: "이미 존재하는 이메일입니다." });
        return;
      }

      // 비밀번호 해싱
      const hashedPassword = await this.passwordHasher.hash(userData.password);

      // 사용자 생성
      const newUser = await this.userRepository.create({
        ...userData,
        password: hashedPassword,
      });

      // JWT 토큰 생성
      const token = this.jwtService.generateToken({
        userId: newUser.id,
        email: newUser.email,
        role: newUser.role,
      });

      res.status(201).json({
        success: true,
        user: newUser,
        token,
      });
    } catch (error) {
      res.status(500).json({ error: "사용자 등록 중 오류가 발생했습니다." });
    }
  }
}
```

### 3. Product Service

```typescript
// src/services/ProductService.ts
export class ProductService {
  private app: express.Application;
  private port: number;

  constructor(port: number = 3002) {
    this.app = express();
    this.port = port;
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupRoutes(): void {
    const productController = new ProductController(new ProductRepository());

    this.app.get(
      "/api/products",
      productController.getProducts.bind(productController)
    );
    this.app.get(
      "/api/products/:id",
      productController.getProductById.bind(productController)
    );
    this.app.post(
      "/api/products",
      productController.createProduct.bind(productController)
    );
  }

  public start(): void {
    this.app.listen(this.port, () => {
      console.log(`Product Service is running on port ${this.port}`);
    });
  }
}

// src/controllers/ProductController.ts
export class ProductController {
  constructor(private productRepository: ProductRepository) {}

  async getProducts(req: Request, res: Response): Promise<void> {
    try {
      const { page = 1, limit = 10, category } = req.query;

      const result = await this.productRepository.findAll({
        page: Number(page),
        limit: Number(limit),
        category: category as string,
      });

      res.json({ success: true, data: result });
    } catch (error) {
      res.status(500).json({ error: "상품 목록 조회 중 오류가 발생했습니다." });
    }
  }
}
```

### 4. Service Discovery & Configuration

```typescript
// src/config/ServiceRegistry.ts
export interface ServiceInfo {
  name: string;
  url: string;
  health: string;
  version: string;
  status: "healthy" | "unhealthy" | "unknown";
  lastCheck: Date;
}

export class ServiceRegistry {
  private static instance: ServiceRegistry;
  private services: Map<string, ServiceInfo> = new Map();

  private constructor() {
    this.initializeServices();
    this.startHealthCheck();
  }

  public static getInstance(): ServiceRegistry {
    if (!ServiceRegistry.instance) {
      ServiceRegistry.instance = new ServiceRegistry();
    }
    return ServiceRegistry.instance;
  }

  private initializeServices(): void {
    const services = [
      {
        name: "user-service",
        url: process.env.USER_SERVICE_URL || "http://localhost:3001",
        health: "/health",
        version: "1.0.0",
      },
      {
        name: "product-service",
        url: process.env.PRODUCT_SERVICE_URL || "http://localhost:3002",
        health: "/health",
        version: "1.0.0",
      },
    ];

    services.forEach((service) => {
      this.services.set(service.name, {
        ...service,
        status: "unknown",
        lastCheck: new Date(),
      });
    });
  }

  public getService(name: string): ServiceInfo | undefined {
    return this.services.get(name);
  }
}
```

## 🎯 마이크로서비스의 장점

### 1. 독립성

- 각 서비스가 독립적으로 개발, 배포, 확장 가능
- 서비스별로 다른 기술 스택 사용 가능

### 2. 장애 격리

- 하나의 서비스 장애가 전체 시스템에 영향 최소화
- 서비스별로 다른 장애 대응 전략 적용 가능

### 3. 확장성

- 필요한 서비스만 선택적으로 확장 가능
- 서비스별로 다른 확장 전략 적용 가능

### 4. 개발 효율성

- 팀별로 독립적인 개발 가능
- 서비스별로 다른 개발 주기 적용 가능

## ⚠️ 주의사항

### 1. 복잡성 증가

- 서비스 간 통신과 조정 복잡성 증가
- 분산 시스템의 복잡성 관리 필요

### 2. 데이터 일관성

- 서비스 간 데이터 일관성 보장 어려움
- 분산 트랜잭션 관리 필요

### 3. 네트워크 지연

- 서비스 간 통신으로 인한 지연 발생
- 네트워크 장애에 대한 대응 필요

## 🚀 고급 패턴

### 1. Circuit Breaker Pattern

```typescript
// 서비스 간 통신의 안정성 향상
export class CircuitBreaker {
  private state: "CLOSED" | "OPEN" | "HALF_OPEN" = "CLOSED";
  private failureCount = 0;
  private readonly threshold = 5;

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === "OPEN") {
      throw new Error("Circuit breaker is OPEN");
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failureCount = 0;
    this.state = "CLOSED";
  }

  private onFailure(): void {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = "OPEN";
    }
  }
}
```

### 2. Event Sourcing

```typescript
// 서비스 간 데이터 동기화
export interface DomainEvent {
  id: string;
  type: string;
  aggregateId: string;
  data: any;
  timestamp: Date;
}

export class EventStore {
  private events: DomainEvent[] = [];

  async append(event: DomainEvent): Promise<void> {
    this.events.push(event);
    await this.publishEvent(event);
  }

  async getEvents(aggregateId: string): Promise<DomainEvent[]> {
    return this.events.filter((event) => event.aggregateId === aggregateId);
  }

  private async publishEvent(event: DomainEvent): Promise<void> {
    // Redis, RabbitMQ, Kafka 등을 통한 이벤트 발행
  }
}
```

## 📚 결론

마이크로서비스 아키텍처는 대규모 애플리케이션의 복잡성을 관리하고 확장성을 향상시킬 수 있는 강력한 패턴입니다.

적절히 적용하면:

- **높은 독립성**으로 개발과 배포의 유연성 증대
- **장애 격리**로 시스템의 안정성 향상
- **확장성**으로 비즈니스 요구사항에 맞는 유연한 확장 가능
- **기술 다양성**으로 서비스별 최적의 기술 스택 선택 가능

프로젝트의 규모와 복잡성을 고려하여 마이크로서비스 아키텍처를 적용하여 효율적인 분산 시스템을 구축하세요.
