# MVP (Model-View-Presenter)

## 📖 개요

**MVP(Model-View-Presenter)**는 **프레젠터(Presenter)**가 뷰와 모델 사이의 로직을 처리하는 패턴입니다. 뷰는 프레젠터에 종속되어 있고, 프레젠터는 뷰의 상태를 제어합니다. 이 패턴은 모바일 앱과 웹 애플리케이션에서 많이 사용되며, 테스트 용이성과 관심사 분리를 통해 코드의 유지보수성을 향상시킵니다.

## 🏗️ MVP의 등장 배경

### 1. MVC 패턴의 한계점

**전통적인 MVC의 문제**:

- **View와 Model의 직접적 관계**: View가 Model을 직접 관찰하여 강한 결합 발생
- **Controller의 역할 모호성**: UI 로직과 비즈니스 로직의 경계가 불분명
- **테스트 어려움**: View와 Controller가 UI 프레임워크에 강하게 의존
- **플랫폼별 구현 차이**: 웹과 데스크톱에서 MVC 해석이 달라짐

### 2. GUI 애플리케이션의 복잡성 증가

**1990년대 데스크톱 애플리케이션의 발전**:

- **Windows Forms와 WinAPI**: 복잡한 이벤트 기반 프로그래밍
- **사용자 인터랙션 증가**: 마우스, 키보드, 다양한 입력 방식 지원
- **실시간 UI 업데이트**: 데이터 변경에 따른 즉각적인 화면 반영 필요
- **상태 관리 복잡성**: 다중 창과 다양한 UI 컴포넌트 간 상태 동기화

### 3. MVP의 탄생과 진화

**Microsoft의 기여 (1990년대)**:

- **Taligent의 MVP**: IBM과 Apple의 협업으로 시작된 객체지향 OS 프로젝트
- **Microsoft MFC**: C++를 위한 Document/View 아키텍처에서 MVP 개념 도입
- **ASP.NET Web Forms**: 웹 개발에서 MVP 패턴의 구체적 구현

### 4. 모바일과 웹의 현대적 적용

**모바일 앱 개발의 요구사항**:

- **플랫폼별 UI 차이**: iOS, Android의 서로 다른 UI 가이드라인
- **생명주기 관리**: 액티비티와 프래그먼트의 복잡한 생명주기
- **메모리 제약**: 제한된 리소스에서의 효율적 메모리 사용
- **테스트 자동화**: 지속적 통합을 위한 자동화된 테스트 필요

**현대 웹 개발에서의 MVP**:

- **SPA(Single Page Application)**: 복잡한 클라이언트 사이드 로직 관리
- **컴포넌트 기반 개발**: React, Angular에서의 컴포넌트 아키텍처
- **상태 관리 라이브러리**: Redux, MobX와의 조합을 통한 MVP 구현

## 🏗️ MVP 아키텍처 구조

### 핵심 구성 요소

```
┌─────────────┐    ┌─────────────────┐    ┌─────────────┐
│    View     │◄──►│   Presenter     │◄──►│    Model    │
│  (UI)      │    │  (로직 처리)     │    │  (데이터)   │
└─────────────┘    └─────────────────┘    └─────────────┘
```

### 1. Model (모델)

- **데이터 구조**: 비즈니스 로직과 데이터를 담당
- **API 통신**: 서버와의 데이터 교환
- **비즈니스 규칙**: 도메인 로직과 유효성 검사
- **상태 관리**: 애플리케이션의 상태 정보 관리

### 2. View (뷰)

- **UI 표현**: 사용자에게 보여지는 인터페이스
- **사용자 입력**: 사용자의 액션을 프레젠터에 전달
- **프레젠터 의존**: 프레젠터의 지시에 따라 UI 업데이트
- **상태 표시**: 프레젠터에서 전달받은 데이터를 표시

### 3. Presenter (프레젠터)

- **로직 처리**: 사용자 액션과 비즈니스 로직 처리
- **뷰 제어**: 뷰의 상태와 동작을 제어
- **모델 조작**: 모델의 데이터를 조작하고 업데이트
- **데이터 변환**: 모델의 데이터를 뷰에 맞게 가공

## 🔍 React에서의 MVP 구현

### 1. Model Layer

```typescript
// src/models/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: "user" | "admin";
}

export interface CreateUserDto {
  name: string;
  email: string;
  password: string;
  role: "user" | "admin";
}

// src/models/UserRepository.ts
export class UserRepository {
  private apiUrl = "/api/users";

  async getUsers(): Promise<User[]> {
    const response = await fetch(this.apiUrl);
    if (!response.ok) {
      throw new Error("사용자 목록을 가져올 수 없습니다.");
    }
    return response.json();
  }

  async createUser(userData: CreateUserDto): Promise<User> {
    const response = await fetch(this.apiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });
    if (!response.ok) {
      throw new Error("사용자 생성에 실패했습니다.");
    }
    return response.json();
  }
}
```

### 2. Presenter Layer

```typescript
// src/presenters/UserPresenter.ts
export class UserPresenter {
  private view: UserView;
  private repository: UserRepository;
  private state: UserViewState;

  constructor(view: UserView, repository: UserRepository) {
    this.view = view;
    this.repository = repository;
    this.state = this.getInitialState();
    this.updateView();
  }

  // 사용자 목록 로드
  async loadUsers(): Promise<void> {
    try {
      this.setState({ loading: true, error: null });

      const users = await this.repository.getUsers();
      this.setState({ users, loading: false });
    } catch (error) {
      const errorMessage =
        error instanceof Error
          ? error.message
          : "알 수 없는 오류가 발생했습니다.";
      this.setState({ error: errorMessage, loading: false });
    }
  }

  // 사용자 생성
  async createUser(): Promise<void> {
    try {
      this.setState({ loading: true, error: null });

      const newUser = await this.repository.createUser(this.state.formData);
      const updatedUsers = [...this.state.users, newUser];

      this.setState({
        users: updatedUsers,
        loading: false,
        formData: this.getInitialState().formData,
      });

      this.view.showSuccessMessage("사용자가 성공적으로 생성되었습니다.");
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "사용자 생성에 실패했습니다.";
      this.setState({ error: errorMessage, loading: false });
      this.view.showErrorMessage(errorMessage);
    }
  }

  // 상태 업데이트 및 뷰 갱신
  private setState(updates: Partial<UserViewState>): void {
    this.state = { ...this.state, ...updates };
    this.updateView();
  }

  private updateView(): void {
    this.view.updateState(this.state);
  }
}
```

### 3. View Layer

```typescript
// src/views/UserView.ts
export class UserView extends React.Component<{}, UserViewState> {
  private presenter: UserPresenter;
  private repository: UserRepository;

  constructor(props: {}) {
    super(props);

    this.repository = new UserRepository();
    this.presenter = new UserPresenter(this, this.repository);

    this.state = this.presenter.getState();
  }

  componentDidMount(): void {
    this.presenter.loadUsers();
  }

  // 프레젠터에서 호출되는 메서드들
  updateState(newState: UserViewState): void {
    this.setState(newState);
  }

  showSuccessMessage(message: string): void {
    console.log("Success:", message);
  }

  showErrorMessage(message: string): void {
    console.error("Error:", message);
  }

  // 이벤트 핸들러들
  handleCreateUser = (): void => {
    this.presenter.createUser();
  };

  render(): JSX.Element {
    const { users, loading, error } = this.state;

    if (loading) return <div className="loading">로딩 중...</div>;
    if (error) return <div className="error">오류: {error}</div>;

    return (
      <div className="user-view">
        <h1>사용자 관리</h1>
        <UserList users={users} />
        <UserForm onSubmit={this.handleCreateUser} />
      </div>
    );
  }
}

// src/components/UserList.tsx
export const UserList: React.FC<UserListProps> = ({
  users,
  selectedUser,
  onUserSelect,
  onDeleteUser,
}) => {
  return (
    <div className="user-list">
      <h2>사용자 목록</h2>
      <div className="user-list__items">
        {users.map((user) => (
          <div
            key={user.id}
            className={`user-list__item ${
              selectedUser?.id === user.id ? "selected" : ""
            }`}
            onClick={() => onUserSelect(user)}
          >
            <div className="user-list__item-name">{user.name}</div>
            <div className="user-list__item-email">{user.email}</div>
            <button
              onClick={(e) => {
                e.stopPropagation();
                onDeleteUser(user.id);
              }}
            >
              삭제
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## 🎯 MVP의 장점

### 1. 관심사 분리

- **Model**: 데이터와 비즈니스 로직
- **View**: UI 표현
- **Presenter**: 로직 처리와 뷰 제어

### 2. 테스트 용이성

- Presenter를 독립적으로 테스트 가능
- Mock View를 사용한 단위 테스트 작성 용이

### 3. 뷰의 독립성

- 뷰가 비즈니스 로직에 의존하지 않음
- 프레젠터를 통한 일관된 인터페이스 제공

### 4. 유지보수성

- 각 계층의 독립적인 수정 가능
- 변경 사항의 영향 범위 최소화

## ⚠️ 주의사항

### 1. 프레젠터의 복잡성

- 프레젠터가 너무 복잡해지면 오히려 유지보수성 저하
- 적절한 크기와 책임 분리 유지

### 2. 뷰와 프레젠터의 결합

- 뷰가 프레젠터에 과도하게 의존하지 않도록 주의
- 인터페이스를 통한 느슨한 결합 유지

### 3. 상태 관리 복잡성

- 대규모 애플리케이션에서는 전역 상태 관리 라이브러리 고려
- Redux, Zustand, Context API 등 활용

## 🚀 고급 패턴

### 1. Passive View Pattern

```typescript
// 뷰가 완전히 수동적이 되도록 하는 패턴
export interface PassiveUserView {
  updateUsers(users: User[]): void;
  updateSelectedUser(user: User | null): void;
  updateLoading(loading: boolean): void;
  updateError(error: string | null): void;
  showSuccessMessage(message: string): void;
  showErrorMessage(message: string): void;
}
```

### 2. Supervising Controller Pattern

```typescript
// 프레젠터가 뷰의 동작을 감독하는 패턴
export class SupervisingUserPresenter {
  private view: UserView;
  private repository: UserRepository;

  constructor(view: UserView, repository: UserRepository) {
    this.view = view;
    this.repository = repository;
    this.setupViewBindings();
  }

  private setupViewBindings(): void {
    // 뷰의 이벤트를 프레젠터에 바인딩
    this.view.onUserSelect = this.handleUserSelect.bind(this);
    this.view.onCreateUser = this.handleCreateUser.bind(this);
  }
}
```

## 📚 결론

MVP는 현대적인 프론트엔드 개발에서 강력한 아키텍처 패턴입니다.

적절히 적용하면:

- **명확한 관심사 분리**로 코드의 가독성 향상
- **높은 테스트 용이성**으로 코드 품질 향상
- **뷰의 독립성**으로 UI 변경의 용이성 증대
- **유지보수성 향상**으로 장기적인 프로젝트 관리 용이

프로젝트의 규모와 복잡성을 고려하여 MVP를 적용하여 효율적인 프론트엔드 아키텍처를 구축하세요.
