# 프레젠테이셔널 & 컨테이너 패턴 (Presentational & Container Pattern)

## 📖 개요

**프레젠테이셔널 & 컨테이너 패턴**은 React에서 주로 사용되는 컴포넌트 설계 패턴으로, 컴포넌트를 두 가지 유형으로 나누어 관심사를 분리합니다. 이 패턴은 코드의 재사용성, 테스트 용이성, 유지보수성을 크게 향상시킵니다.

## 🏗️ 패턴의 등장 배경

### 1. 기존 문제점

React 애플리케이션이 복잡해지면서 여러 문제점들이 대두되었습니다:

- **단일 컴포넌트의 과부하**: 하나의 컴포넌트가 UI 렌더링, 상태 관리, API 호출 등 모든 책임을 담당
- **재사용성 부족**: UI 로직과 비즈니스 로직이 섞여 있어 다른 곳에서 재사용하기 어려움
- **테스트의 어려움**: 복잡한 로직이 섞여 있어 단위 테스트 작성이 까다로움
- **팀 협업의 비효율성**: 디자이너와 개발자가 동시에 작업하기 어려운 구조

### 2. 해결책으로서의 패턴

이 패턴은 Dan Abramov가 제안한 개념으로, 다음과 같은 문제들을 해결하기 위해 등장했습니다:

- **관심사 분리**: UI 로직과 비즈니스 로직을 명확히 분리
- **재사용성 향상**: 프레젠테이셔널 컴포넌트의 독립적 사용 가능
- **테스트 용이성**: 각 컴포넌트를 독립적으로 테스트 가능
- **협업 효율성**: 역할별 독립적 개발 가능

### 3. 실제 적용 사례

많은 대규모 React 애플리케이션에서 채택되고 있습니다:

- **Airbnb**: 컴포넌트 라이브러리 구축에 활용
- **Facebook**: React 자체 개발 과정에서 사용
- **Netflix**: UI 컴포넌트 시스템 구축에 적용

## 🔍 패턴의 핵심 개념

### 1. 프레젠테이셔널 컴포넌트 (Presentational Components)

**프레젠테이셔널 컴포넌트**는 '어떻게 보이는가'에 초점을 맞추며, UI를 담당합니다.

#### 특징

- **자체 상태 없음**: 최소한의 UI 상태만 가짐
- **Props 기반**: 데이터를 props로 받아서 표시
- **재사용 가능**: 다양한 컨테이너에서 재사용
- **테스트 용이**: 순수 함수형 컴포넌트
- **스타일링**: UI 스타일과 레이아웃 담당

#### 예시

```jsx
// UserCard.jsx - 프레젠테이셔널 컴포넌트
const UserCard = ({ user, onEdit, onDelete }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>수정</button>
      <button onClick={() => onDelete(user.id)}>삭제</button>
    </div>
  );
};
```

### 2. 컨테이너 컴포넌트 (Container Components)

**컨테이너 컴포넌트**는 '어떻게 동작하는가'에 초점을 맞추며, 데이터를 가져오거나 상태를 관리하는 로직을 담당합니다.

#### 특징

- **상태 관리**: 데이터 상태와 비즈니스 로직 담당
- **API 호출**: 서버와의 통신 처리
- **이벤트 핸들링**: 사용자 액션에 대한 응답
- **데이터 변환**: API 응답을 컴포넌트에 맞게 가공
- **자식 컴포넌트**: 프레젠테이셔널 컴포넌트에 데이터 전달

#### 예시

```jsx
// UserListContainer.jsx - 컨테이너 컴포넌트
const UserListContainer = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadUsers();
  }, []);

  const loadUsers = async () => {
    setLoading(true);
    const userData = await fetchUsers();
    setUsers(userData);
    setLoading(false);
  };

  const handleDelete = async (userId) => {
    await deleteUser(userId);
    setUsers(users.filter((user) => user.id !== userId));
  };

  if (loading) return <div>로딩 중...</div>;

  return (
    <div className="user-list">
      {users.map((user) => (
        <UserCard
          key={user.id}
          user={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
};
```

## 🎯 패턴의 장점

### 1. 관심사 분리 (Separation of Concerns)

**명확한 역할 분담**으로 코드의 구조를 체계화합니다:

- **UI 로직**: 프레젠테이셔널 컴포넌트에서 처리
  - 어떻게 보여줄 것인가 (How it looks)
  - 스타일링, 레이아웃, 애니메이션
  - 사용자 인터랙션의 UI 반응
- **비즈니스 로직**: 컨테이너 컴포넌트에서 처리
  - 어떻게 동작할 것인가 (How it works)
  - 데이터 페칭, 상태 관리
  - 비즈니스 규칙과 검증 로직

**이점**: 각 컴포넌트가 단일 책임 원칙(SRP)을 준수하여 코드의 가독성과 유지보수성이 향상됩니다.

### 2. 재사용성 향상

**프레젠테이셔널 컴포넌트의 높은 재사용성**을 제공합니다:

```jsx
// UserCard를 다양한 컨테이너에서 재사용
const AdminUserList = () => (
  <UserCard user={user} onEdit={handleEdit} onDelete={handleDelete} />
);

const PublicUserProfile = () => <UserCard user={user} />;
```

**실제 재사용 사례**:

- 동일한 UI 컴포넌트를 다른 데이터 소스에서 사용
- 권한에 따른 기능 제한 (props를 통한 조건부 기능 제공)
- 다양한 레이아웃에서 동일한 컴포넌트 활용

**경제적 효과**: 개발 시간 단축 및 코드 중복 제거로 유지보수 비용 절감

### 3. 테스트 용이성

**독립적인 테스트 환경**을 제공하여 테스트 코드 작성이 용이합니다:

```jsx
// 프레젠테이셔널 컴포넌트 테스트
describe("UserCard", () => {
  it("사용자 정보를 올바르게 표시한다", () => {
    const user = { name: "김철수", email: "test@example.com" };
    render(<UserCard user={user} />);
    expect(screen.getByText("김철수")).toBeInTheDocument();
  });
});
```

**테스트의 이점**:

- **단순성**: 프레젠테이셔널 컴포넌트는 순수 함수처럼 동작하여 테스트가 간단
- **독립성**: 외부 의존성 없이 props만으로 테스트 가능
- **빠른 실행**: API 호출이나 복잡한 상태 관리 없이 UI 로직만 테스트
- **스냅샷 테스트**: UI 변경사항을 쉽게 추적 가능

### 4. 병렬 개발 가능

**팀 협업의 효율성**을 극대화합니다:

- **디자이너**: 프레젠테이셔널 컴포넌트의 UI/UX 작업
- **프론트엔드 개발자**: 컨테이너 컴포넌트의 로직 구현
- **백엔드 개발자**: API 엔드포인트 개발

**결과**: 동시 진행 가능한 작업으로 전체 개발 기간 단축

## 🔧 실제 활용 사례

### 1. 폼 컴포넌트

```jsx
// 프레젠테이셔널: LoginForm
const LoginForm = ({ onSubmit, loading, error }) => (
  <form onSubmit={onSubmit}>
    <input type="email" placeholder="이메일" />
    <input type="password" placeholder="비밀번호" />
    <button type="submit" disabled={loading}>
      {loading ? "로그인 중..." : "로그인"}
    </button>
    {error && <div className="error">{error}</div>}
  </form>
);

// 컨테이너: LoginContainer
const LoginContainer = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    // 로그인 로직 처리
  };

  return <LoginForm onSubmit={handleSubmit} loading={loading} error={error} />;
};
```

### 2. 리스트 컴포넌트

```jsx
// 프레젠테이셔널: ProductGrid
const ProductGrid = ({ products, onProductClick }) => (
  <div className="product-grid">
    {products.map((product) => (
      <ProductCard
        key={product.id}
        product={product}
        onClick={() => onProductClick(product.id)}
      />
    ))}
  </div>
);

// 컨테이너: ProductListContainer
const ProductListContainer = ({ category }) => {
  const [products, setProducts] = useState([]);

  useEffect(() => {
    fetchProductsByCategory(category).then(setProducts);
  }, [category]);

  return (
    <ProductGrid
      products={products}
      onProductClick={(id) => navigate(`/product/${id}`)}
    />
  );
};
```

## 🔧 설계 방법론

### 1. 컴포넌트 분류 기준

**프레젠테이셔널 컴포넌트로 분류할 조건**:

- UI 표현에만 집중하는 컴포넌트
- 외부 데이터 소스에 의존하지 않는 컴포넌트
- props를 통해서만 데이터를 받는 컴포넌트
- 재사용 가능성이 높은 컴포넌트

**컨테이너 컴포넌트로 분류할 조건**:

- 상태 관리가 필요한 컴포넌트
- API 호출이나 외부 데이터 소스에 접근하는 컴포넌트
- 비즈니스 로직을 포함하는 컴포넌트
- 라우팅이나 전역 상태와 연결되는 컴포넌트

### 2. 단계별 설계 과정

**1단계: 요구사항 분석**

- 화면에 필요한 데이터와 기능 정의
- 사용자 인터랙션과 비즈니스 규칙 파악

**2단계: 컴포넌트 분리**

- UI 요소를 프레젠테이셔널 컴포넌트로 추출
- 로직과 상태를 컨테이너 컴포넌트로 분리

**3단계: 인터페이스 정의**

- props의 타입과 콜백 함수 시그니처 정의
- 컴포넌트 간 데이터 흐름 설계

**4단계: 구현 및 테스트**

- 각 컴포넌트를 독립적으로 구현
- 단위 테스트와 통합 테스트 작성

### 3. 베스트 프랙티스

**Props 설계 원칙**:

- 컴포넌트가 필요한 최소한의 데이터만 전달
- 콜백 함수는 명확한 네이밍 규칙 적용 (onAction 형태)
- PropTypes나 TypeScript를 통한 타입 검증

**상태 관리 원칙**:

- 가능한 한 상태를 컨테이너 컴포넌트에 집중
- 전역 상태는 Redux, Zustand 등의 라이브러리 활용
- 지역 상태는 useState, useReducer 활용

## ⚠️ 주의사항

### 1. 과도한 분리

**문제점**:

- 너무 작은 컴포넌트로 분리하면 오히려 복잡성 증가
- 파일 수가 급격히 늘어나 프로젝트 구조가 복잡해짐

**해결책**:

- 적절한 크기와 책임을 고려하여 분리
- "한 번에 하나의 일만 하는" 단일 책임 원칙 적용
- 컴포넌트의 크기보다는 역할과 책임에 집중

### 2. Props Drilling

```jsx
// 나쁜 예: 너무 깊은 props 전달
const App = () => (
  <Layout>
    <Header>
      <Navigation>
        <UserMenu user={user} onLogout={handleLogout} />
      </Navigation>
    </Header>
  </Layout>
);

// 좋은 예: Context나 상태 관리 라이브러리 사용
const UserContext = createContext();
const App = () => (
  <UserContext.Provider value={{ user, onLogout: handleLogout }}>
    <Layout>
      <Header>
        <Navigation>
          <UserMenu />
        </Navigation>
      </Header>
    </Layout>
  </UserContext.Provider>
);
```

## 🚀 고급 패턴

### 1. HOC (Higher-Order Component) 활용

```jsx
// withUserData HOC
const withUserData = (WrappedComponent) => {
  return (props) => {
    const [user, setUser] = useState(null);

    useEffect(() => {
      fetchCurrentUser().then(setUser);
    }, []);

    return <WrappedComponent {...props} user={user} />;
  };
};

// 사용
const UserProfile = withUserData(({ user }) => (
  <div>{user ? user.name : "로딩 중..."}</div>
));
```

### 2. Custom Hook 활용

```jsx
// useUsers custom hook
const useUsers = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);

  const fetchUsers = async () => {
    setLoading(true);
    try {
      const data = await api.fetchUsers();
      setUsers(data);
    } catch (err) {
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  return { users, loading, fetchUsers };
};

// 컨테이너에서 사용
const UserListContainer = () => {
  const { users, loading, fetchUsers } = useUsers();

  useEffect(() => {
    fetchUsers();
  }, []);

  return <UserList users={users} loading={loading} />;
};
```

## 📚 결론

프레젠테이셔널 & 컨테이너 패턴은 React 애플리케이션의 구조를 명확하게 하고, 코드의 재사용성과 유지보수성을 향상시키는 강력한 패턴입니다.

이 패턴을 적절히 활용하면:

- **관심사 분리**로 코드의 가독성 향상
- **재사용 가능한 UI 컴포넌트**로 개발 효율성 증대
- **테스트 용이성**으로 코드 품질 향상
- **팀 협업**에서 역할 분담 명확화

프로젝트의 규모와 복잡성에 따라 적절히 적용하여 효율적인 React 애플리케이션을 구축하세요.
