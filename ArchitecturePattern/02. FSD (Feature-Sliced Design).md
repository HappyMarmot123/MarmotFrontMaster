# FSD (Feature-Sliced Design)

## 📖 개요

**FSD(Feature-Sliced Design)**는 애플리케이션의 코드를 기능(Features), 엔티티(Entities), 공유(Shared) 레이어로 나누는 모듈식 접근법입니다. 각 레이어는 특정 역할을 담당하고, 상호 의존성을 명확히 하여 대규모 애플리케이션의 유지보수성을 높입니다.

## 🏗️ FSD의 등장 배경

### 1. 기존 아키텍처의 한계점

**전통적인 폴더 구조의 문제**:

- **기술별 분리**: components/, services/, utils/ 등 기술적 기준으로만 분리
- **도메인 분산**: 하나의 기능이 여러 폴더에 흩어져 있어 찾기 어려움
- **의존성 혼재**: 서로 다른 기능 간 무분별한 의존성 발생
- **확장성 부족**: 새로운 기능 추가 시 기존 구조에 영향을 미침

**실제 문제 사례**:

```
// 전통적인 구조의 문제점
src/
├── components/
│   ├── UserProfile.jsx     // 사용자 관련
│   ├── ProductCard.jsx     // 상품 관련
│   └── OrderHistory.jsx    // 주문 관련
├── services/
│   ├── userService.js      // 사용자 API
│   ├── productService.js   // 상품 API
│   └── orderService.js     // 주문 API
└── utils/
    ├── userUtils.js        // 사용자 유틸리티
    └── validation.js       // 공통 검증

// 문제: 하나의 기능을 수정하려면 여러 폴더를 오가야 함
```

### 2. FSD의 철학과 해결책

**FSD의 핵심 원칙**:

- **기능별 분리**: 비즈니스 기능을 중심으로 코드 구성
- **명확한 의존성**: 레이어 간 의존 방향을 엄격히 관리
- **독립적 개발**: 각 기능을 독립적으로 개발하고 테스트 가능
- **점진적 성장**: 애플리케이션이 커져도 구조가 무너지지 않음

### 3. 실제 도입 사례

**대규모 프로젝트에서의 성공 사례**:

- **Yandex**: 러시아 최대 검색 엔진 회사에서 개발한 방법론
- **VK**: 러시아 최대 SNS 플랫폼에서 활용
- **다양한 오픈소스 프로젝트**: React, Vue 생태계에서 채택 증가

**도입 이유**:

- 팀 규모 확장에도 코드 품질 유지
- 새로운 개발자의 프로젝트 이해도 향상
- 기능별 독립적인 배포 및 테스트 가능

## 🏗️ FSD 아키텍처 구조

### 레이어 구조 (위에서 아래로)

```
src/
├── app/          # 애플리케이션 설정, 라우팅, 글로벌 스타일
├── pages/        # 페이지 컴포넌트
├── widgets/      # 독립적인 UI 블록 (헤더, 사이드바, 폼 등)
├── features/     # 비즈니스 기능 (로그인, 검색, 필터링 등)
├── entities/     # 비즈니스 엔티티 (사용자, 상품, 주문 등)
└── shared/       # 공유 유틸리티, UI 컴포넌트, API 등
```

### 의존성 규칙

```
app → pages → widgets → features → entities → shared
```

- **위 레이어**는 **아래 레이어**에만 의존 가능
- **아래 레이어**는 **위 레이어**에 의존 불가
- **같은 레이어** 내에서는 **순환 의존성** 금지

## 🔍 각 레이어 상세 설명

### 1. app 레이어

애플리케이션의 전역 설정과 초기화를 담당합니다.

```typescript
// src/app/App.tsx
export const App = () => {
  return (
    <Store>
      <Theme>
        <Router />
      </Theme>
    </Store>
  );
};

// src/app/providers/router.tsx
export const Router = ({ children }: { children: React.ReactNode }) => {
  return (
    <BrowserRouter>
      {children}
      <AppRoutes />
    </BrowserRouter>
  );
};
```

### 2. pages 레이어

라우팅과 페이지 컴포넌트를 담당합니다.

```typescript
// src/pages/UserProfilePage/ui/UserProfilePage.tsx
export const UserProfilePage = () => {
  return (
    <div className="user-profile-page">
      <h1>사용자 프로필</h1>
      <UserProfile />
    </div>
  );
};
```

### 3. widgets 레이어

독립적인 UI 블록을 담당합니다.

```typescript
// src/widgets/UserProfile/ui/UserProfile.tsx
export const UserProfile = () => {
  return (
    <div className="user-profile-widget">
      <UserInfo />
      <EditProfileForm />
    </div>
  );
};
```

### 4. features 레이어

비즈니스 기능을 담당합니다.

```typescript
// src/features/EditProfile/ui/EditProfileForm.tsx
export const EditProfileForm = () => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    bio: "",
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await updateUser(formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
        placeholder="이름"
      />
      <Button type="submit">저장</Button>
    </form>
  );
};

// src/features/EditProfile/api/updateUser.ts
export const updateUser = async (userData: Partial<User>) => {
  const response = await fetch("/api/users/profile", {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(userData),
  });
  return response.json();
};
```

### 5. entities 레이어

비즈니스 엔티티를 담당합니다.

```typescript
// src/entities/User/model/types.ts
export interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  bio?: string;
  createdAt: Date;
}

// src/entities/User/ui/UserInfo.tsx
export const UserInfo = ({ user }: { user: User }) => {
  return (
    <div className="user-info">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      {user.bio && <p>{user.bio}</p>}
    </div>
  );
};
```

### 6. shared 레이어

공유 유틸리티와 UI 컴포넌트를 담당합니다.

```typescript
// src/shared/ui/Button/ui/Button.tsx
export const Button = ({
  variant = "primary",
  size = "medium",
  children,
  className,
  ...props
}: ButtonProps) => {
  return (
    <button
      className={`button button--${variant} button--${size} ${className || ""}`}
      {...props}
    >
      {children}
    </button>
  );
};

// src/shared/lib/api.ts
export const API_BASE_URL =
  process.env.REACT_APP_API_URL || "http://localhost:3000";

export const createApiUrl = (endpoint: string) => `${API_BASE_URL}${endpoint}`;
```

## 🎯 FSD의 장점

### 1. 명확한 의존성 관리

**체계적인 의존성 제어**:

- 레이어 간 의존성이 명확하여 순환 의존성 방지
- 상위 레이어는 하위 레이어에만 의존 가능
- 코드의 결합도 감소, 응집도 향상

**실제 효과**:

- 리팩토링 시 영향 범위를 명확히 예측 가능
- 새로운 기능 추가 시 기존 코드에 미치는 영향 최소화
- 코드 분석 도구로 의존성 위반을 자동 검출 가능

### 2. 확장성과 유지보수성

**점진적 확장 가능**:

- 새로운 기능 추가 시 기존 코드 영향 최소화
- 각 레이어가 독립적으로 진화 가능
- 레거시 코드와 신규 코드의 공존 용이

**팀 협업 효율성**:

- 팀별로 독립적인 개발 가능
- 기능별로 책임 영역이 명확히 구분
- 코드 리뷰 시 해당 도메인 전문가가 집중적으로 검토 가능

**실제 사례**:

- 대규모 팀에서 동시에 여러 기능 개발 가능
- 마이크로 프론트엔드 아키텍처로의 전환 용이

### 3. 재사용성 향상

**계층적 재사용 구조**:

- **shared 레이어**: 전역적으로 재사용되는 UI 컴포넌트와 유틸리티
- **entities 레이어**: 비즈니스 엔티티와 관련 로직의 재사용
- **features 레이어**: 기능 단위의 재사용 가능한 모듈

**구체적 이점**:

- 공통 UI 컴포넌트의 일관성 유지
- 비즈니스 규칙의 중복 제거
- API 클라이언트 로직의 중앙 집중화

**경제적 효과**:

- 개발 시간 단축 (기존 모듈 재활용)
- 버그 수정 시 한 곳만 수정하면 전체 반영
- 디자인 시스템과의 자연스러운 연동

### 4. 테스트 용이성

**계층별 테스트 전략**:

- 각 레이어별 독립적인 테스트 작성 가능
- 모킹과 의존성 주입이 용이
- 통합 테스트에서 특정 레이어만 격리하여 테스트

**구체적 테스트 방법**:

- **shared**: 유틸리티 함수와 UI 컴포넌트 단위 테스트
- **entities**: 비즈니스 로직과 데이터 모델 테스트
- **features**: 기능별 시나리오 테스트
- **widgets**: 복합 UI 블록 통합 테스트
- **pages**: E2E 테스트 및 사용자 시나리오 테스트

**테스트 자동화**:

- CI/CD 파이프라인에서 레이어별 병렬 테스트 실행
- 변경된 레이어에 따른 선택적 테스트 실행

## 🔧 실제 프로젝트 구조 예시

```
src/
├── app/
│   ├── providers/
│   │   ├── router/
│   │   ├── store/
│   │   └── theme/
│   ├── styles/
│   └── App.tsx
├── pages/
│   ├── HomePage/
│   ├── UserProfilePage/
│   └── ProductListPage/
├── widgets/
│   ├── Header/
│   ├── Sidebar/
│   ├── ProductGrid/
│   └── UserProfile/
├── features/
│   ├── SearchProducts/
│   ├── FilterProducts/
│   ├── AddToCart/
│   └── EditProfile/
├── entities/
│   ├── User/
│   ├── Product/
│   ├── Cart/
│   └── Order/
└── shared/
    ├── ui/
    │   ├── Button/
    │   ├── Input/
    │   └── Modal/
    ├── lib/
    │   ├── api.ts
    │   ├── utils.ts
    │   └── constants.ts
    └── api/
        ├── auth.ts
        ├── products.ts
        └── users.ts
```

## 🔧 FSD 설계 방법론

### 1. 단계별 적용 전략

**1단계: 현재 상태 분석**

- 기존 프로젝트의 구조와 의존성 파악
- 주요 기능과 도메인 식별
- 팀의 역량과 프로젝트 규모 고려

**2단계: 점진적 마이그레이션**

- shared 레이어부터 시작하여 공통 요소 정리
- entities 레이어로 비즈니스 모델 추상화
- features 레이어로 기능별 독립 모듈 구성

**3단계: 의존성 규칙 적용**

- 레이어 간 의존성 규칙 엄격히 적용
- 순환 의존성 제거 및 모니터링 체계 구축
- 코드 리뷰 프로세스에 아키텍처 검증 포함

### 2. 레이어 설계 원칙

**shared 레이어 설계**:

- 도메인에 무관한 순수 기술적 요소만 포함
- 재사용 가능성이 높은 UI 컴포넌트
- 프로젝트 전반에 걸쳐 사용되는 유틸리티

**entities 레이어 설계**:

- 비즈니스 엔티티의 순수 모델
- 도메인 특화 비즈니스 규칙
- 데이터 접근 및 변환 로직

**features 레이어 설계**:

- 사용자 스토리 중심의 기능 단위
- entities와 shared를 조합한 비즈니스 기능
- 독립적으로 개발 및 테스트 가능한 모듈

### 3. 네이밍 및 구조 가이드

**폴더 네이밍 규칙**:

- kebab-case 사용 (user-profile, shopping-cart)
- 비즈니스 용어 우선 (기술 용어 지양)
- 명확하고 직관적인 이름 사용

**파일 구조 표준화**:

```
feature-name/
├── api/          # API 호출 로직
├── model/        # 상태 관리 및 비즈니스 로직
├── ui/           # UI 컴포넌트
└── index.ts      # Public API 정의
```

## ⚠️ 주의사항

### 1. 과도한 분리

**문제점**:

- 너무 작은 단위로 분리하면 오히려 복잡성 증가
- 파일 수 급증으로 프로젝트 탐색 어려움
- 간단한 기능도 여러 레이어를 거쳐야 하는 오버엔지니어링

**해결책**:

- 프로젝트 규모에 맞는 적절한 분리 수준 유지
- 기능의 복잡도와 재사용성을 고려한 분리
- 팀의 역량과 프로젝트 일정을 고려한 점진적 적용

### 2. 레이어 간 의존성 준수

**의존성 위반의 위험**:

- 의존성 규칙을 엄격하게 준수하지 않으면 FSD의 장점 상실
- 순환 의존성 발생 시 코드 파악과 수정이 어려워짐
- 잘못된 의존성으로 인한 예상치 못한 부작용 발생

**해결 방안**:

- ESLint 플러그인 등을 활용한 자동 검증
- 순환 의존성 발생 시 아키텍처 재검토
- 정기적인 의존성 그래프 분석 및 리팩토링

### 3. 네이밍 컨벤션

**일관성의 중요성**:

- 일관된 네이밍 규칙이 없으면 팀원 간 혼란 야기
- 폴더와 파일명의 모호함으로 인한 개발 효율성 저하
- 새로운 팀원의 프로젝트 이해도 감소

**베스트 프랙티스**:

- 팀 내 네이밍 가이드라인 문서화
- 폴더와 파일명의 명확성 유지
- 도메인 전문가와 협의한 비즈니스 용어 사용
- 자동화 도구를 통한 네이밍 규칙 검증

## 🚀 FSD 적용 가이드

### 1. 단계별 적용

1. **shared 레이어**부터 시작하여 공통 컴포넌트 정리
2. **entities 레이어**로 비즈니스 모델 정의
3. **features 레이어**로 기능별 로직 구현
4. **widgets 레이어**로 UI 블록 구성
5. **pages 레이어**로 페이지 컴포넌트 완성

### 2. 마이그레이션 전략

- 기존 코드를 점진적으로 FSD 구조로 리팩토링
- 레이어별로 단계적 적용
- 팀원들과의 협의를 통한 일관성 유지

## 📚 결론

FSD는 대규모 React 애플리케이션의 구조를 체계적으로 관리할 수 있는 강력한 아키텍처 패턴입니다.

적절히 적용하면:

- **코드의 가독성과 유지보수성** 향상
- **팀 협업의 효율성** 증대
- **기능 확장의 용이성** 확보
- **테스트와 디버깅의 편의성** 증대

프로젝트의 규모와 팀의 역량을 고려하여 FSD를 적용하여 효율적인 애플리케이션 아키텍처를 구축하세요.
