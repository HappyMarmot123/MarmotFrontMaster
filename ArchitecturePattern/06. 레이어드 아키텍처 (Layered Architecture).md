# 레이어드 아키텍처 (Layered Architecture)

## 📖 개요

**레이어드 아키텍처(Layered Architecture)**는 Presentation(Web), Business Logic(Service), Data Access(Repository) 계층으로 나누는 방식입니다. 상위 계층은 하위 계층에만 의존하며, 각 계층의 역할이 명확하여 유지보수가 쉽습니다. Java의 스프링 프레임워크나 Node.js의 Express에서 흔히 사용됩니다.

## 🏗️ 레이어드 아키텍처의 등장 배경

### 1. 모놀리식 애플리케이션의 문제점

**전통적인 개발 방식의 한계**:

- **스파게티 코드**: 모든 로직이 한 곳에 뒤섞여 있는 구조
- **단일 파일 거대화**: 하나의 파일에 수천 줄의 코드가 몰림
- **의존성 혼재**: 데이터베이스 코드와 UI 코드가 직접 연결
- **재사용 불가**: 특정 기능을 다른 곳에서 사용하기 어려움

**실제 문제 상황**:

```php
// 문제가 있는 전통적인 PHP 코드
<?php
// index.php - 모든 로직이 한 파일에
if ($_POST['action'] == 'create_user') {
    // 1. 입력 검증 (표현 계층)
    if (empty($_POST['name'])) die('이름 필수');

    // 2. 비즈니스 로직 (비즈니스 계층)
    $password = password_hash($_POST['password'], PASSWORD_DEFAULT);

    // 3. 데이터베이스 접근 (데이터 계층)
    $conn = new PDO('mysql:host=localhost;dbname=app', $user, $pass);
    $stmt = $conn->prepare('INSERT INTO users...');
    $stmt->execute([$_POST['name'], $password]);

    // 4. HTML 출력 (표현 계층)
    echo '<h1>사용자 생성 완료</h1>';
}
?>
```

### 2. 계층화의 필요성

**소프트웨어 공학 원칙의 대두**:

- **관심사 분리(Separation of Concerns)**: 각기 다른 책임을 별도 모듈로 분리
- **단일 책임 원칙(Single Responsibility)**: 하나의 클래스는 하나의 이유로만 변경
- **의존성 역전 원칙(Dependency Inversion)**: 추상화에 의존, 구체 구현에 의존 금지
- **개방-폐쇄 원칙(Open-Closed)**: 확장에는 열려있고 수정에는 닫혀있음

### 3. 엔터프라이즈 애플리케이션의 발전

**복잡한 비즈니스 요구사항**:

- 다양한 사용자 인터페이스 지원 (웹, 모바일, API)
- 복잡한 비즈니스 규칙과 워크플로우
- 다중 데이터 소스와 외부 시스템 연동
- 보안, 트랜잭션, 캐싱 등 횡단 관심사

**Martin Fowler의 "Patterns of Enterprise Application Architecture" (2002)**:

- 레이어드 아키텍처의 체계적 정리
- Service Layer, Repository Pattern 등 구체적 패턴 제시
- 엔터프라이즈 애플리케이션 개발의 표준 수립

### 4. 현대적 적용 사례

**대규모 시스템에서의 성공**:

- **Spring Boot**: Java 생태계의 레이어드 아키텍처 표준
- **Django**: Python의 MVT 패턴을 통한 레이어 분리
- **Ruby on Rails**: Convention over Configuration으로 레이어 구조 자동화
- **ASP.NET Core**: 의존성 주입을 통한 현대적 레이어드 아키텍처

## 🏗️ 레이어드 아키텍처 구조

### 계층 구조 (위에서 아래로)

```
┌─────────────────────────────────────┐
│           Presentation Layer        │ ← 사용자 인터페이스
│         (Controller, Routes)        │
├─────────────────────────────────────┤
│           Business Logic Layer      │ ← 비즈니스 로직
│           (Service, Use Cases)      │
├─────────────────────────────────────┤
│           Data Access Layer         │ ← 데이터 접근
│         (Repository, DAO)           │
├─────────────────────────────────────┤
│           Data Source Layer         │ ← 데이터베이스, 외부 API
│         (Database, External API)    │
└─────────────────────────────────────┘
```

### 의존성 규칙

```
Presentation → Business Logic → Data Access → Data Source
```

- **상위 계층**은 **하위 계층**에만 의존 가능
- **하위 계층**은 **상위 계층**에 의존 불가
- **같은 계층** 내에서는 **순환 의존성** 금지

## 🔍 Node.js/Express에서의 레이어드 아키텍처 구현

### 1. Presentation Layer (표현 계층)

```typescript
// src/controllers/UserController.ts
export class UserController {
  constructor(private userService: UserService) {}

  async getUsers(req: Request, res: Response): Promise<void> {
    try {
      const { page = 1, limit = 10 } = req.query;
      const result = await this.userService.getUsers({
        page: Number(page),
        limit: Number(limit),
      });

      res.json(
        ApiResponse.success("사용자 목록을 성공적으로 조회했습니다.", result)
      );
    } catch (error) {
      res
        .status(500)
        .json(ApiResponse.error("사용자 목록 조회 중 오류가 발생했습니다."));
    }
  }

  async createUser(req: Request, res: Response): Promise<void> {
    try {
      const userData: CreateUserDto = req.body;
      const newUser = await this.userService.createUser(userData);

      res
        .status(201)
        .json(
          ApiResponse.success("사용자가 성공적으로 생성되었습니다.", newUser)
        );
    } catch (error) {
      res
        .status(500)
        .json(ApiResponse.error("사용자 생성 중 오류가 발생했습니다."));
    }
  }
}

// src/routes/userRoutes.ts
const router = Router();

const userRepository = new UserRepository();
const userService = new UserService(userRepository);
const userController = new UserController(userService);

router.get("/", userController.getUsers.bind(userController));
router.post("/", userController.createUser.bind(userController));

export default router;
```

### 2. Business Logic Layer (비즈니스 로직 계층)

```typescript
// src/services/UserService.ts
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService,
    private logger: Logger
  ) {}

  async getUsers(options: UserQueryOptions): Promise<PaginationResult> {
    try {
      const { page, limit } = options;
      const offset = (page - 1) * limit;

      const users = await this.userRepository.findAll(limit, offset);
      const totalUsers = await this.userRepository.count();

      return {
        users,
        pagination: {
          currentPage: page,
          totalPages: Math.ceil(totalUsers / limit),
          totalUsers,
          hasNext: page < Math.ceil(totalUsers / limit),
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      this.logger.error("사용자 목록 조회 실패", { error, options });
      throw error;
    }
  }

  async createUser(userData: CreateUserDto): Promise<User> {
    try {
      // 입력 데이터 검증
      const validationResult = UserValidator.validateCreate(userData);
      if (!validationResult.isValid) {
        throw new Error(`validation: ${validationResult.errors.join(", ")}`);
      }

      // 이메일 중복 확인
      const existingUser = await this.userRepository.findByEmail(
        userData.email
      );
      if (existingUser) {
        throw new Error("duplicate: 이메일이 이미 존재합니다.");
      }

      // 비밀번호 해싱
      const hashedPassword = await PasswordHasher.hash(userData.password);

      // 사용자 생성
      const newUser = await this.userRepository.create({
        ...userData,
        password: hashedPassword,
      });

      return newUser;
    } catch (error) {
      this.logger.error("사용자 생성 실패", { error, email: userData.email });
      throw error;
    }
  }
}
```

### 3. Data Access Layer (데이터 접근 계층)

```typescript
// src/repositories/UserRepository.ts
export class UserRepository {
  private db: Pool;
  private logger: Logger;

  constructor() {
    this.db = DatabaseConnection.getPool();
    this.logger = new Logger("UserRepository");
  }

  async findAll(limit: number = 10, offset: number = 0): Promise<User[]> {
    try {
      const query = `
        SELECT id, name, email, role, created_at, updated_at
        FROM users
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
      `;

      const result = await this.db.query(query, [limit, offset]);
      return result.rows.map(this.mapRowToUser);
    } catch (error) {
      this.logger.error("사용자 목록 조회 실패", { error, limit, offset });
      throw error;
    }
  }

  async findById(id: string): Promise<User | null> {
    try {
      const query = `
        SELECT id, name, email, password, role, created_at, updated_at
        FROM users
        WHERE id = $1
      `;

      const result = await this.db.query(query, [id]);
      return result.rows.length > 0 ? this.mapRowToUser(result.rows[0]) : null;
    } catch (error) {
      this.logger.error("사용자 조회 실패", { error, userId: id });
      throw error;
    }
  }

  async create(userData: CreateUserDto): Promise<User> {
    try {
      const query = `
        INSERT INTO users (name, email, password, role, created_at, updated_at)
        VALUES ($1, $2, $3, $4, NOW(), NOW())
        RETURNING id, name, email, password, role, created_at, updated_at
      `;

      const values = [
        userData.name,
        userData.email,
        userData.password,
        userData.role,
      ];
      const result = await this.db.query(query, values);
      return this.mapRowToUser(result.rows[0]);
    } catch (error) {
      this.logger.error("사용자 생성 실패", { error, email: userData.email });
      throw error;
    }
  }

  private mapRowToUser(row: any): User {
    return {
      id: row.id,
      name: row.name,
      email: row.email,
      password: row.password || "",
      role: row.role,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }
}
```

### 4. Entity Layer (엔티티 계층)

```typescript
// src/entities/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
  password: string;
  role: "user" | "admin";
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserDto {
  name: string;
  email: string;
  password: string;
  role: "user" | "admin";
}

export interface UpdateUserDto {
  name?: string;
  email?: string;
  password?: string;
  role?: "user" | "admin";
}
```

## 🎯 레이어드 아키텍처의 장점

### 1. 관심사 분리

- 각 계층이 명확한 책임을 가짐
- 코드의 가독성과 이해도 향상

### 2. 유지보수성

- 각 계층을 독립적으로 수정 가능
- 변경 사항의 영향 범위 최소화

### 3. 테스트 용이성

**계층별 테스트 전략**:

- **Presentation Layer 테스트**: HTTP 요청/응답 및 API 계약 검증

  - API 엔드포인트 통합 테스트
  - 인증/권한 부여 시나리오 테스트
  - 입력 검증과 에러 처리 테스트

- **Business Logic Layer 테스트**: 핵심 비즈니스 규칙 검증

  - 순수 비즈니스 로직 단위 테스트
  - 복잡한 워크플로우 시나리오 테스트
  - 외부 의존성을 Mock으로 격리한 테스트

- **Data Access Layer 테스트**: 데이터 영속성 및 쿼리 검증
  - Repository 패턴을 통한 데이터 접근 테스트
  - 인메모리 데이터베이스를 활용한 통합 테스트
  - 성능 및 동시성 테스트

**테스트 피라미드 구현**:

```typescript
// Service Layer 단위 테스트
describe("UserService", () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = {
      findById: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    } as any;
    userService = new UserService(mockUserRepository);
  });

  it("사용자 생성 시 이메일 중복 검증", async () => {
    mockUserRepository.findByEmail.mockResolvedValue(existingUser);

    await expect(
      userService.createUser({ email: "test@test.com", name: "홍길동" })
    ).rejects.toThrow("이메일이 이미 존재합니다");
  });
});
```

### 4. 확장성

- 새로운 기능 추가 시 기존 코드 영향 최소화
- 새로운 기술 스택 도입 시 해당 계층만 수정

## ⚠️ 주의사항

### 1. 계층 간 결합도

- 계층 간 의존성을 최소화
- 인터페이스를 통한 느슨한 결합 유지

### 2. 성능 고려

- 불필요한 계층 통과 방지
- 적절한 캐싱 전략 수립

### 3. 과도한 분리

- 너무 많은 계층으로 나누면 오히려 복잡성 증가
- 프로젝트 규모에 맞는 적절한 분리 수준 유지

## 🚀 고급 패턴

### 1. Repository Pattern

```typescript
// 데이터 접근 계층을 추상화
export interface IUserRepository {
  findAll(limit?: number, offset?: number): Promise<User[]>;
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  create(user: CreateUserDto): Promise<User>;
  update(id: string, user: UpdateUserDto): Promise<User | null>;
  delete(id: string): Promise<boolean>;
}
```

### 2. Dependency Injection

```typescript
// 의존성 주입을 통한 결합도 감소
export class UserService {
  constructor(
    private userRepository: IUserRepository,
    private emailService: IEmailService,
    private logger: ILogger
  ) {}
}
```

## 📚 결론

레이어드 아키텍처는 체계적이고 확장 가능한 애플리케이션 구조를 구축할 수 있는 강력한 패턴입니다.

적절히 적용하면:

- **명확한 관심사 분리**로 코드의 가독성 향상
- **높은 유지보수성**으로 장기적인 프로젝트 관리 용이
- **테스트 용이성**으로 코드 품질 향상
- **확장성**으로 새로운 기능 추가 용이

프로젝트의 규모와 복잡성을 고려하여 레이어드 아키텍처를 적용하여 효율적인 애플리케이션 아키텍처를 구축하세요.
