# MVVM (Model-View-ViewModel)

## 📖 개요

**MVVM(Model-View-ViewModel)**은 React와 Vue에서 주로 사용되는 아키텍처 패턴으로, **뷰(View)**와 **모델(Model)**을 분리하고, **뷰모델(ViewModel)**이 둘 사이의 연결고리 역할을 합니다. 뷰모델은 뷰의 상태를 관리하고, 데이터를 바인딩하여 뷰가 모델의 변경 사항을 자동으로 반영하도록 합니다.

## 🏗️ MVVM의 등장 배경

### 1. 기존 MVC 패턴의 한계

**전통적인 MVC의 문제점**:

- **뷰와 컨트롤러의 강한 결합**: UI 로직과 비즈니스 로직이 섞여 있음
- **테스트의 어려움**: UI에 의존적인 컨트롤러 테스트가 복잡
- **재사용성 부족**: 뷰와 컨트롤러가 밀접하게 연결되어 재사용 어려움
- **대화형 UI 처리의 복잡성**: 복잡한 사용자 인터랙션 처리 시 코드 복잡도 증가

### 2. 데이터 바인딩의 필요성

**현대적 웹 애플리케이션의 요구사항**:

- **반응형 UI**: 데이터 변경에 따른 자동 UI 업데이트
- **양방향 바인딩**: 사용자 입력이 데이터에 즉시 반영
- **상태 동기화**: 여러 UI 컴포넌트 간 일관된 상태 유지
- **선언적 프로그래밍**: 명령형보다 선언적 방식의 UI 개발

### 3. MVVM의 등장과 진화

**마이크로소프트의 WPF/Silverlight**: 2005년 John Gossman이 처음 제안한 패턴으로, 데스크톱 애플리케이션에서 시작

**웹 프론트엔드로의 확산**:

- **AngularJS (2010)**: 웹에서 MVVM 패턴의 첫 번째 대중화
- **Knockout.js (2010)**: 순수 JavaScript MVVM 라이브러리
- **Vue.js (2014)**: 선언적 렌더링과 반응형 데이터 바인딩
- **React (2013)**: 단방향 데이터 플로우를 통한 MVVM 스타일 구현

### 4. 현재의 중요성

**SPA(Single Page Application) 시대의 핵심**:

- 복잡한 상태 관리의 필요성 증대
- 컴포넌트 기반 아키텍처의 표준화
- 개발자 경험(DX) 향상의 중요성
- 팀 협업과 코드 유지보수성의 중요성

## 🏗️ MVVM 아키텍처 구조

### 핵심 구성 요소

```
┌─────────────┐    ┌─────────────────┐    ┌─────────────┐
│    View     │◄──►│   ViewModel     │◄──►│    Model    │
│  (UI)      │    │  (상태 관리)     │    │  (데이터)   │
└─────────────┘    └─────────────────┘    └─────────────┘
```

### 1. Model (모델)

- **데이터 구조**: 비즈니스 로직과 데이터를 담당
- **API 통신**: 서버와의 데이터 교환
- **비즈니스 규칙**: 도메인 로직과 유효성 검사

### 2. View (뷰)

- **UI 표현**: 사용자에게 보여지는 인터페이스
- **사용자 입력**: 사용자의 액션을 ViewModel에 전달
- **데이터 바인딩**: ViewModel의 상태 변화를 자동으로 반영

### 3. ViewModel (뷰모델)

- **상태 관리**: 뷰의 상태와 데이터를 관리
- **비즈니스 로직**: 뷰와 모델 간의 중재자 역할
- **데이터 변환**: 모델의 데이터를 뷰에 맞게 가공

## 🔍 React에서의 MVVM 구현

### 1. Model Layer

```typescript
// src/models/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: "user" | "admin";
}

// src/models/UserRepository.ts
export class UserRepository {
  private apiUrl = "/api/users";

  async getUsers(): Promise<User[]> {
    const response = await fetch(this.apiUrl);
    if (!response.ok) {
      throw new Error("사용자 목록을 가져올 수 없습니다.");
    }
    return response.json();
  }

  async createUser(userData: Omit<User, "id">): Promise<User> {
    const response = await fetch(this.apiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });
    if (!response.ok) {
      throw new Error("사용자 생성에 실패했습니다.");
    }
    return response.json();
  }
}
```

### 2. ViewModel Layer

```typescript
// src/viewmodels/UserViewModel.ts
export class UserViewModel {
  private userRepository: UserRepository;

  constructor() {
    this.userRepository = new UserRepository();
  }

  useUsers() {
    const [users, setUsers] = useState<User[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const fetchUsers = useCallback(async () => {
      try {
        setLoading(true);
        const userList = await this.userRepository.getUsers();
        setUsers(userList);
      } catch (err) {
        setError(
          err instanceof Error ? err.message : "알 수 없는 오류가 발생했습니다."
        );
      } finally {
        setLoading(false);
      }
    }, []);

    const createUser = useCallback(async (userData: Omit<User, "id">) => {
      try {
        setLoading(true);
        const newUser = await this.userRepository.createUser(userData);
        setUsers((prev) => [...prev, newUser]);
        return newUser;
      } catch (err) {
        setError(
          err instanceof Error ? err.message : "사용자 생성에 실패했습니다."
        );
        throw err;
      } finally {
        setLoading(false);
      }
    }, []);

    return {
      users,
      loading,
      error,
      fetchUsers,
      createUser,
    };
  }
}
```

### 3. View Layer

```typescript
// src/views/UserList.tsx
export const UserList = () => {
  const { users, loading, error, fetchUsers, createUser } =
    useUserViewModel().useUsers();

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  const handleCreateUser = async (userData: any) => {
    try {
      await createUser(userData);
    } catch (err) {
      // 에러 처리
    }
  };

  if (loading) return <div className="loading">로딩 중...</div>;
  if (error) return <div className="error">오류: {error}</div>;

  return (
    <div className="user-list">
      <h1>사용자 목록</h1>
      <UserForm onSubmit={handleCreateUser} />
      <div className="user-grid">
        {users.map((user) => (
          <UserCard
            key={user.id}
            user={user}
            onDelete={() => handleDeleteUser(user.id)}
          />
        ))}
      </div>
    </div>
  );
};
```

## 🎯 Vue에서의 MVVM 구현

### 1. Model Layer

```typescript
// src/models/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: "user" | "admin";
}

// src/models/UserRepository.ts
export class UserRepository {
  private apiUrl = "/api/users";

  async getUsers(): Promise<User[]> {
    const response = await fetch(this.apiUrl);
    if (!response.ok) {
      throw new Error("사용자 목록을 가져올 수 없습니다.");
    }
    return response.json();
  }
}
```

### 2. ViewModel Layer (Composition API)

```vue
<!-- src/viewmodels/useUsers.ts -->
<script setup lang="ts">
import { ref, computed, onMounted } from "vue";
import { User, UserRepository } from "../models/UserRepository";

const userRepository = new UserRepository();

// 반응형 상태
const users = ref<User[]>([]);
const loading = ref(false);
const error = ref<string | null>(null);
const searchQuery = ref("");

// 계산된 속성
const filteredUsers = computed(() => {
  if (!searchQuery.value) return users.value;
  return users.value.filter(
    (user) =>
      user.name.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
      user.email.toLowerCase().includes(searchQuery.value.toLowerCase())
  );
});

// 메서드
const fetchUsers = async () => {
  try {
    loading.value = true;
    error.value = null;
    users.value = await userRepository.getUsers();
  } catch (err) {
    error.value =
      err instanceof Error ? err.message : "알 수 없는 오류가 발생했습니다.";
  } finally {
    loading.value = false;
  }
};

// 초기 데이터 로드
onMounted(() => {
  fetchUsers();
});
</script>
```

### 3. View Layer

```vue
<!-- src/views/UserList.vue -->
<template>
  <div class="user-list">
    <h1>사용자 목록</h1>

    <!-- 검색 -->
    <div class="search-section">
      <input
        v-model="searchQuery"
        type="text"
        placeholder="사용자 검색..."
        class="search-input"
      />
    </div>

    <!-- 사용자 생성 폼 -->
    <UserForm @submit="handleCreateUser" />

    <!-- 로딩 상태 -->
    <div v-if="loading" class="loading">로딩 중...</div>

    <!-- 에러 상태 -->
    <div v-else-if="error" class="error">오류: {{ error }}</div>

    <!-- 사용자 목록 -->
    <div v-else class="user-grid">
      <UserCard
        v-for="user in filteredUsers"
        :key="user.id"
        :user="user"
        @delete="handleDeleteUser(user.id)"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { UserCard, UserForm } from "../components";
import { useUsers } from "../viewmodels/useUsers";

const { loading, error, searchQuery, filteredUsers, createUser, deleteUser } =
  useUsers();

const handleCreateUser = async (userData: any) => {
  try {
    await createUser(userData);
  } catch (err) {
    // 에러 처리
  }
};
</script>
```

## 🎯 MVVM의 장점

### 1. 관심사 분리

**명확한 책임 분할**:

- **Model**: 데이터와 비즈니스 로직

  - 순수한 데이터 구조와 비즈니스 규칙
  - API 통신과 데이터 검증 로직
  - 도메인 특화 로직과 엔티티

- **View**: UI 표현

  - 사용자 인터페이스 렌더링
  - 시각적 요소와 레이아웃
  - 사용자 입력 이벤트 처리

- **ViewModel**: 상태 관리와 데이터 바인딩
  - 뷰의 상태와 로직 관리
  - 모델과 뷰 간의 데이터 변환
  - 사용자 인터랙션에 대한 응답

**분리의 실제 효과**:

- 각 계층의 독립적인 개발과 테스트 가능
- 변경사항의 영향 범위 최소화
- 코드의 가독성과 유지보수성 향상

### 2. 테스트 용이성

**계층별 독립적 테스트**:

- **ViewModel 테스트**: UI 없이 로직만 테스트 가능
- **Model 테스트**: 순수 비즈니스 로직과 데이터 검증 테스트
- **View 테스트**: 렌더링과 사용자 인터랙션 테스트

**테스트 전략**:

```typescript
// ViewModel 단위 테스트 예시
describe("UserViewModel", () => {
  it("사용자 생성 시 검증 오류 처리", async () => {
    const mockRepository = {
      createUser: jest.fn().mockRejectedValue(new Error("이메일 중복")),
    };

    const viewModel = new UserViewModel(mockRepository);

    await viewModel.createUser({ name: "", email: "test@test.com" });

    expect(viewModel.error).toBe("이메일 중복");
    expect(viewModel.loading).toBe(false);
  });
});
```

**테스트의 이점**:

- Mock 데이터를 사용한 예측 가능한 테스트
- UI 의존성 없는 빠른 단위 테스트
- 비즈니스 로직의 철저한 검증 가능

### 3. 재사용성

**ViewModel의 다중 재사용**:

- 동일한 ViewModel을 웹, 모바일, 데스크톱에서 사용
- 다양한 UI 컴포넌트에서 동일한 비즈니스 로직 활용
- 플랫폼 간 일관된 비즈니스 규칙 적용

**Model의 범용적 활용**:

- 여러 ViewModel에서 동일한 Model 사용
- API 클라이언트의 재사용
- 도메인 로직의 중앙 집중화

**실제 재사용 사례**:

```typescript
// 하나의 UserViewModel을 다양한 View에서 사용
const userViewModel = new UserViewModel();

// 관리자 페이지
<AdminUserList viewModel={userViewModel} />

// 사용자 프로필 페이지
<UserProfile viewModel={userViewModel} />

// 모바일 앱
<MobileUserList viewModel={userViewModel} />
```

### 4. 유지보수성

**독립적인 계층 수정**:

- View 변경이 비즈니스 로직에 영향 없음
- Model 변경이 UI에 직접적 영향 없음
- ViewModel이 변경사항을 흡수하여 다른 계층 보호

**변경 영향 범위 최소화**:

- 디자인 변경 시 View만 수정
- 비즈니스 규칙 변경 시 Model과 ViewModel만 수정
- API 변경 시 Repository와 Model만 수정

**장기적 유지보수 이점**:

- 레거시 코드의 점진적 리팩토링 가능
- 새로운 기능 추가 시 기존 구조 활용
- 팀원 변경 시에도 일관된 코드 구조 유지

## 🔧 MVVM 설계 방법론

### 1. 계층별 설계 원칙

**Model 설계 원칙**:

- 순수한 데이터 구조와 비즈니스 로직만 포함
- UI나 프레젠테이션 로직에 의존하지 않음
- 검증 가능하고 테스트 가능한 단위로 구성
- 도메인 주도 설계(DDD) 원칙 적용

**ViewModel 설계 원칙**:

- 하나의 View 또는 관련된 View 그룹만 담당
- Model의 데이터를 View에 맞게 변환
- 사용자 인터랙션에 대한 응답 로직 포함
- 상태 변화에 대한 알림 메커니즘 제공

**View 설계 원칙**:

- 순수한 UI 렌더링과 사용자 입력 처리만 담당
- ViewModel과의 바인딩을 통한 데이터 표시
- 비즈니스 로직을 포함하지 않음
- 재사용 가능한 컴포넌트로 구성

### 2. 데이터 바인딩 전략

**단방향 바인딩**:

- ViewModel → View로의 데이터 흐름
- 상태 변화의 예측 가능성 확보
- React의 props를 통한 데이터 전달

**양방향 바인딩**:

- View ↔ ViewModel 간 자동 동기화
- 폼 입력과 상태의 실시간 동기화
- Vue.js의 v-model 디렉티브 활용

**이벤트 기반 통신**:

- View에서 ViewModel로의 액션 전달
- 콜백 함수와 이벤트 핸들러 활용
- 느슨한 결합을 통한 유연성 확보

### 3. 상태 관리 패턴

**지역 상태 관리**:

- 컴포넌트 내부 상태 관리
- useState, useReducer 활용
- 단순한 UI 상태 처리

**전역 상태 관리**:

- 애플리케이션 전체 상태 관리
- Redux, Zustand, Pinia 등 활용
- 복잡한 상태 동기화 처리

**하이브리드 접근법**:

- 지역과 전역 상태의 적절한 조합
- 상태의 범위와 생명주기 고려
- 성능과 복잡성의 균형점 찾기

## ⚠️ 주의사항

### 1. 과도한 복잡성

**문제점**:

- ViewModel이 너무 복잡해지면 오히려 유지보수성 저하
- 모든 상황에 MVVM을 적용하려는 과도한 추상화
- 간단한 UI에도 복잡한 구조를 강요하는 경우

**해결책**:

- 적절한 크기와 책임 분리 유지
- 프로젝트 규모와 복잡성에 맞는 적용
- 단순한 기능은 단순하게 구현

### 2. 성능 고려

**성능 이슈의 원인**:

- 과도한 데이터 바인딩으로 인한 불필요한 리렌더링
- 복잡한 ViewModel 로직으로 인한 계산 비용 증가
- 메모리 누수와 이벤트 리스너 정리 미흡

**최적화 전략**:

- React.memo(), useMemo(), useCallback() 활용
- 메모이제이션과 최적화 기법 적용
- 가상화(virtualization)를 통한 대용량 데이터 처리
- 적절한 상태 분할과 지연 로딩 적용

**성능 모니터링**:

- React DevTools Profiler 활용
- 메모리 사용량과 가비지 컬렉션 모니터링
- 사용자 경험 지표(UX metrics) 추적

### 3. 상태 관리 복잡성

**복잡성의 원인**:

- 여러 ViewModel 간 상태 동기화 문제
- 대규모 애플리케이션에서의 상태 전파 복잡성
- 상태 변화의 추적과 디버깅 어려움

**해결 방안**:

- 적절한 전역 상태 관리 라이브러리 도입
- Redux, Zustand, Pinia 등의 전문 도구 활용
- 상태의 정규화(normalization)와 구조화
- 상태 변화 로깅과 디버깅 도구 활용

**아키텍처 가이드라인**:

- 상태의 소유권과 책임 범위 명확화
- 이벤트 기반 아키텍처 고려
- 마이크로 프론트엔드에서의 상태 분리 전략

## 🚀 고급 패턴

### 1. 커스텀 훅 활용

```typescript
// src/hooks/useViewModel.ts
export function useViewModel<T>(initialState: T) {
  const [state, setState] = useState<T>(initialState);
  const stateRef = useRef<T>(state);

  const updateState = useCallback((updater: T | ((prev: T) => T)) => {
    setState(updater);
    if (typeof updater === "function") {
      stateRef.current = (updater as (prev: T) => T)(stateRef.current);
    } else {
      stateRef.current = updater;
    }
  }, []);

  return [state, updateState, stateRef.current] as const;
}
```

### 2. 의존성 주입

```typescript
// src/viewmodels/BaseViewModel.ts
export abstract class BaseViewModel<T> {
  protected repository: T;

  constructor(repository: T) {
    this.repository = repository;
  }

  abstract getState(): any;
  abstract setState(state: any): void;
}
```

## 📚 결론

MVVM은 현대적인 프론트엔드 개발에서 강력한 아키텍처 패턴입니다.

적절히 적용하면:

- **명확한 관심사 분리**로 코드의 가독성 향상
- **높은 테스트 용이성**으로 코드 품질 향상
- **재사용 가능한 컴포넌트**로 개발 효율성 증대
- **유지보수성 향상**으로 장기적인 프로젝트 관리 용이

프로젝트의 규모와 복잡성을 고려하여 MVVM을 적용하여 효율적인 프론트엔드 아키텍처를 구축하세요.
