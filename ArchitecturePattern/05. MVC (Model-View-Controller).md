# MVC (Model-View-Controller)

## 📖 개요

**MVC(Model-View-Controller)**는 전통적인 웹 개발에서 많이 사용되는 패턴으로, 데이터를 관리하는 모델, 사용자 인터페이스를 담당하는 뷰, 사용자의 입력을 처리하는 컨트롤러로 역할을 나눕니다.

## 🏗️ MVC의 등장 배경

### 1. 초기 소프트웨어 개발의 문제점

**모놀리식 코드 구조의 한계**:

- **코드 뒤섞임**: UI 로직, 비즈니스 로직, 데이터 처리가 한 곳에 집중
- **유지보수 어려움**: 작은 변경에도 전체 시스템에 영향
- **테스트 복잡성**: 각 기능을 독립적으로 테스트하기 어려움
- **협업 비효율**: 여러 개발자가 동시에 작업하기 어려운 구조

### 2. MVC의 탄생과 진화

**Xerox PARC의 Smalltalk-80 (1970년대)**:

- Trygve Reenskaug가 최초로 제안한 아키텍처 패턴
- GUI 애플리케이션의 구조적 문제 해결을 위해 고안
- 사용자 인터페이스와 비즈니스 로직의 분리 개념 도입

**웹 개발로의 확산**:

- **1990년대 후반**: 웹 애플리케이션이 복잡해지면서 MVC 필요성 대두
- **Ruby on Rails (2004)**: "Convention over Configuration"으로 MVC 대중화
- **Spring Framework (2003)**: Java 진영에서 MVC 패턴 표준화
- **ASP.NET MVC (2009)**: Microsoft의 웹 개발 MVC 프레임워크
- **Express.js (2010)**: Node.js 생태계에서 MVC 패턴 구현

### 3. 현대적 관점에서의 MVC

**RESTful API 시대의 MVC**:

- 백엔드 API 서버의 표준 아키텍처
- 마이크로서비스 아키텍처의 기본 구조
- 프론트엔드와 백엔드 분리를 통한 역할 명확화

**프레임워크별 MVC 해석**:

- **Django**: MVT(Model-View-Template) 패턴 채택
- **Laravel**: Eloquent ORM을 통한 현대적 MVC 구현
- **Next.js**: API Routes를 통한 풀스택 MVC 패턴

## 🏗️ MVC 아키텍처 구조

### 핵심 구성 요소

```
┌─────────────┐    ┌─────────────────┐    ┌─────────────┐
│    View     │◄──►│   Controller    │◄──►│    Model    │
│  (UI)      │    │  (로직 처리)     │    │  (데이터)   │
└─────────────┘    └─────────────────┘    └─────────────┘
```

### 1. Model (모델)

- **데이터 구조**: 비즈니스 로직과 데이터를 담당
- **데이터베이스**: 데이터의 CRUD 작업 처리
- **비즈니스 규칙**: 도메인 로직과 유효성 검사
- **상태 관리**: 애플리케이션의 상태 정보 관리

### 2. View (뷰)

- **UI 표현**: 사용자에게 보여지는 인터페이스
- **데이터 표시**: 모델의 데이터를 사용자에게 표시
- **사용자 입력**: 사용자의 액션을 컨트롤러에 전달
- **템플릿**: 데이터를 렌더링하는 템플릿 파일

### 3. Controller (컨트롤러)

- **요청 처리**: 사용자의 입력과 요청을 처리
- **로직 제어**: 비즈니스 로직의 흐름을 제어
- **모델 조작**: 모델의 데이터를 조작하고 업데이트
- **뷰 선택**: 적절한 뷰를 선택하여 응답

## 🔍 Node.js/Express에서의 MVC 구현

### 1. Model Layer

```typescript
// src/models/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: "user" | "admin";
}

// src/models/UserModel.ts
export class UserModel {
  private db: Pool;

  constructor(db: Pool) {
    this.db = db;
  }

  async findAll(): Promise<User[]> {
    const query = "SELECT id, name, email, role FROM users";
    const result = await this.db.query(query);
    return result.rows.map(this.mapRowToUser);
  }

  async findById(id: string): Promise<User | null> {
    const query = "SELECT id, name, email, role FROM users WHERE id = $1";
    const result = await this.db.query(query, [id]);
    return result.rows.length > 0 ? this.mapRowToUser(result.rows[0]) : null;
  }

  async create(userData: Omit<User, "id">): Promise<User> {
    const query = `
      INSERT INTO users (name, email, role)
      VALUES ($1, $2, $3)
      RETURNING id, name, email, role
    `;
    const values = [userData.name, userData.email, userData.role];
    const result = await this.db.query(query, values);
    return this.mapRowToUser(result.rows[0]);
  }

  private mapRowToUser(row: any): User {
    return {
      id: row.id,
      name: row.name,
      email: row.email,
      role: row.role,
    };
  }
}
```

### 2. Controller Layer

```typescript
// src/controllers/UserController.ts
export class UserController {
  private userService: UserService;

  constructor(userService: UserService) {
    this.userService = userService;
  }

  async getUsers(req: Request, res: Response): Promise<void> {
    try {
      const { page = 1, limit = 10 } = req.query;
      const result = await this.userService.getUsers({
        page: Number(page),
        limit: Number(limit),
      });

      res.json({
        success: true,
        data: result.users,
        pagination: result.pagination,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "사용자 목록을 가져오는 중 오류가 발생했습니다.",
      });
    }
  }

  async createUser(req: Request, res: Response): Promise<void> {
    try {
      const userData = req.body;
      const newUser = await this.userService.createUser(userData);

      res.status(201).json({
        success: true,
        message: "사용자가 성공적으로 생성되었습니다.",
        data: newUser,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "사용자 생성 중 오류가 발생했습니다.",
      });
    }
  }
}
```

### 3. Service Layer (비즈니스 로직)

```typescript
// src/services/UserService.ts
export class UserService {
  private userModel: UserModel;

  constructor(userModel: UserModel) {
    this.userModel = userModel;
  }

  async getUsers(options: UserQueryOptions): Promise<PaginationResult> {
    const { page, limit } = options;
    const offset = (page - 1) * limit;

    const users = await this.userModel.findAll();
    const totalUsers = users.length;
    const paginatedUsers = users.slice(offset, offset + limit);

    return {
      users: paginatedUsers,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(totalUsers / limit),
        totalUsers,
        hasNext: page < Math.ceil(totalUsers / limit),
        hasPrev: page > 1,
      },
    };
  }

  async createUser(userData: Omit<User, "id">): Promise<User> {
    return this.userModel.create(userData);
  }
}
```

### 4. View Layer (템플릿)

```html
<!-- src/views/users/index.ejs -->
<!DOCTYPE html>
<html lang="ko">
  <head>
    <title>사용자 목록</title>
  </head>
  <body>
    <div class="container">
      <h1>사용자 관리</h1>

      <table class="user-table">
        <thead>
          <tr>
            <th>ID</th>
            <th>이름</th>
            <th>이메일</th>
            <th>역할</th>
            <th>작업</th>
          </tr>
        </thead>
        <tbody>
          <% users.forEach(user => { %>
          <tr>
            <td><%= user.id %></td>
            <td><%= user.name %></td>
            <td><%= user.email %></td>
            <td><%= user.role %></td>
            <td>
              <button onclick="editUser('<%= user.id %>')">수정</button>
              <button onclick="deleteUser('<%= user.id %>')">삭제</button>
            </td>
          </tr>
          <% }); %>
        </tbody>
      </table>
    </div>
  </body>
</html>
```

### 5. Routes (라우팅)

```typescript
// src/routes/userRoutes.ts
const router = Router();

const userModel = new UserModel(/* database connection */);
const userService = new UserService(userModel);
const userController = new UserController(userService);

router.get("/", userController.getUsers.bind(userController));
router.post("/", userController.createUser.bind(userController));

export default router;
```

## 🎯 MVC의 장점

### 1. 관심사 분리

- **Model**: 데이터와 비즈니스 로직
- **View**: UI 표현
- **Controller**: 요청 처리와 흐름 제어

### 2. 코드 재사용성

- Model의 비즈니스 로직을 여러 Controller에서 재사용
- View 템플릿을 여러 Controller에서 재사용

### 3. 유지보수성

- 각 계층의 독립적인 수정 가능
- 변경 사항의 영향 범위 최소화

### 4. 테스트 용이성

- 각 계층을 독립적으로 테스트 가능
- Mock 객체를 사용한 단위 테스트 작성 용이

## ⚠️ 주의사항

### 1. Controller의 복잡성

- Controller가 너무 복잡해지면 오히려 유지보수성 저하
- Service 계층을 활용하여 비즈니스 로직 분리

### 2. View와 Model의 결합

- View에서 직접 Model에 접근하지 않도록 주의
- Controller를 통한 데이터 전달 유지

### 3. 성능 고려

- 데이터베이스 쿼리 최적화
- 캐싱 전략 수립

## 🚀 고급 패턴

### 1. Repository Pattern

```typescript
// 데이터 접근 계층을 추상화
export interface IUserRepository {
  findAll(): Promise<User[]>;
  findById(id: string): Promise<User | null>;
  create(user: User): Promise<User>;
}
```

### 2. Dependency Injection

```typescript
// 의존성 주입을 통한 결합도 감소
export class UserController {
  constructor(private userService: IUserService, private logger: ILogger) {}
}
```

## 📚 결론

MVC는 전통적이면서도 강력한 아키텍처 패턴입니다.

적절히 적용하면:

- **명확한 관심사 분리**로 코드의 가독성 향상
- **높은 재사용성**으로 개발 효율성 증대
- **유지보수성 향상**으로 장기적인 프로젝트 관리 용이
- **테스트 용이성**으로 코드 품질 향상

프로젝트의 규모와 복잡성을 고려하여 MVC를 적용하여 효율적인 웹 애플리케이션 아키텍처를 구축하세요.
