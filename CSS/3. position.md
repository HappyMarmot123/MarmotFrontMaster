# CSS Position 속성

## 📖 개요

**CSS Position 속성**은 HTML 요소가 문서 내에서 어떻게 배치되는지를 결정하는 핵심 속성입니다. 이 속성은 요소의 위치 지정 방식을 정의하고, top, right, bottom, left 속성과 함께 사용하여 요소를 정확한 위치에 배치할 수 있게 해줍니다.

**Position 속성이 CSS 레이아웃에서 중요한 이유:**

- **정확한 위치 제어**: 요소를 픽셀 단위로 정확하게 배치할 수 있습니다
- **레이어링 제어**: z-index와 함께 사용하여 요소의 겹침 순서를 관리할 수 있습니다
- **고정 요소 구현**: 헤더, 사이드바, 모달 등의 고정 위치 요소를 만들 수 있습니다
- **복잡한 레이아웃**: 절대 위치와 상대 위치를 조합하여 정교한 레이아웃을 구성할 수 있습니다

## 🔍 Position 속성의 기본값과 동작

### 1. **Static (기본값)**

**특징:**

- 요소가 문서의 일반적인 흐름에 따라 배치됨
- top, right, bottom, left 속성이 무시됨
- z-index 속성이 적용되지 않음
- 가장 기본적이고 예측 가능한 배치 방식

**실무 활용:**

```css
/* 기본 정적 배치 */
.static-element {
  position: static;
  /* top, right, bottom, left 속성이 무시됨 */
  margin: 20px;
  padding: 15px;
  background-color: #f8f9fa;
}

/* 정적 배치의 일반적인 사용 */
.normal-flow {
  position: static;
  width: 100%;
  height: auto;
  margin-bottom: 20px;
}
```

### 2. **Relative (상대 위치)**

**특징:**

- 요소를 원래 위치에서 상대적으로 이동
- 원래 공간은 그대로 유지됨
- 다른 요소의 배치에 영향을 주지 않음
- z-index 속성 사용 가능

**실무 활용:**

```css
/* 상대 위치로 미세 조정 */
.relative-adjustment {
  position: relative;
  top: -10px;
  left: 20px;
  background-color: #e9ecef;
  border: 1px solid #dee2e6;
}

/* 상대 위치로 레이어링 */
.layered-element {
  position: relative;
  z-index: 1;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* 상대 위치로 자식 요소의 기준점 설정 */
.positioning-parent {
  position: relative;
  height: 200px;
  background-color: #f8f9fa;
}
```

### 3. **Absolute (절대 위치)**

**특징:**

- 가장 가까운 positioned 조상 요소를 기준으로 배치
- positioned 조상이 없으면 초기 컨테이닝 블록(viewport)을 기준
- 문서 흐름에서 완전히 제거됨
- 다른 요소의 배치에 영향을 주지 않음

**실무 활용:**

```css
/* 절대 위치로 정확한 배치 */
.absolute-positioned {
  position: absolute;
  top: 50px;
  right: 20px;
  width: 200px;
  height: 100px;
  background-color: #007bff;
  color: white;
}

/* 부모 요소 기준 절대 배치 */
.parent {
  position: relative;
  height: 300px;
  border: 2px solid #dee2e6;
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #28a745;
  color: white;
  padding: 20px;
}
```

### 4. **Fixed (고정 위치)**

**특징:**

- 뷰포트를 기준으로 고정 배치
- 스크롤해도 위치가 변하지 않음
- 문서 흐름에서 제거됨
- 모바일에서 주의가 필요 (iOS Safari 등)

**실무 활용:**

```css
/* 고정 헤더 */
.fixed-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 1000;
}

/* 고정 사이드바 */
.fixed-sidebar {
  position: fixed;
  top: 60px;
  left: 0;
  width: 250px;
  height: calc(100vh - 60px);
  background-color: #f8f9fa;
  border-right: 1px solid #dee2e6;
  overflow-y: auto;
}

/* 고정 플로팅 버튼 */
.floating-button {
  position: fixed;
  bottom: 30px;
  right: 30px;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background-color: #007bff;
  color: white;
  border: none;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  z-index: 999;
}
```

### 5. **Sticky (고정 배치)**

**특징:**

- 일반적인 흐름에 따라 배치되다가 스크롤 시 고정
- 부모 컨테이너의 경계 내에서만 동작
- 상대 위치와 고정 위치의 중간적 특성
- 최신 브라우저에서 지원

**실무 활용:**

```css
/* 스티키 헤더 */
.sticky-header {
  position: sticky;
  top: 0;
  background-color: #fff;
  border-bottom: 1px solid #dee2e6;
  z-index: 100;
  padding: 15px 0;
}

/* 스티키 네비게이션 */
.sticky-nav {
  position: sticky;
  top: 60px;
  background-color: #f8f9fa;
  padding: 10px 0;
  border-bottom: 1px solid #dee2e6;
}

/* 스티키 사이드바 */
.sticky-sidebar {
  position: sticky;
  top: 20px;
  height: fit-content;
  background-color: #fff;
  border: 1px solid #dee2e6;
  border-radius: 8px;
  padding: 20px;
}
```

## 🎯 실무에서 자주 사용되는 패턴

### 1. **모달 오버레이**

```css
/* 모달 배경 */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* 모달 컨텐츠 */
.modal-content {
  position: relative;
  background-color: #fff;
  border-radius: 8px;
  padding: 30px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}

/* 모달 닫기 버튼 */
.modal-close {
  position: absolute;
  top: 15px;
  right: 15px;
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #6c757d;
}
```

### 2. **툴팁 구현**

```css
/* 툴팁 컨테이너 */
.tooltip-container {
  position: relative;
  display: inline-block;
}

/* 툴팁 */
.tooltip {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 14px;
  white-space: nowrap;
  z-index: 1000;
  margin-bottom: 8px;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}

/* 툴팁 화살표 */
.tooltip::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: #333;
}

/* 툴팁 표시 */
.tooltip-container:hover .tooltip {
  opacity: 1;
  visibility: visible;
}
```

### 3. **카드 오버레이 효과**

```css
/* 카드 컨테이너 */
.card-container {
  position: relative;
  overflow: hidden;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* 카드 이미지 */
.card-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

/* 카드 오버레이 */
.card-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    rgba(0, 0, 0, 0.7) 100%
  );
  opacity: 0;
  transition: opacity 0.3s;
  display: flex;
  align-items: flex-end;
  padding: 20px;
}

/* 카드 오버레이 텍스트 */
.card-overlay-text {
  color: white;
  font-size: 18px;
  font-weight: bold;
}

/* 호버 시 오버레이 표시 */
.card-container:hover .card-overlay {
  opacity: 1;
}
```

## 🔧 고급 활용 기법

### 1. **Z-Index 관리**

```css
/* 레이어 순서 정의 */
.z-base {
  z-index: 1;
}
.z-content {
  z-index: 10;
}
.z-dropdown {
  z-index: 100;
}
.z-sticky {
  z-index: 200;
}
.z-header {
  z-index: 300;
}
.z-modal {
  z-index: 1000;
}
.z-tooltip {
  z-index: 1100;
}

/* 컨텍스트별 z-index 관리 */
.modal-context {
  position: relative;
  z-index: 1000;
}

.modal-context .dropdown {
  z-index: 1001; /* 모달 내부의 드롭다운 */
}
```

### 2. **성능 최적화**

```css
/* GPU 가속 활용 */
.gpu-accelerated {
  position: absolute;
  transform: translateZ(0); /* GPU 가속 활성화 */
  will-change: transform; /* 브라우저에 변경 예고 */
}

/* 레이아웃 변경 최소화 */
.stable-position {
  position: fixed;
  /* top, left 등 위치 속성을 한 번만 설정 */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
```

### 3. **반응형 위치 조정**

```css
/* 모바일에서 위치 조정 */
@media (max-width: 768px) {
  .desktop-positioned {
    position: static;
    margin: 20px 0;
  }

  .mobile-floating {
    position: fixed;
    bottom: 20px;
    right: 20px;
    left: 20px;
    width: auto;
  }
}

/* 태블릿에서 위치 조정 */
@media (min-width: 769px) and (max-width: 1024px) {
  .tablet-adjusted {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}
```

## 📱 모바일 환경 고려사항

### 1. **iOS Safari 주의사항**

```css
/* iOS에서 고정 위치 문제 해결 */
.ios-fixed {
  position: fixed;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
}

/* iOS에서 스크롤 시 고정 요소 깜빡임 방지 */
.ios-stable {
  position: fixed;
  -webkit-overflow-scrolling: touch;
  overflow-scrolling: touch;
}
```

### 2. **터치 인터페이스 최적화**

```css
/* 터치 친화적 위치 */
.touch-friendly {
  position: fixed;
  bottom: 20px;
  right: 20px;
  min-width: 44px; /* 터치 최소 크기 */
  min-height: 44px;
  border-radius: 50%;
}
```

## 🎨 접근성 고려사항

### 1. **키보드 네비게이션**

```css
/* 포커스 가능한 요소의 위치 */
.focusable-positioned {
  position: relative;
}

.focusable-positioned:focus {
  outline: 2px solid #007bff;
  outline-offset: 2px;
  z-index: 10;
}
```

### 2. **스크린 리더 지원**

```css
/* 스크린 리더를 위한 숨김 */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

## 🎯 결론

CSS Position 속성은 웹 레이아웃에서 요소의 정확한 위치를 제어하는 강력한 도구입니다. 각 position 값의 특성을 이해하고 적절히 활용하면 복잡한 레이아웃도 쉽게 구현할 수 있습니다.

**성공적인 위치 제어를 위한 핵심 요소:**

1. **기본 값 이해**: static, relative, absolute, fixed, sticky의 차이점과 활용법
2. **컨텍스트 관리**: positioned 요소와 일반 요소의 관계 이해
3. **Z-Index 전략**: 레이어 순서의 체계적 관리
4. **성능 최적화**: GPU 가속과 레이아웃 변경 최소화
5. **접근성**: 모든 사용자를 위한 사용성 고려

Position 속성을 마스터하면 정교한 웹 레이아웃을 구현할 수 있으며, 사용자 경험을 향상시키는 인터랙티브한 요소들을 만들 수 있습니다.
