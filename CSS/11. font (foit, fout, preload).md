# CSS Font 최적화 (FOIT, FOUT, Preload)

## 📖 개요

**CSS Font 최적화**는 웹 폰트 로딩 성능과 사용자 경험을 향상시키기 위한 핵심 기술입니다. FOIT(Flash of Invisible Text), FOUT(Flash of Unstyled Text), 그리고 font preload 등의 기법을 통해 폰트 로딩 중 발생하는 시각적 문제를 해결하고, 빠르고 일관된 타이포그래피 경험을 제공할 수 있습니다.

**Font 최적화가 현대 웹 개발에서 중요한 이유:**

- **사용자 경험**: 폰트 로딩 지연으로 인한 레이아웃 시프트와 깜빡임 현상 방지
- **성능 최적화**: 폰트 파일 크기와 로딩 시간 최적화로 페이지 로딩 속도 향상
- **접근성**: 모든 사용자가 읽기 쉬운 텍스트에 빠르게 접근할 수 있도록 보장
- **브랜드 일관성**: 의도된 타이포그래피가 신속하게 표시되어 브랜드 아이덴티티 유지
- **Core Web Vitals**: CLS(Cumulative Layout Shift) 개선으로 SEO 성능 향상

**Font 최적화의 핵심 가치:**
웹 폰트는 브랜드 아이덴티티와 사용자 경험의 핵심 요소이지만, 잘못 구현하면 성능 저하와 사용성 문제를 야기할 수 있습니다. 적절한 최적화를 통해 아름다운 타이포그래피와 빠른 성능을 동시에 달성할 수 있으며, 이는 현대 웹 개발의 필수 역량입니다.

## 🔤 FOIT와 FOUT 이해하기

### 1. **FOIT (Flash of Invisible Text)**

**FOIT의 특징과 문제점:**

- 웹 폰트가 로딩되는 동안 텍스트가 완전히 보이지 않음
- 사용자가 콘텐츠를 읽을 수 없어 사용성 저하
- 폰트 로딩 실패 시 영구적인 빈 화면 위험

**FOIT 발생 상황:**

```css
/* FOIT를 유발하는 일반적인 웹 폰트 선언 */
@font-face {
  font-family: "CustomFont";
  src: url("customfont.woff2") format("woff2"), url("customfont.woff") format("woff");
  /* font-display 속성 없음 - 기본값은 auto (브라우저마다 다름) */
}

.text-content {
  font-family: "CustomFont", sans-serif;
  /* 폰트 로딩 중 텍스트가 보이지 않을 수 있음 */
}
```

**FOIT 해결 방법:**

```css
/* font-display: swap으로 FOIT 방지 */
@font-face {
  font-family: "CustomFont";
  src: url("customfont.woff2") format("woff2"), url("customfont.woff") format("woff");
  font-display: swap; /* 즉시 폴백 폰트 표시, 로딩 완료 시 교체 */
}

/* font-display: fallback으로 균형잡힌 접근 */
@font-face {
  font-family: "HeadingFont";
  src: url("headingfont.woff2") format("woff2");
  font-display: fallback; /* 짧은 대기 후 폴백 폰트, 제한 시간 내 교체 */
}

/* font-display: optional로 성능 우선 */
@font-face {
  font-family: "OptionalFont";
  src: url("optionalfont.woff2") format("woff2");
  font-display: optional; /* 네트워크 상태에 따라 선택적 로딩 */
}
```

### 2. **FOUT (Flash of Unstyled Text)**

**FOUT의 특징과 활용:**

- 폴백 폰트로 텍스트를 먼저 표시
- 웹 폰트 로딩 완료 시 교체로 인한 깜빡임 발생
- 콘텐츠 접근성은 좋지만 시각적 불일치 문제

**FOUT 최적화 전략:**

```css
/* 폴백 폰트와 웹 폰트의 크기 차이 최소화 */
@font-face {
  font-family: "WebFont";
  src: url("webfont.woff2") format("woff2");
  font-display: swap;
  /* 폰트 메트릭 조정으로 레이아웃 시프트 최소화 */
  ascent-override: 90%;
  descent-override: 25%;
  line-gap-override: 0%;
  size-adjust: 100%;
}

/* 폴백 폰트 스택 최적화 */
.optimized-text {
  font-family: "WebFont", /* 웹 폰트와 유사한 메트릭의 시스템 폰트 */ "Segoe UI",
    "Roboto", "Helvetica Neue", Arial, sans-serif;

  /* 폰트 크기 조정으로 FOUT 임팩트 최소화 */
  font-size: 1rem;
  line-height: 1.5;
  letter-spacing: 0.01em;
}

/* 웹 폰트 로딩 상태별 스타일 */
.text-content {
  font-family: Arial, sans-serif; /* 기본 폴백 */
  transition: font-family 0.1s ease; /* 부드러운 전환 */
}

/* 웹 폰트 로딩 완료 시 */
.fonts-loaded .text-content {
  font-family: "WebFont", Arial, sans-serif;
}

/* 웹 폰트 로딩 실패 시 */
.fonts-failed .text-content {
  font-family: Arial, sans-serif;
  /* 스타일 보정으로 유사한 느낌 유지 */
  font-weight: 500;
  letter-spacing: 0.02em;
}
```

## ⚡ Font-Display 속성 마스터하기

### 1. **Font-Display 값별 특성**

**각 값의 동작과 적용 시나리오:**

- `auto`: 브라우저 기본 동작 (일반적으로 block과 유사)
- `block`: 짧은 대기 후 무제한 교체 허용
- `swap`: 즉시 폴백 표시, 무제한 교체 허용
- `fallback`: 짧은 대기, 제한된 교체 기간
- `optional`: 네트워크 성능에 따른 선택적 로딩

**실무 활용 가이드:**

```css
/* 브랜드 로고 폰트 - 중요하므로 block 사용 */
@font-face {
  font-family: "BrandLogo";
  src: url("brand-logo.woff2") format("woff2");
  font-display: block;
  /* 로고는 정확한 폰트가 중요하므로 잠시 기다려서라도 정확히 표시 */
}

/* 본문 텍스트 - 가독성 우선으로 swap 사용 */
@font-face {
  font-family: "BodyText";
  src: url("body-text.woff2") format("woff2");
  font-display: swap;
  /* 즉시 읽을 수 있어야 하므로 폴백 폰트로 먼저 표시 */
}

/* 제목 폰트 - 균형잡힌 fallback 사용 */
@font-face {
  font-family: "HeadingFont";
  src: url("heading-font.woff2") format("woff2");
  font-display: fallback;
  /* 짧은 대기 후 제한된 시간 내에만 교체 */
}

/* 장식 폰트 - 선택적 optional 사용 */
@font-face {
  font-family: "DecorativeFont";
  src: url("decorative-font.woff2") format("woff2");
  font-display: optional;
  /* 네트워크가 빠를 때만 로딩, 느리면 폴백 유지 */
}

/* 아이콘 폰트 - 필수적이므로 block 사용 */
@font-face {
  font-family: "IconFont";
  src: url("icon-font.woff2") format("woff2");
  font-display: block;
  /* 아이콘이 없으면 의미가 손상되므로 반드시 로딩 */
}
```

### 2. **Font-Display와 사용자 경험**

**콘텐츠 타입별 최적 전략:**

```css
/* 뉴스/블로그 콘텐츠 - 가독성 최우선 */
@font-face {
  font-family: "ReadableFont";
  src: url("readable-font.woff2") format("woff2");
  font-display: swap; /* 즉시 읽을 수 있도록 */
}

.article-content {
  font-family: "ReadableFont", Georgia, "Times New Roman", serif;
  font-size: 1.125rem;
  line-height: 1.7;
  /* 긴 텍스트 읽기에 최적화 */
}

/* 마케팅 페이지 - 브랜드 경험 중요 */
@font-face {
  font-family: "BrandFont";
  src: url("brand-font.woff2") format("woff2");
  font-display: fallback; /* 브랜드 느낌과 성능의 균형 */
}

.marketing-headline {
  font-family: "BrandFont", "Helvetica Neue", Arial, sans-serif;
  font-size: 3rem;
  font-weight: 700;
  /* 임팩트있는 헤드라인 */
}

/* 대시보드/앱 UI - 성능 우선 */
@font-face {
  font-family: "UIFont";
  src: url("ui-font.woff2") format("woff2");
  font-display: optional; /* 빠른 인터랙션이 중요 */
}

.dashboard-text {
  font-family: "UIFont", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  font-size: 0.875rem;
  /* 시스템 폰트와 유사한 느낌 유지 */
}
```

## 🚀 Font Preload 전략

### 1. **리소스 힌트 활용**

**효과적인 폰트 preload 구현:**

```html
<!-- HTML head에서 중요한 폰트 preload -->
<link
  rel="preload"
  href="/fonts/critical-font.woff2"
  as="font"
  type="font/woff2"
  crossorigin
/>

<!-- 여러 폰트 weight preload -->
<link
  rel="preload"
  href="/fonts/body-regular.woff2"
  as="font"
  type="font/woff2"
  crossorigin
/>
<link
  rel="preload"
  href="/fonts/body-bold.woff2"
  as="font"
  type="font/woff2"
  crossorigin
/>

<!-- 조건부 preload (JavaScript 필요) -->
<script>
  // 화면 크기에 따른 선택적 preload
  if (window.innerWidth > 768) {
    const link = document.createElement("link");
    link.rel = "preload";
    link.href = "/fonts/desktop-font.woff2";
    link.as = "font";
    link.type = "font/woff2";
    link.crossOrigin = "";
    document.head.appendChild(link);
  }
</script>
```

**CSS와 연동한 preload 최적화:**

```css
/* preload된 폰트의 CSS 정의 */
@font-face {
  font-family: "CriticalFont";
  src: url("/fonts/critical-font.woff2") format("woff2");
  font-display: swap;
  /* preload로 이미 다운로드되어 즉시 사용 가능 */
}

/* 우선순위가 높은 텍스트에 적용 */
.hero-title {
  font-family: "CriticalFont", sans-serif;
  font-size: 3.5rem;
  font-weight: 700;
  /* Above-the-fold 콘텐츠에서 즉시 표시 */
}

/* 지연 로딩되는 폰트는 별도 처리 */
@font-face {
  font-family: "SecondaryFont";
  src: url("/fonts/secondary-font.woff2") format("woff2");
  font-display: optional;
  /* 필요할 때만 로딩 */
}
```

### 2. **폰트 서브셋팅과 최적화**

**파일 크기 최적화 전략:**

```css
/* 라틴 문자만 포함한 서브셋 */
@font-face {
  font-family: "OptimizedFont";
  src: url("/fonts/font-latin.woff2") format("woff2");
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA,
    U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215,
    U+FEFF, U+FFFD;
}

/* 한글 문자를 위한 별도 서브셋 */
@font-face {
  font-family: "OptimizedFont";
  src: url("/fonts/font-korean.woff2") format("woff2");
  font-display: swap;
  unicode-range: U+AC00-D7AF, U+1100-11FF, U+3130-318F, U+A960-A97F, U+D7B0-D7FF;
}

/* 특수 문자를 위한 서브셋 */
@font-face {
  font-family: "OptimizedFont";
  src: url("/fonts/font-symbols.woff2") format("woff2");
  font-display: optional;
  unicode-range: U+2190-21FF, U+2600-26FF, U+1F300-1F5FF, U+1F600-1F64F,
    U+1F680-1F6FF;
}

/* 폰트 weight별 최적화 */
@font-face {
  font-family: "VariableFont";
  src: url("/fonts/variable-font.woff2") format("woff2-variations");
  font-display: swap;
  font-weight: 100 900; /* Variable font로 모든 weight 지원 */
  font-style: normal oblique 0deg 20deg;
}

/* Variable font 활용 */
.dynamic-weight {
  font-family: "VariableFont", sans-serif;
  font-weight: var(--dynamic-weight, 400);
  font-style: oblique var(--dynamic-slant, 0deg);
  transition: font-weight 0.3s ease, font-style 0.3s ease;
}
```

## 🎛️ JavaScript를 활용한 고급 폰트 로딩

### 1. **Font Loading API 활용**

**프로그래밍적 폰트 로딩 제어:**

```javascript
// Font Loading API를 사용한 폰트 로딩 감지
class FontLoadingManager {
  constructor() {
    this.loadedFonts = new Set();
    this.initializeFontLoading();
  }

  async initializeFontLoading() {
    // 중요한 폰트 우선 로딩
    const criticalFonts = [
      new FontFace("CriticalFont", "url(/fonts/critical-font.woff2)"),
      new FontFace("CriticalFont", "url(/fonts/critical-font-bold.woff2)", {
        weight: "700",
      }),
    ];

    // 병렬 로딩으로 성능 최적화
    try {
      const loadedFonts = await Promise.all(
        criticalFonts.map((font) => font.load())
      );

      // 문서에 폰트 추가
      loadedFonts.forEach((font) => {
        document.fonts.add(font);
        this.loadedFonts.add(font.family);
      });

      // CSS 클래스로 로딩 상태 알림
      document.documentElement.classList.add("critical-fonts-loaded");
    } catch (error) {
      console.warn("Critical fonts failed to load:", error);
      document.documentElement.classList.add("critical-fonts-failed");
    }

    // 선택적 폰트는 지연 로딩
    this.loadOptionalFonts();
  }

  async loadOptionalFonts() {
    // 메인 콘텐츠 로딩 완료 후 선택적 폰트 로딩
    await new Promise((resolve) => {
      if (document.readyState === "complete") {
        resolve();
      } else {
        window.addEventListener("load", resolve);
      }
    });

    const optionalFonts = [
      new FontFace("DecorativeFont", "url(/fonts/decorative-font.woff2)"),
      new FontFace("IconFont", "url(/fonts/icon-font.woff2)"),
    ];

    // 네트워크 상태 고려
    if (navigator.connection && navigator.connection.effectiveType === "4g") {
      try {
        const loadedOptionalFonts = await Promise.all(
          optionalFonts.map((font) => font.load())
        );

        loadedOptionalFonts.forEach((font) => {
          document.fonts.add(font);
          this.loadedFonts.add(font.family);
        });

        document.documentElement.classList.add("optional-fonts-loaded");
      } catch (error) {
        console.info("Optional fonts not loaded due to network conditions");
      }
    }
  }

  // 폰트 로딩 상태 확인
  isFontLoaded(fontFamily) {
    return this.loadedFonts.has(fontFamily);
  }

  // 폰트 로딩 완료 대기
  async waitForFont(fontFamily, timeout = 3000) {
    if (this.isFontLoaded(fontFamily)) {
      return true;
    }

    return new Promise((resolve) => {
      const checkFont = () => {
        if (document.fonts.check(`1em ${fontFamily}`)) {
          this.loadedFonts.add(fontFamily);
          resolve(true);
        }
      };

      // 폰트 로딩 이벤트 리스너
      document.fonts.addEventListener("loadingdone", checkFont);

      // 타임아웃 설정
      setTimeout(() => {
        document.fonts.removeEventListener("loadingdone", checkFont);
        resolve(false);
      }, timeout);

      checkFont(); // 즉시 확인
    });
  }
}

// 폰트 로딩 매니저 초기화
const fontManager = new FontLoadingManager();
```

### 2. **Intersection Observer를 활용한 지연 로딩**

**화면에 보이는 콘텐츠만 폰트 로딩:**

```javascript
// 뷰포트 기반 폰트 지연 로딩
class LazyFontLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      {
        rootMargin: "100px 0px", // 100px 전에 미리 로딩
        threshold: 0.1,
      }
    );

    this.initializeLazyFonts();
  }

  initializeLazyFonts() {
    // 지연 로딩할 요소들 관찰
    const lazyFontElements = document.querySelectorAll("[data-lazy-font]");
    lazyFontElements.forEach((element) => {
      this.observer.observe(element);
    });
  }

  handleIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        this.loadFontForElement(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }

  async loadFontForElement(element) {
    const fontFamily = element.dataset.lazyFont;
    const fontUrl = element.dataset.fontUrl;
    const fontWeight = element.dataset.fontWeight || "normal";

    try {
      const font = new FontFace(fontFamily, `url(${fontUrl})`, {
        weight: fontWeight,
      });

      await font.load();
      document.fonts.add(font);

      // 폰트 로딩 완료 시 클래스 추가
      element.classList.add("font-loaded");
      element.style.fontFamily = `${fontFamily}, ${element.style.fontFamily}`;
    } catch (error) {
      console.warn(`Failed to load font ${fontFamily}:`, error);
      element.classList.add("font-failed");
    }
  }
}

// CSS와 연동
const lazyFontLoader = new LazyFontLoader();
```

**해당 CSS:**

```css
/* 지연 로딩 폰트를 위한 스타일 */
[data-lazy-font] {
  font-family: Arial, sans-serif; /* 기본 폴백 */
  transition: font-family 0.2s ease;
}

[data-lazy-font].font-loaded {
  /* 폰트 로딩 완료 시 적용될 스타일 */
}

[data-lazy-font].font-failed {
  /* 폰트 로딩 실패 시 보정 스타일 */
  font-weight: 500;
  letter-spacing: 0.01em;
}

/* 스켈레톤 로딩 효과 */
[data-lazy-font]:not(.font-loaded) {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: skeleton-loading 1.5s infinite;
  color: transparent;
}

@keyframes skeleton-loading {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}
```

## 📊 성능 측정과 모니터링

### 1. **Core Web Vitals 최적화**

**CLS (Cumulative Layout Shift) 개선:**

```css
/* 폰트 메트릭 매칭으로 레이아웃 시프트 최소화 */
@font-face {
  font-family: "WebFont";
  src: url("webfont.woff2") format("woff2");
  font-display: swap;

  /* 폴백 폰트와 유사한 메트릭 조정 */
  ascent-override: 92%;
  descent-override: 23%;
  line-gap-override: 0%;
  size-adjust: 105%; /* 웹 폰트를 폴백 폰트 크기에 맞춤 */
}

/* 폴백 폰트 최적화 */
.cls-optimized {
  font-family: "WebFont", /* 웹 폰트와 유사한 메트릭의 시스템 폰트 */ "Segoe UI",
    system-ui, sans-serif;

  /* 일관된 라인 하이트로 레이아웃 안정성 확보 */
  line-height: 1.5;

  /* 폰트 크기 조정으로 시각적 일관성 유지 */
  font-size: 1rem;
  font-weight: 400;
}

/* 중요한 텍스트는 reserved space 확보 */
.hero-title {
  font-family: "HeadingFont", Impact, Arial, sans-serif;
  min-height: 4rem; /* 폰트 로딩 전에도 공간 확보 */
  display: flex;
  align-items: center;
}
```

### 2. **성능 모니터링과 분석**

**실시간 폰트 성능 추적:**

```javascript
// 폰트 로딩 성능 모니터링
class FontPerformanceMonitor {
  constructor() {
    this.metrics = {
      fontLoadingStart: performance.now(),
      fontsLoaded: [],
      fontsFailed: [],
      totalFontSize: 0,
    };

    this.initializeMonitoring();
  }

  initializeMonitoring() {
    // Performance Observer로 리소스 타이밍 감지
    if ("PerformanceObserver" in window) {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.initiatorType === "css" && entry.name.includes("font")) {
            this.recordFontMetrics(entry);
          }
        });
      });

      observer.observe({ entryTypes: ["resource"] });
    }

    // Font Loading API 이벤트 감지
    document.fonts.addEventListener("loading", (event) => {
      console.log(`Font loading started: ${event.fontface.family}`);
    });

    document.fonts.addEventListener("loadingdone", (event) => {
      this.metrics.fontsLoaded.push({
        family: event.fontface.family,
        loadTime: performance.now() - this.metrics.fontLoadingStart,
      });

      this.analyzePerformance();
    });

    document.fonts.addEventListener("loadingerror", (event) => {
      this.metrics.fontsFailed.push({
        family: event.fontface.family,
        error: event.error,
      });
    });
  }

  recordFontMetrics(entry) {
    this.metrics.totalFontSize += entry.transferSize || 0;

    // Core Web Vitals 영향 분석
    this.checkCLSImpact(entry);
  }

  checkCLSImpact(entry) {
    // 폰트 로딩이 레이아웃에 미치는 영향 감지
    if (entry.responseEnd > entry.loadEventStart + 100) {
      console.warn(
        `Font ${entry.name} may cause layout shift - load time: ${entry.duration}ms`
      );
    }
  }

  analyzePerformance() {
    const totalLoadTime = performance.now() - this.metrics.fontLoadingStart;

    // 성능 기준 평가
    if (totalLoadTime > 3000) {
      console.warn("Font loading exceeds 3 seconds - consider optimization");
      this.suggestOptimizations();
    }

    // 폰트 사용률 분석
    this.analyzeFontUsage();
  }

  suggestOptimizations() {
    const suggestions = [];

    if (this.metrics.totalFontSize > 500000) {
      // 500KB
      suggestions.push("Consider font subsetting to reduce file size");
    }

    if (this.metrics.fontsFailed.length > 0) {
      suggestions.push("Implement better fallback strategies for failed fonts");
    }

    if (this.metrics.fontsLoaded.length > 5) {
      suggestions.push("Consider reducing the number of font variants");
    }

    console.log("Font optimization suggestions:", suggestions);
  }

  analyzeFontUsage() {
    // 실제 사용되는 폰트 분석
    const usedFonts = new Set();

    document.querySelectorAll("*").forEach((element) => {
      const computedStyle = getComputedStyle(element);
      const fontFamily = computedStyle.fontFamily;
      if (fontFamily && fontFamily !== "inherit") {
        usedFonts.add(fontFamily.split(",")[0].trim().replace(/["']/g, ""));
      }
    });

    console.log("Actually used fonts:", Array.from(usedFonts));

    // 로딩했지만 사용하지 않는 폰트 감지
    this.metrics.fontsLoaded.forEach((font) => {
      if (!usedFonts.has(font.family)) {
        console.warn(`Loaded but unused font: ${font.family}`);
      }
    });
  }

  // 성능 리포트 생성
  generateReport() {
    return {
      totalLoadTime: performance.now() - this.metrics.fontLoadingStart,
      fontsLoaded: this.metrics.fontsLoaded.length,
      fontsFailed: this.metrics.fontsFailed.length,
      totalSize: this.metrics.totalFontSize,
      recommendations: this.generateRecommendations(),
    };
  }

  generateRecommendations() {
    const recommendations = [];

    // 데이터 기반 추천사항 생성
    if (this.metrics.totalFontSize > 300000) {
      recommendations.push({
        type: "size-optimization",
        message: "Consider using variable fonts or reducing font variants",
        impact: "high",
      });
    }

    return recommendations;
  }
}

// 모니터링 시작
const fontMonitor = new FontPerformanceMonitor();

// 페이지 로드 완료 후 리포트 생성
window.addEventListener("load", () => {
  setTimeout(() => {
    const report = fontMonitor.generateReport();
    console.log("Font Performance Report:", report);
  }, 2000);
});
```

## 🎯 결론

CSS Font 최적화는 웹 성능과 사용자 경험을 동시에 향상시키는 핵심 기술입니다. FOIT/FOUT 문제 해결, 적절한 font-display 전략, 그리고 효과적인 preload 활용을 통해 아름다운 타이포그래피와 빠른 성능을 모두 달성할 수 있습니다.

**성공적인 Font 최적화를 위한 핵심 요소:**

1. **로딩 전략**: font-display 속성으로 FOIT/FOUT 제어
2. **우선순위 관리**: 중요한 폰트는 preload, 선택적 폰트는 지연 로딩
3. **파일 최적화**: 서브셋팅과 Variable Font 활용으로 크기 최소화
4. **성능 모니터링**: Core Web Vitals 개선과 실시간 성능 추적
5. **사용자 배려**: 네트워크 상태와 사용자 설정 고려

Font 최적화를 마스터하면 브랜드 아이덴티티를 유지하면서도 뛰어난 성능을 제공하는 웹사이트를 구축할 수 있으며, 모든 사용자에게 일관되고 빠른 타이포그래피 경험을 제공할 수 있습니다.
