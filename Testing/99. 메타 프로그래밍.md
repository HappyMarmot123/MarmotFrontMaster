# 메타 프로그래밍(Metaprogramming)

## 메타 프로그래밍이란?

메타 프로그래밍은 **'프로그램이 다른 프로그램이나 자기 자신을 수정하거나 생성하는'** 프로그래밍 기법이에요. 🤖 코드가 자신의 동작을 동적으로 변경하거나, 컴파일 타임 또는 런타임에 새로운 코드를 만들어내는 것을 의미하죠.

### 메타 프로그래밍의 핵심 개념

- **동적 코드 생성:** 특정 패턴에 맞는 코드를 자동으로 생성하여 개발자가 반복적인 코드를 직접 작성하지 않도록 도와요. 예를 들어, ORM(객체 관계 매핑) 라이브러리는 데이터베이스 스키마를 바탕으로 모델 클래스를 자동으로 생성해요.
- **리플렉션(Reflection):** 프로그램이 자신의 구조(클래스, 메서드, 변수 등)를 런타임에 조사하고 조작할 수 있도록 해요. 이를 통해 프로그램의 동작을 유연하게 제어할 수 있습니다.
- **데코레이터(Decorator):** 함수나 클래스의 동작을 변경하지 않고도 기능을 추가하는 방식이에요. 파이썬이나 자바스크립트에서 흔히 볼 수 있는 `@` 문법이 대표적이죠.

## JavaScript에서의 메타 프로그래밍 기법

### 1. 리플렉션(Reflection)

JavaScript는 런타임에 객체의 구조를 조사하고 조작할 수 있는 강력한 리플렉션 기능을 제공합니다.

```javascript
// 객체 속성 조사
const obj = { name: "John", age: 30 };

// 속성 존재 확인
console.log("name" in obj); // true
console.log(obj.hasOwnProperty("age")); // true

// 속성 목록 가져오기
console.log(Object.keys(obj)); // ['name', 'age']
console.log(Object.values(obj)); // ['John', 30]
console.log(Object.entries(obj)); // [['name', 'John'], ['age', 30]]

// 속성 설명자 가져오기
const descriptor = Object.getOwnPropertyDescriptor(obj, "name");
console.log(descriptor); // {value: 'John', writable: true, enumerable: true, configurable: true}
```

### 2. 동적 속성 접근

```javascript
const obj = { name: "John", age: 30 };

// 동적 속성 접근
const propertyName = "name";
console.log(obj[propertyName]); // 'John'

// 동적 메서드 호출
const methodName = "toString";
console.log(obj[methodName]()); // '[object Object]'
```

### 3. Proxy 객체

Proxy는 객체의 기본 동작을 가로채고 사용자 정의 동작으로 대체할 수 있게 해줍니다.

```javascript
const target = { name: "John", age: 30 };

const handler = {
  get(target, prop, receiver) {
    console.log(`속성 ${prop}에 접근했습니다.`);
    return target[prop];
  },

  set(target, prop, value, receiver) {
    console.log(`속성 ${prop}을 ${value}로 설정했습니다.`);
    target[prop] = value;
    return true;
  },
};

const proxy = new Proxy(target, handler);

// 속성 접근 시 로그 출력
console.log(proxy.name); // "속성 name에 접근했습니다." + "John"
proxy.age = 31; // "속성 age을 31로 설정했습니다."
```

### 4. Symbol과 메타데이터

Symbol은 객체에 메타데이터를 추가하거나 내부 속성을 정의하는 데 사용됩니다.

```javascript
// 내부 속성 정의
const _private = Symbol("private");

class Example {
  constructor() {
    this[_private] = "private data";
  }

  getPrivateData() {
    return this[_private];
  }
}

const ex = new Example();
console.log(ex.getPrivateData()); // 'private data'
console.log(ex[_private]); // 'private data' (Symbol을 알고 있어야 접근 가능)
```

### 5. 함수 생성자와 eval

```javascript
// 동적 함수 생성
const functionBody = "return x + y;";
const dynamicFunction = new Function("x", "y", functionBody);

console.log(dynamicFunction(5, 3)); // 8

// eval 사용 (주의: 보안 위험)
const expression = "2 + 2";
const result = eval(expression); // 4
```

## 데코레이터(Decorator)

데코레이터는 클래스, 메서드, 속성에 메타데이터를 추가하거나 동작을 수정하는 데 사용됩니다.

```javascript
// 간단한 로깅 데코레이터
function log(target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args) {
    console.log(`${propertyKey} 메서드 호출됨`);
    const result = originalMethod.apply(this, args);
    console.log(`${propertyKey} 메서드 완료됨`);
    return result;
  };

  return descriptor;
}

class Calculator {
  @log
  add(a, b) {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(5, 3); // 로그 출력 후 결과 반환
```

## 메타 프로그래밍의 실제 활용 사례

### 1. ORM 라이브이러리

```javascript
// 간단한 ORM 예시
class Model {
  static define(name, schema) {
    return class extends Model {
      constructor(data) {
        super();
        Object.assign(this, data);
      }

      static get tableName() {
        return name;
      }
    };
  }
}

// 사용 예시
const User = Model.define("users", {
  name: String,
  email: String,
  age: Number,
});

const user = new User({ name: "John", email: "john@example.com", age: 30 });
```

### 2. API 클라이언트 생성

```javascript
// API 엔드포인트 자동 생성
function createAPIClient(baseURL) {
  return new Proxy(
    {},
    {
      get(target, prop) {
        return function (data) {
          return fetch(`${baseURL}/${prop}`, {
            method: "POST",
            body: JSON.stringify(data),
            headers: { "Content-Type": "application/json" },
          });
        };
      },
    }
  );
}

const api = createAPIClient("https://api.example.com");
api.users({ name: "John" }); // POST /users 호출
```

### 3. 유효성 검사 자동화

```javascript
// 속성 유효성 검사 자동화
function validate(target, propertyKey, descriptor) {
  const originalSet = descriptor.set;

  descriptor.set = function (value) {
    if (this.validators && this.validators[propertyKey]) {
      const validator = this.validators[propertyKey];
      if (!validator(value)) {
        throw new Error(`Invalid value for ${propertyKey}: ${value}`);
      }
    }
    originalSet.call(this, value);
  };
}

class User {
  validators = {
    age: (value) => value >= 0 && value <= 150,
    email: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
  };

  @validate
  set age(value) {
    this._age = value;
  }

  @validate
  set email(value) {
    this._email = value;
  }
}
```

## 테스팅 도구의 Mock 객체

테스팅에서 **Mock(모의) 객체**는 실제 객체의 동작을 흉내 내는 가짜 객체예요. 🎭 단위 테스트(Unit Test)를 수행할 때, 테스트 대상 코드가 의존하는 외부 시스템(데이터베이스, 네트워크 API 등)을 시뮬레이션하기 위해 사용됩니다.

### Mock 객체의 역할

- **외부 의존성 분리:** 테스트 중인 코드가 실제 데이터베이스나 네트워크에 연결될 필요 없이, 미리 정해진 응답을 반환하도록 설정할 수 있어요.
- **예측 가능한 테스트 환경:** 외부 시스템의 불안정성(네트워크 지연, 서버 다운 등)에 영향을 받지 않고 일관된 결과를 얻을 수 있어요.
- **특정 시나리오 테스트:** 실제로는 발생시키기 어려운 예외 상황(예: 네트워크 에러, 데이터베이스 연결 실패)을 의도적으로 만들어서 테스트할 수 있어요.

### Mock 객체 사용 예시

```javascript
// 간단한 Mock 객체 생성
function createMockAPI() {
  return {
    getUsers: jest.fn().mockResolvedValue([
      { id: 1, name: "John" },
      { id: 2, name: "Jane" },
    ]),

    createUser: jest.fn().mockResolvedValue({ id: 3, name: "Bob" }),

    deleteUser: jest.fn().mockResolvedValue({ success: true }),
  };
}

// 테스트에서 사용
const mockAPI = createMockAPI();
const userService = new UserService(mockAPI);

test("사용자 목록을 가져온다", async () => {
  const users = await userService.getUsers();
  expect(users).toHaveLength(2);
  expect(mockAPI.getUsers).toHaveBeenCalled();
});
```

## 메타 프로그래밍의 장단점

### 장점

1. **코드 중복 제거:** 반복적인 패턴을 자동화하여 코드량을 줄일 수 있습니다.
2. **유연성 향상:** 런타임에 동적으로 동작을 변경할 수 있습니다.
3. **생산성 증대:** 보일러플레이트 코드를 자동으로 생성할 수 있습니다.

### 단점

1. **복잡성 증가:** 코드의 동작을 예측하기 어려워집니다.
2. **디버깅 어려움:** 런타임에 생성된 코드는 디버깅이 복잡합니다.
3. **성능 오버헤드:** 메타 프로그래밍 기법은 일반적으로 성능 비용이 있습니다.
4. **가독성 저하:** 코드의 의도를 파악하기 어려울 수 있습니다.

## 결론

메타 프로그래밍은 JavaScript에서 매우 강력한 도구이지만, 신중하게 사용해야 합니다. 적절한 상황에서 사용하면 코드의 유연성과 재사용성을 크게 향상시킬 수 있지만, 과도한 사용은 코드의 복잡성과 유지보수성을 악화시킬 수 있습니다.

메타 프로그래밍을 사용할 때는 항상 명확한 문서화와 테스트를 통해 코드의 동작을 예측 가능하게 만들어야 하며, 팀원들과의 협업을 고려하여 적절한 수준에서 활용하는 것이 중요합니다.
