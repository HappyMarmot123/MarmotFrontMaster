# Lazy Load (지연 로딩)

## 📖 개요

**Lazy Load(지연 로딩)**는 웹 페이지의 리소스(이미지, 비디오, 스크립트 등)를 사용자가 실제로 필요로 할 때까지 로딩을 지연시키는 기법입니다. 이를 통해 초기 페이지 로딩 시간을 단축하고, 불필요한 리소스 다운로드를 방지하여 웹 성능을 크게 향상시킬 수 있습니다.

## 🎯 Lazy Load의 필요성

### 1. 기존 로딩 방식의 문제점

**즉시 로딩(Immediate Loading)의 한계**:

- **초기 로딩 지연**: 모든 리소스를 한 번에 다운로드하여 페이지 로딩 시간 증가
- **불필요한 데이터 전송**: 뷰포트 밖에 있는 이미지나 콘텐츠도 즉시 로드
- **대역폭 낭비**: 사용자가 보지 않는 콘텐츠까지 다운로드
- **모바일 성능 저하**: 제한된 네트워크 환경에서 큰 리소스 파일 다운로드

**실제 성능 영향**:

```javascript
// 즉시 로딩 방식의 문제
// 총 이미지 수: 50개
// 초기 로딩 시간: 8.5초
// 총 다운로드 크기: 15.2MB
// First Contentful Paint: 3.8초
// Largest Contentful Paint: 12.3초
```

### 2. Lazy Load의 해결책

**지연 로딩의 이점**:

- **초기 로딩 시간 단축**: 뷰포트에 보이는 콘텐츠만 우선 로드
- **대역폭 절약**: 사용자가 실제로 필요로 하는 리소스만 다운로드
- **사용자 경험 향상**: 페이지 로딩 완료까지의 대기 시간 감소
- **모바일 최적화**: 제한된 네트워크 환경에서의 효율적 리소스 관리

**성능 향상 효과**:

```javascript
// Lazy Load 적용 후
// 초기 로딩 시간: 2.1초 (75% 개선)
// 초기 다운로드 크기: 2.8MB (82% 감소)
// First Contentful Paint: 1.2초 (68% 개선)
// Largest Contentful Paint: 4.8초 (61% 개선)
```

## 🔧 Lazy Load 구현 방법

### 1. 이미지 Lazy Loading

**Intersection Observer API 활용**:

```javascript
// utils/lazyImage.js
class LazyImageLoader {
  constructor() {
    this.imageObserver = null;
    this.init();
  }

  init() {
    // Intersection Observer 지원 확인
    if ("IntersectionObserver" in window) {
      this.imageObserver = new IntersectionObserver(
        this.handleIntersection.bind(this),
        {
          rootMargin: "50px 0px", // 뷰포트 50px 전에 미리 로드
          threshold: 0.01,
        }
      );
    }
  }

  handleIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        this.loadImage(img);
        this.imageObserver.unobserve(img);
      }
    });
  }

  loadImage(img) {
    const src = img.dataset.src;
    if (src) {
      img.src = src;
      img.classList.remove("lazy");
      img.classList.add("loaded");
    }
  }

  observe(image) {
    if (this.imageObserver) {
      this.imageObserver.observe(image);
    } else {
      // 폴백: 즉시 로드
      this.loadImage(image);
    }
  }
}

// 사용 예시
const lazyLoader = new LazyImageLoader();

document.addEventListener("DOMContentLoaded", () => {
  const lazyImages = document.querySelectorAll("img[data-src]");
  lazyImages.forEach((img) => lazyLoader.observe(img));
});
```

**HTML에서의 사용**:

```html
<!-- 기본 Lazy Loading -->
<img
  data-src="images/product1.jpg"
  alt="상품 이미지 1"
  class="lazy"
  loading="lazy"
/>

<!-- 고급 Lazy Loading -->
<img
  data-src="images/product1.jpg"
  data-srcset="images/product1-small.jpg 300w, images/product1-medium.jpg 600w, images/product1-large.jpg 900w"
  data-sizes="(max-width: 768px) 300px, (max-width: 1200px) 600px, 900px"
  alt="상품 이미지 1"
  class="lazy"
  loading="lazy"
/>

<!-- 플레이스홀더 이미지 -->
<img
  data-src="images/product1.jpg"
  src="images/placeholder.jpg"
  alt="상품 이미지 1"
  class="lazy"
  loading="lazy"
/>
```

**CSS 스타일링**:

```css
/* Lazy Loading 이미지 스타일 */
.lazy {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  filter: blur(5px);
}

.lazy.loaded {
  opacity: 1;
  filter: blur(0);
}

/* 로딩 상태 표시 */
.lazy::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin: -10px 0 0 -10px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
```

### 2. React에서의 Lazy Loading

**커스텀 Hook 활용**:

```jsx
// hooks/useLazyLoad.js
import { useEffect, useRef, useState } from "react";

export const useLazyLoad = (options = {}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [isLoaded, setIsLoaded] = useState(false);
  const elementRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.unobserve(entry.target);
        }
      },
      {
        rootMargin: options.rootMargin || "50px",
        threshold: options.threshold || 0.01,
      }
    );

    if (elementRef.current) {
      observer.observe(elementRef.current);
    }

    return () => {
      if (elementRef.current) {
        observer.unobserve(elementRef.current);
      }
    };
  }, [options.rootMargin, options.threshold]);

  const handleLoad = () => {
    setIsLoaded(true);
  };

  return {
    elementRef,
    isVisible,
    isLoaded,
    handleLoad,
  };
};

// 사용 예시
function LazyImage({ src, alt, placeholder }) {
  const { elementRef, isVisible, isLoaded, handleLoad } = useLazyLoad();

  return (
    <div ref={elementRef} className="lazy-image-container">
      {!isVisible && (
        <img src={placeholder} alt="로딩 중..." className="placeholder" />
      )}

      {isVisible && (
        <img
          src={src}
          alt={alt}
          onLoad={handleLoad}
          className={`lazy-image ${isLoaded ? "loaded" : ""}`}
        />
      )}
    </div>
  );
}
```

**React 컴포넌트에서의 활용**:

```jsx
// components/ProductGrid.jsx
import React from "react";
import LazyImage from "./LazyImage";

function ProductGrid({ products }) {
  return (
    <div className="product-grid">
      {products.map((product) => (
        <div key={product.id} className="product-card">
          <LazyImage
            src={product.image}
            alt={product.name}
            placeholder="/images/placeholder.jpg"
          />
          <h3>{product.name}</h3>
          <p>{product.price}</p>
        </div>
      ))}
    </div>
  );
}

export default ProductGrid;
```

### 3. Vue.js에서의 Lazy Loading

**Vue Directive 활용**:

```javascript
// directives/lazyLoad.js
export const lazyLoad = {
  mounted(el, binding) {
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.classList.remove("lazy");
          imageObserver.unobserve(img);
        }
      });
    });

    imageObserver.observe(el);
  },
};

// main.js에서 전역 등록
import { createApp } from "vue";
import App from "./App.vue";
import { lazyLoad } from "./directives/lazyLoad";

const app = createApp(App);
app.directive("lazy", lazyLoad);
app.mount("#app");
```

**Vue 컴포넌트에서의 사용**:

```vue
<!-- ProductCard.vue -->
<template>
  <div class="product-card">
    <img
      v-lazy
      :data-src="product.image"
      :alt="product.name"
      class="product-image lazy"
      loading="lazy"
    />
    <h3>{{ product.name }}</h3>
    <p>{{ product.price }}</p>
  </div>
</template>

<script>
export default {
  name: "ProductCard",
  props: {
    product: {
      type: Object,
      required: true,
    },
  },
};
</script>

<style scoped>
.lazy {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.lazy:not([src=""]):not([src*="placeholder"]) {
  opacity: 1;
}
</style>
```

## 🚀 고급 최적화 기법

### 1. 가상 스크롤링(Virtual Scrolling)

**대용량 리스트 최적화**:

```jsx
// components/VirtualList.jsx
import React, { useState, useEffect, useRef } from "react";

function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // 보이는 아이템만 렌더링
  const visibleItemCount = Math.ceil(containerHeight / itemHeight);
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleItemCount + 1, items.length);

  const visibleItems = items.slice(startIndex, endIndex);
  const totalHeight = items.length * itemHeight;
  const offsetY = startIndex * itemHeight;

  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  return (
    <div
      ref={containerRef}
      style={{ height: containerHeight, overflow: "auto" }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: "relative" }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{ height: itemHeight }}
              className="virtual-list-item"
            >
              {item.content}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

export default VirtualList;
```

**사용 예시**:

```jsx
// App.jsx
import VirtualList from "./components/VirtualList";

function App() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    content: `아이템 ${i}`,
  }));

  return (
    <div className="app">
      <h1>가상 스크롤링 예시</h1>
      <VirtualList items={items} itemHeight={50} containerHeight={400} />
    </div>
  );
}
```

### 2. 무한 스크롤(Infinite Scroll)

**페이지네이션 대신 무한 로딩**:

```jsx
// hooks/useInfiniteScroll.js
import { useState, useEffect, useCallback } from "react";

export const useInfiniteScroll = (fetchData, options = {}) => {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;

    setLoading(true);
    try {
      const newItems = await fetchData(page);

      if (newItems.length === 0) {
        setHasMore(false);
      } else {
        setItems((prev) => [...prev, ...newItems]);
        setPage((prev) => prev + 1);
      }
    } catch (error) {
      console.error("데이터 로딩 실패:", error);
    } finally {
      setLoading(false);
    }
  }, [fetchData, page, loading, hasMore]);

  useEffect(() => {
    const handleScroll = () => {
      if (
        window.innerHeight + document.documentElement.scrollTop >=
        document.documentElement.offsetHeight - options.threshold
      ) {
        loadMore();
      }
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, [loadMore, options.threshold]);

  return { items, loading, hasMore, loadMore };
};

// 사용 예시
function ProductList() {
  const fetchProducts = async (page) => {
    const response = await fetch(`/api/products?page=${page}&limit=20`);
    return response.json();
  };

  const { items, loading, hasMore } = useInfiniteScroll(fetchProducts, {
    threshold: 100,
  });

  return (
    <div className="product-list">
      {items.map((product) => (
        <ProductCard key={product.id} product={product} />
      ))}

      {loading && <div className="loading">로딩 중...</div>}
      {!hasMore && <div className="end">모든 상품을 불러왔습니다.</div>}
    </div>
  );
}
```

### 3. 스마트 프리로딩(Smart Preloading)

**사용자 행동 예측을 통한 프리로딩**:

```javascript
// utils/smartPreloader.js
class SmartPreloader {
  constructor() {
    this.preloadQueue = new Map();
    this.observer = null;
    this.init();
  }

  init() {
    // 마우스 움직임 감지
    this.observeMouseMovement();

    // 스크롤 방향 감지
    this.observeScrollDirection();
  }

  observeMouseMovement() {
    let mouseX = 0;
    let mouseY = 0;
    let direction = "none";

    document.addEventListener("mousemove", (e) => {
      const deltaX = e.clientX - mouseX;
      const deltaY = e.clientY - mouseY;

      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        direction = deltaX > 0 ? "right" : "left";
      } else {
        direction = deltaY > 0 ? "down" : "up";
      }

      mouseX = e.clientX;
      mouseY = e.clientY;

      this.predictAndPreload(direction, e.clientX, e.clientY);
    });
  }

  observeScrollDirection() {
    let lastScrollTop = 0;

    window.addEventListener("scroll", () => {
      const scrollTop = window.pageYOffset;
      const direction = scrollTop > lastScrollTop ? "down" : "up";

      this.preloadVisibleContent(direction);
      lastScrollTop = scrollTop;
    });
  }

  predictAndPreload(direction, x, y) {
    // 마우스 위치와 방향을 기반으로 다음에 보일 콘텐츠 예측
    const predictions = this.getPredictions(direction, x, y);

    predictions.forEach((prediction) => {
      if (!this.preloadQueue.has(prediction.id)) {
        this.preloadQueue.set(prediction.id, prediction);
        this.preloadResource(prediction);
      }
    });
  }

  preloadVisibleContent(direction) {
    const visibleElements = this.getVisibleElements();

    visibleElements.forEach((element) => {
      const nextElement = this.getNextElement(element, direction);
      if (nextElement) {
        this.preloadElement(nextElement);
      }
    });
  }

  preloadResource(prediction) {
    if (prediction.type === "image") {
      const img = new Image();
      img.src = prediction.src;
    } else if (prediction.type === "component") {
      // 컴포넌트 프리로딩
      import(prediction.path);
    }
  }

  getPredictions(direction, x, y) {
    // 방향과 위치 기반 예측 로직
    const predictions = [];

    if (direction === "right") {
      // 오른쪽으로 이동 중이면 다음 이미지 프리로딩
      const nextImage = this.findNextImage(x, y);
      if (nextImage) {
        predictions.push({
          id: nextImage.id,
          type: "image",
          src: nextImage.src,
        });
      }
    }

    return predictions;
  }

  getVisibleElements() {
    // 현재 화면에 보이는 요소들 반환
    return Array.from(document.querySelectorAll("[data-preload]"));
  }

  getNextElement(currentElement, direction) {
    // 방향에 따른 다음 요소 찾기
    const selector =
      direction === "down" ? "nextElementSibling" : "previousElementSibling";
    return currentElement[selector];
  }

  preloadElement(element) {
    const preloadData = element.dataset.preload;
    if (preloadData) {
      const { type, src, path } = JSON.parse(preloadData);
      this.preloadResource({ type, src, path });
    }
  }
}

// 사용 예시
const smartPreloader = new SmartPreloader();
```

## 📊 성능 측정과 모니터링

### 1. Lazy Loading 성능 측정

**Intersection Observer 성능 측정**:

```javascript
// utils/performanceMonitor.js
export const measureLazyLoadingPerformance = () => {
  const metrics = {
    totalImages: 0,
    lazyLoadedImages: 0,
    averageLoadTime: 0,
    totalLoadTime: 0,
  };

  const imageLoadTimes = [];
  const startTime = performance.now();

  // 이미지 로딩 시간 측정
  const measureImageLoad = (img) => {
    const loadStart = performance.now();

    img.addEventListener("load", () => {
      const loadTime = performance.now() - loadStart;
      imageLoadTimes.push(loadTime);
      metrics.totalLoadTime += loadTime;
      metrics.averageLoadTime = metrics.totalLoadTime / imageLoadTimes.length;
    });
  };

  // 모든 이미지에 측정 이벤트 추가
  document.querySelectorAll("img").forEach((img) => {
    metrics.totalImages++;
    if (img.classList.contains("lazy")) {
      metrics.lazyLoadedImages++;
    }
    measureImageLoad(img);
  });

  return metrics;
};
```

**사용자 경험 메트릭 수집**:

```javascript
// utils/userExperienceMetrics.js
export const collectUXMetrics = () => {
  const metrics = {
    firstImageLoad: 0,
    lastImageLoad: 0,
    scrollDepth: 0,
    timeOnPage: 0,
  };

  let firstImageLoaded = false;
  let pageStartTime = performance.now();

  // 첫 번째 이미지 로딩 시간
  document.addEventListener("DOMContentLoaded", () => {
    const firstImage = document.querySelector("img");
    if (firstImage) {
      firstImage.addEventListener("load", () => {
        if (!firstImageLoaded) {
          metrics.firstImageLoad = performance.now() - pageStartTime;
          firstImageLoaded = true;
        }
      });
    }
  });

  // 스크롤 깊이 측정
  let maxScrollDepth = 0;
  window.addEventListener("scroll", () => {
    const scrollTop = window.pageYOffset;
    const documentHeight = document.documentElement.scrollHeight;
    const windowHeight = window.innerHeight;

    const scrollDepth = (scrollTop + windowHeight) / documentHeight;
    maxScrollDepth = Math.max(maxScrollDepth, scrollDepth);
    metrics.scrollDepth = maxScrollDepth;
  });

  // 페이지 이탈 시 메트릭 전송
  window.addEventListener("beforeunload", () => {
    metrics.timeOnPage = performance.now() - pageStartTime;
    metrics.lastImageLoad = performance.now() - pageStartTime;

    // 메트릭 전송
    navigator.sendBeacon("/api/metrics", JSON.stringify(metrics));
  });

  return metrics;
};
```

### 2. A/B 테스트를 통한 검증

**Lazy Loading 적용 전후 비교**:

```javascript
// utils/abTest.js
export const runLazyLoadingABTest = () => {
  const isLazyLoadingEnabled = Math.random() < 0.5; // 50% 확률

  if (isLazyLoadingEnabled) {
    // Lazy Loading 적용
    enableLazyLoading();
  } else {
    // 즉시 로딩 방식
    enableImmediateLoading();
  }

  // 성능 데이터 수집
  const performanceData = {
    variant: isLazyLoadingEnabled ? "lazy-loading" : "immediate-loading",
    metrics: {},
  };

  // Core Web Vitals 측정
  if ("PerformanceObserver" in window) {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === "largest-contentful-paint") {
          performanceData.metrics.lcp = entry.startTime;
        }
      });
    });

    observer.observe({ entryTypes: ["largest-contentful-paint"] });
  }

  // 페이지 로드 완료 시 데이터 전송
  window.addEventListener("load", () => {
    performanceData.metrics.loadTime = performance.now();

    // 분석 서버로 전송
    sendPerformanceData(performanceData);
  });

  return isLazyLoadingEnabled;
};

function enableLazyLoading() {
  // Lazy Loading 구현
  const lazyImages = document.querySelectorAll("img[data-src]");
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        imageObserver.unobserve(img);
      }
    });
  });

  lazyImages.forEach((img) => imageObserver.observe(img));
}

function enableImmediateLoading() {
  // 즉시 로딩 구현
  const lazyImages = document.querySelectorAll("img[data-src]");
  lazyImages.forEach((img) => {
    img.src = img.dataset.src;
  });
}
```

## ⚠️ 주의사항과 제한사항

### 1. SEO 고려사항

**검색 엔진 최적화**:

```html
<!-- SEO를 위한 메타데이터 -->
<head>
  <!-- 이미지 사이트맵 -->
  <link rel="image-sitemap" href="/image-sitemap.xml" />

  <!-- Open Graph 이미지 -->
  <meta property="og:image" content="https://example.com/images/product1.jpg" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />

  <!-- Twitter Card 이미지 -->
  <meta
    name="twitter:image"
    content="https://example.com/images/product1.jpg"
  />
</head>

<!-- 구조화된 데이터 -->
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Product",
    "name": "상품명",
    "image": "https://example.com/images/product1.jpg",
    "description": "상품 설명"
  }
</script>
```

**이미지 사이트맵 생성**:

```javascript
// utils/imageSitemapGenerator.js
export const generateImageSitemap = (images) => {
  const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:image="http://www.google.com/schemas/sitemap-image/1.1">
  ${images
    .map(
      (image) => `
  <url>
    <loc>${image.pageUrl}</loc>
    <image:image>
      <image:loc>${image.imageUrl}</image:loc>
      <image:title>${image.title}</image:title>
      <image:caption>${image.caption}</image:caption>
    </image:image>
  </url>
  `
    )
    .join("")}
</urlset>`;

  return sitemap;
};
```

### 2. 접근성 고려사항

**스크린 리더 지원**:

```html
<!-- 접근성을 위한 속성 추가 -->
<img
  data-src="images/product1.jpg"
  alt="상품 이미지 1 - 상세 설명"
  aria-describedby="product1-description"
  role="img"
  tabindex="0"
/>

<div id="product1-description" class="sr-only">
  이 상품은 고품질 소재로 제작되었으며, 다양한 색상과 사이즈를 제공합니다.
</div>

<!-- 로딩 상태 안내 -->
<div class="loading-indicator" aria-live="polite" aria-atomic="true">
  이미지 로딩 중...
</div>
```

**키보드 네비게이션 지원**:

```javascript
// utils/accessibility.js
export const enhanceKeyboardNavigation = () => {
  const lazyImages = document.querySelectorAll("img[data-src]");

  lazyImages.forEach((img) => {
    img.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        // 이미지 로딩 트리거
        loadImage(img);
      }
    });

    // 포커스 시 이미지 미리 로딩
    img.addEventListener("focus", () => {
      if (!img.src && img.dataset.src) {
        loadImage(img);
      }
    });
  });
};

function loadImage(img) {
  if (img.dataset.src) {
    img.src = img.dataset.src;
    img.classList.remove("lazy");
    img.classList.add("loaded");
  }
}
```

### 3. 브라우저 호환성

**지원 브라우저**:

- **Intersection Observer**: Chrome 51+, Firefox 55+, Safari 12.1+, Edge 79+
- **loading="lazy"**: Chrome 76+, Firefox 75+, Safari 15.4+, Edge 79+

**폴백 전략**:

```javascript
// utils/fallback.js
export const createLazyLoadingFallback = () => {
  // Intersection Observer 지원 확인
  if (!("IntersectionObserver" in window)) {
    return createScrollBasedFallback();
  }

  // loading="lazy" 지원 확인
  if (!("loading" in HTMLImageElement.prototype)) {
    return createIntersectionObserverFallback();
  }

  return createNativeLazyLoading();
};

function createScrollBasedFallback() {
  // 스크롤 이벤트 기반 폴백
  const lazyImages = document.querySelectorAll("img[data-src]");

  const handleScroll = throttle(() => {
    lazyImages.forEach((img) => {
      if (isElementInViewport(img)) {
        loadImage(img);
      }
    });
  }, 100);

  window.addEventListener("scroll", handleScroll);
  window.addEventListener("resize", handleScroll);

  // 초기 로드
  handleScroll();
}

function createIntersectionObserverFallback() {
  // Intersection Observer 기반 폴백
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        loadImage(img);
        imageObserver.unobserve(img);
      }
    });
  });

  document.querySelectorAll("img[data-src]").forEach((img) => {
    imageObserver.observe(img);
  });
}

function createNativeLazyLoading() {
  // 네이티브 lazy loading 사용
  document.querySelectorAll("img[data-src]").forEach((img) => {
    img.loading = "lazy";
    img.src = img.dataset.src;
  });
}

function isElementInViewport(el) {
  const rect = el.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <=
      (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

function throttle(func, limit) {
  let inThrottle;
  return function () {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}
```

## 🎯 실제 적용 사례

### 1. E-commerce 사이트

**상품 목록 페이지 최적화**:

```jsx
// components/ProductList.jsx
import React, { useState, useEffect } from "react";
import LazyImage from "./LazyImage";

function ProductList({ category }) {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchProducts(category);
  }, [category]);

  const fetchProducts = async (cat) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/products?category=${cat}`);
      const data = await response.json();
      setProducts(data);
    } catch (error) {
      console.error("상품 로딩 실패:", error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="product-list">
      {loading && <div className="loading">상품 로딩 중...</div>}

      <div className="product-grid">
        {products.map((product) => (
          <div key={product.id} className="product-card">
            <LazyImage
              src={product.image}
              alt={product.name}
              placeholder="/images/product-placeholder.jpg"
              className="product-image"
            />
            <h3>{product.name}</h3>
            <p className="price">{product.price.toLocaleString()}원</p>
          </div>
        ))}
      </div>
    </div>
  );
}

export default ProductList;
```

### 2. 블로그/뉴스 사이트

**기사 목록 페이지 최적화**:

```jsx
// components/ArticleList.jsx
import React from "react";
import LazyImage from "./LazyImage";

function ArticleList({ articles }) {
  return (
    <div className="article-list">
      {articles.map((article) => (
        <article key={article.id} className="article-card">
          <div className="article-image">
            <LazyImage
              src={article.featuredImage}
              alt={article.title}
              placeholder="/images/article-placeholder.jpg"
              className="article-thumbnail"
            />
          </div>

          <div className="article-content">
            <h2>{article.title}</h2>
            <p>{article.excerpt}</p>
            <div className="article-meta">
              <span>{article.author}</span>
              <span>{new Date(article.publishedAt).toLocaleDateString()}</span>
            </div>
          </div>
        </article>
      ))}
    </div>
  );
}

export default ArticleList;
```

## 📚 결론

Lazy Load는 웹 성능 최적화의 핵심 기법으로, 사용자 경험을 크게 향상시킬 수 있습니다.

**적용 시 고려사항**:

- **SEO 최적화**: 검색 엔진이 이미지를 인식할 수 있도록 적절한 메타데이터 제공
- **접근성**: 스크린 리더와 키보드 네비게이션 지원
- **브라우저 호환성**: 구형 브라우저를 위한 폴백 전략 수립
- **사용자 경험**: 로딩 상태 표시와 부드러운 전환 효과

**성공적인 적용을 위한 체크리스트**:

- [ ] Intersection Observer API 또는 폴백 구현
- [ ] 적절한 플레이스홀더 이미지 제공
- [ ] SEO를 위한 메타데이터 설정
- [ ] 접근성 가이드라인 준수
- [ ] 성능 측정 및 모니터링 체계 구축

Lazy Load를 적절히 적용하면 초기 페이지 로딩 시간을 크게 단축하고, 사용자에게 더 빠르고 반응성 좋은 웹 경험을 제공할 수 있습니다.
