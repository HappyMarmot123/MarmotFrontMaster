# 코드 스플리팅 (Code Splitting)

## 📖 개요

**코드 스플리팅(Code Splitting)**은 웹 애플리케이션의 JavaScript 번들을 여러 개의 작은 청크(chunk)로 나누어 필요할 때만 로드하는 기법입니다. 이를 통해 초기 번들 크기를 줄이고, 사용자가 실제로 필요로 하는 코드만 다운로드하여 웹 성능을 크게 향상시킬 수 있습니다.

## 🎯 코드 스플리팅의 필요성

### 1. 모놀리식 번들의 문제점

**기존 번들링 방식의 한계**:

- **초기 로딩 지연**: 모든 JavaScript 코드를 한 번에 다운로드해야 함
- **불필요한 코드 전송**: 사용하지 않는 기능의 코드도 함께 로드
- **캐싱 비효율성**: 일부 코드만 변경되어도 전체 번들 재다운로드
- **모바일 성능 저하**: 제한된 네트워크 환경에서 큰 파일 다운로드 지연

**실제 성능 영향**:

```javascript
// 모놀리식 번들의 문제
// 초기 번들 크기: 2.5MB
// First Contentful Paint: 4.2초
// Time to Interactive: 8.5초
// 모바일 3G 환경: 15초 이상
```

### 2. 코드 스플리팅의 해결책

**지연 로딩(Lazy Loading)**:

- 필요한 시점에만 코드 다운로드
- 초기 페이지 로딩 시간 단축
- 사용자 경험의 즉각적 개선

**성능 향상 효과**:

```javascript
// 코드 스플리팅 적용 후
// 초기 번들 크기: 450KB (82% 감소)
// First Contentful Paint: 1.8초 (57% 개선)
// Time to Interactive: 3.2초 (62% 개선)
// 모바일 3G 환경: 4.5초 (70% 개선)
```

## 🔧 코드 스플리팅 구현 방법

### 1. React에서의 동적 임포트

**React.lazy를 활용한 컴포넌트 지연 로딩**:

```jsx
// App.jsx
import React, { Suspense, lazy } from "react";
import LoadingSpinner from "./components/LoadingSpinner";

// 동적 임포트로 컴포넌트 지연 로딩
const Dashboard = lazy(() => import("./pages/Dashboard"));
const UserProfile = lazy(() => import("./pages/UserProfile"));
const Settings = lazy(() => import("./pages/Settings"));

function App() {
  const [currentPage, setCurrentPage] = useState("dashboard");

  const renderPage = () => {
    switch (currentPage) {
      case "dashboard":
        return <Dashboard />;
      case "profile":
        return <UserProfile />;
      case "settings":
        return <Settings />;
      default:
        return <Dashboard />;
    }
  };

  return (
    <div className="app">
      <nav>
        <button onClick={() => setCurrentPage("dashboard")}>대시보드</button>
        <button onClick={() => setCurrentPage("profile")}>프로필</button>
        <button onClick={() => setCurrentPage("settings")}>설정</button>
      </nav>

      <Suspense fallback={<LoadingSpinner />}>{renderPage()}</Suspense>
    </div>
  );
}

export default App;
```

**라우트 기반 코드 스플리팅**:

```jsx
// App.jsx with React Router
import React, { Suspense, lazy } from "react";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import LoadingSpinner from "./components/LoadingSpinner";

// 페이지별 동적 임포트
const Home = lazy(() => import("./pages/Home"));
const About = lazy(() => import("./pages/About"));
const Contact = lazy(() => import("./pages/Contact"));
const Blog = lazy(() => import("./pages/Blog"));
const BlogPost = lazy(() => import("./pages/BlogPost"));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/contact" element={<Contact />} />
          <Route path="/blog" element={<Blog />} />
          <Route path="/blog/:id" element={<BlogPost />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

export default App;
```

### 2. Vue.js에서의 코드 스플리팅

**Vue Router와 동적 임포트**:

```javascript
// router/index.js
import { createRouter, createWebHistory } from "vue-router";

const routes = [
  {
    path: "/",
    name: "Home",
    component: () => import("../views/Home.vue"),
  },
  {
    path: "/about",
    name: "About",
    component: () => import("../views/About.vue"),
  },
  {
    path: "/products",
    name: "Products",
    component: () => import("../views/Products.vue"),
  },
  {
    path: "/product/:id",
    name: "ProductDetail",
    component: () => import("../views/ProductDetail.vue"),
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;
```

**Vue 컴포넌트에서의 지연 로딩**:

```vue
<!-- App.vue -->
<template>
  <div id="app">
    <nav>
      <router-link to="/">홈</router-link>
      <router-link to="/about">소개</router-link>
      <router-link to="/products">상품</router-link>
    </nav>

    <router-view v-slot="{ Component }">
      <transition name="fade" mode="out-in">
        <component :is="Component" />
      </transition>
    </router-view>
  </div>
</template>

<script>
export default {
  name: "App",
};
</script>

<style>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s;
}
.fade-enter,
.fade-leave-to {
  opacity: 0;
}
</style>
```

### 3. Webpack을 활용한 고급 코드 스플리팅

**Entry Point 분할**:

```javascript
// webpack.config.js
const path = require("path");

module.exports = {
  entry: {
    main: "./src/main.js",
    vendor: "./src/vendor.js",
    admin: "./src/admin.js",
  },
  output: {
    filename: "[name].[contenthash].js",
    path: path.resolve(__dirname, "dist"),
    clean: true,
  },
  optimization: {
    splitChunks: {
      chunks: "all",
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: "vendors",
          chunks: "all",
        },
        common: {
          name: "common",
          minChunks: 2,
          chunks: "all",
          enforce: true,
        },
      },
    },
  },
};
```

**동적 임포트와 청크 네이밍**:

```javascript
// src/utils/lazyLoad.js
export const lazyLoadComponent = (importFunc, chunkName) => {
  return importFunc().then((module) => {
    // 청크 네이밍을 위한 주석
    // webpackChunkName: "chunkName"
    return module.default || module;
  });
};

// 사용 예시
const UserProfile = () =>
  lazyLoadComponent(
    () => import(/* webpackChunkName: "user-profile" */ "./pages/UserProfile"),
    "user-profile"
  );
```

## 🚀 고급 최적화 기법

### 1. 조건부 코드 스플리팅

**사용자 권한에 따른 조건부 로딩**:

```jsx
// components/ConditionalComponent.jsx
import React, { Suspense, lazy, useState, useEffect } from "react";

function ConditionalComponent({ userRole }) {
  const [AdminPanel, setAdminPanel] = useState(null);
  const [UserPanel, setUserPanel] = useState(null);

  useEffect(() => {
    if (userRole === "admin") {
      // 관리자 패널만 로드
      import("./AdminPanel").then((module) => {
        setAdminPanel(() => module.default);
      });
    } else {
      // 일반 사용자 패널만 로드
      import("./UserPanel").then((module) => {
        setUserPanel(() => module.default);
      });
    }
  }, [userRole]);

  if (userRole === "admin" && AdminPanel) {
    return (
      <Suspense fallback={<div>관리자 패널 로딩 중...</div>}>
        <AdminPanel />
      </Suspense>
    );
  }

  if (userRole === "user" && UserPanel) {
    return (
      <Suspense fallback={<div>사용자 패널 로딩 중...</div>}>
        <UserPanel />
      </Suspense>
    );
  }

  return <div>로딩 중...</div>;
}

export default ConditionalComponent;
```

**기능별 조건부 로딩**:

```jsx
// hooks/useFeatureFlag.js
import { useState, useEffect } from "react";

export const useFeatureFlag = (featureName) => {
  const [isEnabled, setIsEnabled] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // 기능 플래그 확인
    checkFeatureFlag(featureName).then((enabled) => {
      setIsEnabled(enabled);
      setIsLoading(false);
    });
  }, [featureName]);

  return { isEnabled, isLoading };
};

// 사용 예시
function App() {
  const { isEnabled: isAdvancedSearchEnabled, isLoading } =
    useFeatureFlag("advanced-search");

  if (isLoading) return <div>로딩 중...</div>;

  return (
    <div>
      <BasicSearch />
      {isAdvancedSearchEnabled && (
        <Suspense fallback={<div>고급 검색 로딩 중...</div>}>
          <AdvancedSearch />
        </Suspense>
      )}
    </div>
  );
}
```

### 2. 프리페칭(Preloading) 최적화

**사용자 행동 예측을 통한 프리페칭**:

```jsx
// hooks/usePrefetch.js
import { useCallback } from "react";

export const usePrefetch = () => {
  const prefetchComponent = useCallback((importFunc) => {
    // 마우스 호버 시 프리페칭
    importFunc();
  }, []);

  const prefetchOnHover = useCallback(
    (importFunc, delay = 100) => {
      let timeoutId;

      const handleMouseEnter = () => {
        timeoutId = setTimeout(() => {
          prefetchComponent(importFunc);
        }, delay);
      };

      const handleMouseLeave = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      };

      return { handleMouseEnter, handleMouseLeave };
    },
    [prefetchComponent]
  );

  return { prefetchComponent, prefetchOnHover };
};

// 사용 예시
function Navigation() {
  const { prefetchOnHover } = usePrefetch();

  const handleAboutHover = prefetchOnHover(() => import("../pages/About"));

  const handleContactHover = prefetchOnHover(() => import("../pages/Contact"));

  return (
    <nav>
      <a
        href="/about"
        onMouseEnter={handleAboutHover.handleMouseEnter}
        onMouseLeave={handleAboutHover.handleMouseLeave}
      >
        소개
      </a>
      <a
        href="/contact"
        onMouseEnter={handleContactHover.handleMouseEnter}
        onMouseLeave={handleContactHover.handleMouseLeave}
      >
        연락처
      </a>
    </nav>
  );
}
```

**라우트 기반 프리페칭**:

```jsx
// components/RoutePrefetcher.jsx
import { useEffect } from "react";
import { useLocation } from "react-router-dom";

const routePrefetchMap = {
  "/": () => import("../pages/Home"),
  "/about": () => import("../pages/About"),
  "/products": () => import("../pages/Products"),
  "/contact": () => import("../pages/Contact"),
};

function RoutePrefetcher() {
  const location = useLocation();

  useEffect(() => {
    // 현재 페이지와 관련된 다음 페이지들을 프리페치
    const prefetchRelatedRoutes = () => {
      const currentPath = location.pathname;

      // 관련 경로들을 프리페치
      if (currentPath === "/") {
        // 홈페이지에서는 소개와 상품 페이지 프리페치
        routePrefetchMap["/about"]();
        routePrefetchMap["/products"]();
      } else if (currentPath === "/products") {
        // 상품 페이지에서는 연락처 페이지 프리페치
        routePrefetchMap["/contact"]();
      }
    };

    // 페이지 로드 완료 후 프리페치
    const timer = setTimeout(prefetchRelatedRoutes, 1000);

    return () => clearTimeout(timer);
  }, [location.pathname]);

  return null; // 렌더링하지 않음
}

export default RoutePrefetcher;
```

### 3. 워커 기반 코드 스플리팅

**Web Worker를 활용한 백그라운드 로딩**:

```javascript
// workers/preloadWorker.js
self.onmessage = function (e) {
  const { type, modulePath } = e.data;

  if (type === "preload") {
    // 모듈 프리페칭
    import(modulePath)
      .then((module) => {
        self.postMessage({
          type: "preloadComplete",
          modulePath,
          success: true,
        });
      })
      .catch((error) => {
        self.postMessage({
          type: "preloadError",
          modulePath,
          error: error.message,
        });
      });
  }
};

// 메인 스레드에서 사용
const preloadWorker = new Worker("/workers/preloadWorker.js");

export const preloadModule = (modulePath) => {
  return new Promise((resolve, reject) => {
    const handleMessage = (e) => {
      if (
        e.data.type === "preloadComplete" &&
        e.data.modulePath === modulePath
      ) {
        preloadWorker.removeEventListener("message", handleMessage);
        resolve();
      } else if (
        e.data.type === "preloadError" &&
        e.data.modulePath === modulePath
      ) {
        preloadWorker.removeEventListener("message", handleMessage);
        reject(new Error(e.data.error));
      }
    };

    preloadWorker.addEventListener("message", handleMessage);
    preloadWorker.postMessage({ type: "preload", modulePath });
  });
};
```

## 📊 성능 측정과 분석

### 1. 번들 분석 도구

**Webpack Bundle Analyzer**:

```bash
# 번들 분석 도구 설치
npm install --save-dev webpack-bundle-analyzer

# webpack.config.js 설정
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: false,
      reportFilename: 'bundle-report.html'
    })
  ]
};

# 분석 실행
npm run build
# dist/bundle-report.html 파일이 생성됨
```

**React DevTools Profiler**:

```jsx
// 성능 프로파일링
import { Profiler } from "react";

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) {
  console.log({
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime,
  });
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      {/* 앱 컴포넌트들 */}
    </Profiler>
  );
}
```

### 2. 성능 메트릭 수집

**Core Web Vitals 측정**:

```javascript
// performance.js
import { getCLS, getFID, getFCP, getLCP, getTTFB } from "web-vitals";

function sendToAnalytics(metric) {
  // 성능 데이터를 분석 서버로 전송
  const data = {
    name: metric.name,
    value: metric.value,
    id: metric.id,
    timestamp: Date.now(),
  };

  // Google Analytics 또는 자체 분석 서버로 전송
  if (window.gtag) {
    window.gtag("event", metric.name, {
      value: Math.round(
        metric.name === "CLS" ? metric.value * 1000 : metric.value
      ),
      event_label: metric.id,
      non_interaction: true,
    });
  }
}

// 성능 메트릭 수집 시작
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

**사용자 정의 성능 측정**:

```javascript
// custom-metrics.js
export const measureCodeSplitting = () => {
  const metrics = {
    initialBundleSize: 0,
    lazyLoadedChunks: 0,
    totalLoadTime: 0,
  };

  // 초기 번들 크기 측정
  const initialChunks = performance
    .getEntriesByType("resource")
    .filter((entry) => entry.name.includes(".js"));

  metrics.initialBundleSize = initialChunks.reduce((total, chunk) => {
    return total + chunk.transferSize;
  }, 0);

  // 지연 로딩된 청크 수 측정
  let chunkCount = 0;
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach((entry) => {
      if (entry.name.includes(".js") && entry.initiatorType === "fetch") {
        chunkCount++;
        metrics.lazyLoadedChunks = chunkCount;
      }
    });
  });

  observer.observe({ entryTypes: ["resource"] });

  return metrics;
};
```

## ⚠️ 주의사항과 제한사항

### 1. 과도한 분할의 위험

**문제점**:

- 너무 작은 청크로 분할 시 HTTP 요청 수 증가
- 네트워크 오버헤드로 인한 성능 저하
- 브라우저의 동시 연결 수 제한에 따른 병목 현상

**해결책**:

```javascript
// webpack.config.js - 적절한 청크 크기 설정
module.exports = {
  optimization: {
    splitChunks: {
      minSize: 20000, // 20KB 이상
      maxSize: 244000, // 244KB 이하
      minChunks: 1,
      maxAsyncRequests: 30,
      maxInitialRequests: 30,
    },
  },
};
```

### 2. 캐싱 전략 고려

**캐싱 효율성**:

```javascript
// webpack.config.js - 캐싱 최적화
module.exports = {
  output: {
    filename: "[name].[contenthash].js",
    chunkFilename: "[name].[contenthash].js",
  },
  optimization: {
    moduleIds: "deterministic",
    chunkIds: "deterministic",
  },
};
```

**Service Worker를 활용한 캐싱**:

```javascript
// service-worker.js
const CACHE_NAME = "app-v1";
const STATIC_CACHE = "static-v1";
const DYNAMIC_CACHE = "dynamic-v1";

self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE).then((cache) => {
      return cache.addAll([
        "/",
        "/static/js/main.chunk.js",
        "/static/css/main.chunk.css",
      ]);
    })
  );
});

self.addEventListener("fetch", (event) => {
  if (event.request.url.includes(".js") || event.request.url.includes(".css")) {
    event.respondWith(
      caches.open(DYNAMIC_CACHE).then((cache) => {
        return cache.match(event.request).then((response) => {
          if (response) {
            return response;
          }

          return fetch(event.request).then((fetchResponse) => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});
```

### 3. 브라우저 호환성

**지원 브라우저**:

- Chrome 61+
- Firefox 60+
- Safari 10.1+
- Edge 79+

**폴백 전략**:

```javascript
// polyfill.js
if (!window.Promise) {
  // Promise 폴백
  window.Promise = require("es6-promise").Promise;
}

if (!window.fetch) {
  // Fetch API 폴백
  window.fetch = require("whatwg-fetch");
}

// 동적 임포트 폴백
if (!window.dynamicImport) {
  window.dynamicImport = (modulePath) => {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = modulePath;
      script.onload = () => resolve();
      script.onerror = reject;
      document.head.appendChild(script);
    });
  };
}
```

## 🎯 실제 적용 사례

### 1. E-commerce 사이트

**상품 카테고리별 코드 스플리팅**:

```jsx
// pages/Products.jsx
import React, { Suspense, lazy, useState } from "react";

const Electronics = lazy(() => import("../components/categories/Electronics"));
const Clothing = lazy(() => import("../components/categories/Clothing"));
const Books = lazy(() => import("../components/categories/Books"));

function Products() {
  const [selectedCategory, setSelectedCategory] = useState("electronics");

  const renderCategory = () => {
    switch (selectedCategory) {
      case "electronics":
        return <Electronics />;
      case "clothing":
        return <Clothing />;
      case "books":
        return <Books />;
      default:
        return <Electronics />;
    }
  };

  return (
    <div>
      <nav>
        <button onClick={() => setSelectedCategory("electronics")}>
          전자제품
        </button>
        <button onClick={() => setSelectedCategory("clothing")}>의류</button>
        <button onClick={() => setSelectedCategory("books")}>도서</button>
      </nav>

      <Suspense fallback={<div>카테고리 로딩 중...</div>}>
        {renderCategory()}
      </Suspense>
    </div>
  );
}

export default Products;
```

### 2. 관리자 대시보드

**권한별 기능 모듈 분할**:

```jsx
// components/AdminDashboard.jsx
import React, { Suspense, lazy, useEffect, useState } from "react";

const UserManagement = lazy(() => import("./admin/UserManagement"));
const Analytics = lazy(() => import("./admin/Analytics"));
const Settings = lazy(() => import("./admin/Settings"));

function AdminDashboard({ userRole }) {
  const [adminModules, setAdminModules] = useState([]);

  useEffect(() => {
    // 사용자 권한에 따라 필요한 모듈만 로드
    const loadModules = async () => {
      const modules = [];

      if (userRole === "super-admin") {
        modules.push(
          { name: "UserManagement", component: UserManagement },
          { name: "Analytics", component: Analytics },
          { name: "Settings", component: Settings }
        );
      } else if (userRole === "admin") {
        modules.push(
          { name: "UserManagement", component: UserManagement },
          { name: "Analytics", component: Analytics }
        );
      }

      setAdminModules(modules);
    };

    loadModules();
  }, [userRole]);

  return (
    <div className="admin-dashboard">
      {adminModules.map(({ name, component: Component }) => (
        <Suspense key={name} fallback={<div>{name} 로딩 중...</div>}>
          <Component />
        </Suspense>
      ))}
    </div>
  );
}

export default AdminDashboard;
```

## 📚 결론

코드 스플리팅은 현대 웹 애플리케이션의 성능 최적화에 필수적인 기법입니다.

**적용 시 고려사항**:

- **적절한 분할 수준**: 과도한 분할로 인한 성능 저하 방지
- **사용자 경험**: 로딩 상태 표시와 에러 처리
- **캐싱 전략**: 효율적인 리소스 재사용
- **브라우저 호환성**: 구형 브라우저를 위한 폴백 제공

**성공적인 적용을 위한 체크리스트**:

- [ ] 라우트 기반 코드 스플리팅 구현
- [ ] 컴포넌트별 지연 로딩 적용
- [ ] 프리페칭 전략 수립
- [ ] 번들 분석 및 최적화
- [ ] 성능 측정 및 모니터링 체계 구축

코드 스플리팅을 적절히 적용하면 초기 로딩 시간을 크게 단축하고, 사용자에게 더 빠르고 반응성 좋은 웹 경험을 제공할 수 있습니다.
