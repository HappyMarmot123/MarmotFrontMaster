# 이미지 최적화

## 📖 개요

**이미지 최적화**는 웹 성능 향상을 위한 핵심 기법으로, 대용량 이미지의 전송/디코딩/렌더링 비용을 줄여 LCP, CLS, FCP 등 핵심 지표를 개선합니다. 대부분의 사이트에서 이미지가 전체 전송량의 다수를 차지하므로, 올바른 포맷 선택과 반응형 제공, 지연 로딩, 적절한 캐싱은 체감 속도에 직접적인 영향을 줍니다.

**이미지 최적화가 중요한 이유**

- **네트워크 비용 절감**: 더 작은 파일로 더 빠른 전송
- **렌더링 안정성**: CLS 방지를 위한 치수/비율 관리
- **UX 개선**: 빠른 LCP, 부드러운 페인트, 깜빡임 최소화
- **운영 효율**: CDN/서버 변환으로 빌드·배포 파이프라인 단순화

## 🧭 전략 개요

- **올바른 포맷**: AVIF/WebP 우선, 폴백 제공
- **반응형 제공**: `srcset`/`sizes`로 해상도·레이아웃에 맞춰 다운로드
- **안정적 레이아웃**: `width`/`height` 또는 `aspect-ratio`로 CLS 방지
- **지연 로딩**: `loading="lazy"`, `decoding="async"`, `fetchpriority`
- **압축·리사이즈**: 서버/빌드 또는 CDN 파라미터로 동적 최적화
- **캐싱·선로딩**: Cache-Control, hero 이미지 `preload`
- **아트 디렉션**: `picture` + `media`로 상황별 크롭/구성 제공

## 🖼️ 포맷 선택(AVIF/WebP/JPEG/PNG/SVG)

**권장 원칙**

- 사진류: AVIF > WebP > JPEG(품질 0.75~0.85)
- 그래픽/아이콘: SVG(벡터) 또는 PNG(투명 필요 시)
- 브라우저 지원이 불확실하면 `picture`로 폴백 구성

```html
<picture>
  <source srcset="image.avif" type="image/avif" />
  <source srcset="image.webp" type="image/webp" />
  <img src="image.jpg" alt="설명" width="1200" height="800" />
</picture>
```

- AVIF: 최고 수준 압축, 색상/아티팩트 품질 우수(인코딩 비용↑)
- WebP: 폭넓은 지원, 손실/무손실 모두 가능
- JPEG/PNG: 레거시 호환, 품질 대비 용량↑(필요 시만)

## 📐 레이아웃 안정성(CLS 방지)

이미지의 고정 치수를 제공하거나 **비율**을 명시하면, 로드 전에 자리 잡기가 완료되어 레이아웃 점프(CLS)를 줄일 수 있습니다.

```html
<!-- 고정 치수 명시 -->
<img src="hero.jpg" alt="Hero" width="1280" height="720" />

<!-- 유동 레이아웃: 비율 유지 -->
<img
  src="card.jpg"
  alt="Card"
  style="aspect-ratio: 4 / 3; width: 100%; height: auto;"
/>
```

- `width`/`height` 속성은 CSS 크기를 강제하지 않으며, **내재 비율 계산용 메타**로도 활용됩니다
- 카드·그리드 등에서는 `aspect-ratio`가 간편하고 안정적입니다

## 📱 반응형 이미지(srcset/sizes)

같은 이미지를 다양한 해상도/레이아웃에 맞게 자동 선택하도록 합니다.

```html
<img
  src="image-800.jpg"
  srcset="image-400.jpg 400w, image-800.jpg 800w, image-1200.jpg 1200w"
  sizes="(max-width: 600px) 100vw, (max-width: 1200px) 50vw, 33vw"
  alt="반응형 이미지"
  width="1200"
  height="800"
/>
```

- `srcset`: 후보 이미지와 고유 너비를 선언
- `sizes`: 뷰포트 조건에 따른 실제 렌더 너비 예측값을 제공(다운로드 선택 정확도↑)
- 잘못된 `sizes`는 불필요한 큰 이미지를 받게 하므로, 레이아웃에 맞춰 주기적으로 점검

## 🎨 아트 디렉션(picture + media)

레이아웃/디바이스에 따라 구성을 변경해야 한다면 **아트 디렉션**이 필요합니다.

```html
<picture>
  <source media="(max-width: 768px)" srcset="image-mobile.jpg" />
  <source media="(max-width: 1200px)" srcset="image-tablet.jpg" />
  <img src="image-desktop.jpg" alt="아트 디렉션" width="1600" height="900" />
</picture>
```

- 단순 리사이즈가 아닌 **크롭·구성 변경**이 필요한 경우에만 사용

## 💤 지연 로딩/디코딩/우선순위

- `loading="lazy"`: 뷰포트 밖 이미지를 지연 로드(초기 네트워크 혼잡 감소)
- `decoding="async"`: 디코딩을 비동기화해 메인 스레드 블로킹 최소화
- `fetchpriority`: LCP 후보 이미지는 `high`, 지연 가능한 이미지는 `low`

```html
<!-- LCP 후보(위영역 히어로) -->
<link
  rel="preload"
  as="image"
  href="/hero.avif"
  imagesrcset="/hero.avif 1200w, /hero@2x.avif 2400w"
  imagesizes="100vw"
/>
<img
  src="/hero.avif"
  alt="Hero"
  fetchpriority="high"
  width="1280"
  height="720"
/>

<!-- 일반 콘텐츠 이미지 -->
<img
  src="/thumb.webp"
  alt="썸네일"
  loading="lazy"
  decoding="async"
  width="400"
  height="300"
/>
```

- `preload`는 **정말 필요한 소수의 핵심 이미지**에만 적용(과도 사용 시 역효과)

## 🧪 압축/리사이즈(서버·CDN·빌드)

- **서버/빌드**: Sharp, Squoosh, imagemin 등으로 리사이즈+품질 조정
- **CDN**: `?w=`, `?q=`, `?format=` 파라미터로 디바이스별 즉시 최적화
- **권장 품질 가이드**(대략)
  - JPEG: 0.75~0.85, WebP: 0.7~0.85, AVIF: 0.45~0.65(콘텐츠별 다름)
- **DPR 대응**: 1x/2x 모두를 `srcset`으로 제공(고해상도 화면 선명도↑)

```html
<img
  src="/cdn/image.jpg?w=800&q=80&fmt=webp"
  srcset="
    /cdn/image.jpg?w=800&q=80&fmt=webp  1x,
    /cdn/image.jpg?w=1600&q=75&fmt=webp 2x
  "
  alt="CDN 최적화"
  width="800"
  height="533"
/>
```

## 🟦 플레이스홀더(LQIP/Blurhash/지배색)

이미지 로딩 전 **저해상도 프리뷰**를 보여주면 지각적 체감 속도가 향상됩니다.

- LQIP: 아주 낮은 해상도의 흐릿한 프리뷰
- Blurhash: 짧은 문자열로 블러 패턴 표현(클라이언트에서 렌더)
- Dominant Color: 지배 색상으로 배경을 먼저 채움

```html
<img
  src="/tiny-blur.jpg"
  data-src="/real.jpg"
  class="lazy"
  style="filter: blur(12px);"
  alt="프리뷰"
/>
```

```js
// 교체 시 blur 제거(요약)
const img = document.querySelector("img.lazy");
img.addEventListener("load", () => (img.style.filter = "none"));
img.src = img.dataset.src;
```

## 🗃️ 캐싱과 헤더

- **Cache-Control**: 정적 이미지에 `immutable, max-age=31536000`(파일명에 해시 포함)
- **CDN 캐시 키**: 포맷/품질/크기 파라미터 포함하여 변형별 캐시 분리
- **Conditional**: ETag/Last-Modified로 재검증 비용 최소화

```http
Cache-Control: public, max-age=31536000, immutable
```

## 🔍 품질과 용량의 균형

- 지나친 압축은 **banding/블록 노이즈** 유발 → A/B로 시각 평가
- **세부가 많은 이미지**는 품질 손실 체감이 크므로 포맷/품질 수치 재조정
- UI 스크린샷/텍스트 포함 이미지 → PNG/SVG 검토(가독성 유지)

## 📊 모니터링과 검증

- **Core Web Vitals**: LCP 대상 이미지 식별 및 크기/우선순위/치수 명시 점검
- **프로덕션 리그레션 방지**: Lighthouse CI, bundlesize 유사 정책으로 임계치 초과 시 실패

```js
import { getLCP } from "web-vitals";
getLCP((m) => console.log("LCP", m.value));
```

## ✅ 체크리스트

- [ ] AVIF/WebP 우선 + JPEG/PNG 폴백
- [ ] `width/height` 또는 `aspect-ratio` 명시로 CLS 방지
- [ ] `srcset`/`sizes`로 반응형 제공, DPR 대응
- [ ] LCP 후보 `preload`/`fetchpriority=high`, 그 외 `loading="lazy"`/`decoding="async"`
- [ ] CDN/서버 리사이즈·압축 일원화, 품질 수치 검증
- [ ] Cache-Control 장기 캐싱(파일 해시), 조건부 재검증
- [ ] LCP/CLS 지표 상시 모니터링

## 📚 결론

이미지 최적화는 포맷·치수·전송·디코딩·캐싱을 아우르는 **엔드 투 엔드 작업**입니다. 위 전략을 체계적으로 적용하면 **LCP/CLS 개선, 트래픽 절감, 체감 속도 향상**을 동시에 달성할 수 있습니다. 코드보다 **정확한 선언(치수/반응형/우선순위)**과 **배포 파이프라인(CDN/캐시) 설계**가 성패를 가릅니다.
