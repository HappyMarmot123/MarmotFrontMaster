# 아트 디렉션 (Art Direction)

## 📖 개요

**아트 디렉션(Art Direction)**은 다양한 디바이스와 화면 크기에 맞춰 이미지의 시각적 구성을 최적화하는 기법입니다. 단순한 크기 조정이 아닌, 각 디바이스의 특성과 사용자 경험을 고려하여 이미지의 초점, 구도, 콘텐츠를 조정하는 고급 반응형 이미지 기법입니다.

## 🎯 아트 디렉션의 필요성

### 1. 단순 크기 조정의 한계

**기존 반응형 이미지의 문제점**:

- **구도 손실**: 작은 화면에서 중요한 요소가 잘리거나 축소됨
- **가독성 저하**: 모바일에서 텍스트나 세부 요소가 읽기 어려워짐
- **사용자 경험 악화**: 디바이스별 최적화되지 않은 이미지로 인한 불편함
- **브랜드 일관성 저하**: 화면 크기에 따라 이미지의 임팩트가 달라짐

**실제 문제 사례**:

```html
<!-- 단순 크기 조정만으로는 해결되지 않는 문제 -->
<img
  src="hero-image.jpg"
  srcset="
    hero-image-400w.jpg   400w,
    hero-image-800w.jpg   800w,
    hero-image-1200w.jpg 1200w
  "
  sizes="100vw"
  alt="히어로 이미지"
/>
<!-- 모바일에서는 중요한 텍스트가 잘리고, 
     데스크톱에서는 불필요한 여백이 생김 -->
```

### 2. 아트 디렉션의 해결책

**아트 디렉션의 이점**:

- **디바이스별 최적화**: 각 화면 크기에 맞는 최적의 이미지 구도 제공
- **사용자 경험 향상**: 모든 디바이스에서 일관된 시각적 임팩트 유지
- **콘텐츠 가독성**: 작은 화면에서도 중요한 요소가 명확하게 보임
- **브랜드 일관성**: 다양한 디바이스에서도 브랜드 이미지 유지

**최적화 효과**:

```javascript
// 아트 디렉션 적용 전후 비교
const artDirectionComparison = {
  before: {
    mobile: { readability: "낮음", userExperience: "나쁨", loadTime: "3.2초" },
    tablet: { readability: "보통", userExperience: "보통", loadTime: "2.8초" },
    desktop: { readability: "높음", userExperience: "좋음", loadTime: "2.1초" },
  },
  after: {
    mobile: { readability: "높음", userExperience: "좋음", loadTime: "2.1초" },
    tablet: { readability: "높음", userExperience: "좋음", loadTime: "1.9초" },
    desktop: { readability: "높음", userExperience: "좋음", loadTime: "1.8초" },
  },
};
```

## 🔧 아트 디렉션 구현 방법

### 1. HTML picture 요소 활용

**기본 아트 디렉션 구조**:

```html
<!-- 기본 아트 디렉션 구현 -->
<picture>
  <!-- 모바일용 이미지 (세로 구도, 주요 요소 중앙 배치) -->
  <source
    media="(max-width: 768px)"
    srcset="hero-mobile-400w.jpg 400w, hero-mobile-800w.jpg 800w"
    sizes="100vw"
  />

  <!-- 태블릿용 이미지 (가로 구도, 균형잡힌 구도) -->
  <source
    media="(max-width: 1200px)"
    srcset="hero-tablet-600w.jpg 600w, hero-tablet-1200w.jpg 1200w"
    sizes="100vw"
  />

  <!-- 데스크톱용 이미지 (가로 구도, 넓은 시야) -->
  <img
    src="hero-desktop-1200w.jpg"
    srcset="
      hero-desktop-800w.jpg   800w,
      hero-desktop-1200w.jpg 1200w,
      hero-desktop-1600w.jpg 1600w
    "
    sizes="100vw"
    alt="히어로 이미지 - 다양한 디바이스에 최적화"
  />
</picture>
```

**고급 아트 디렉션 (여러 이미지 소스)**:

```html
<!-- 복잡한 아트 디렉션 구현 -->
<picture>
  <!-- 모바일 세로 화면 -->
  <source
    media="(max-width: 480px) and (orientation: portrait)"
    srcset="hero-mobile-portrait-400w.jpg 400w"
    sizes="100vw"
  />

  <!-- 모바일 가로 화면 -->
  <source
    media="(max-width: 768px) and (orientation: landscape)"
    srcset="hero-mobile-landscape-600w.jpg 600w"
    sizes="100vw"
  />

  <!-- 태블릿 -->
  <source
    media="(min-width: 769px) and (max-width: 1024px)"
    srcset="hero-tablet-800w.jpg 800w, hero-tablet-1200w.jpg 1200w"
    sizes="100vw"
  />

  <!-- 데스크톱 -->
  <source
    media="(min-width: 1025px)"
    srcset="
      hero-desktop-1200w.jpg 1200w,
      hero-desktop-1600w.jpg 1600w,
      hero-desktop-2000w.jpg 2000w
    "
    sizes="100vw"
  />

  <!-- 폴백 이미지 -->
  <img src="hero-fallback.jpg" alt="히어로 이미지" loading="eager" />
</picture>
```

### 2. CSS를 활용한 아트 디렉션

**CSS 미디어 쿼리를 통한 이미지 전환**:

```css
/* CSS 기반 아트 디렉션 */
.hero-image {
  width: 100%;
  height: auto;
  object-fit: cover;
}

/* 모바일용 이미지 */
.hero-image {
  content: url("hero-mobile.jpg");
}

/* 태블릿용 이미지 */
@media (min-width: 769px) {
  .hero-image {
    content: url("hero-tablet.jpg");
  }
}

/* 데스크톱용 이미지 */
@media (min-width: 1025px) {
  .hero-image {
    content: url("hero-desktop.jpg");
  }
}

/* 고해상도 디스플레이 지원 */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .hero-image {
    content: url("hero-retina.jpg");
  }
}
```

**CSS Grid를 활용한 레이아웃 기반 아트 디렉션**:

```css
/* CSS Grid 기반 아트 디렉션 */
.hero-container {
  display: grid;
  grid-template-areas:
    "image"
    "content";
  gap: 1rem;
}

.hero-image {
  grid-area: image;
  width: 100%;
  height: 300px;
  object-fit: cover;
}

.hero-content {
  grid-area: content;
  padding: 1rem;
}

/* 태블릿 이상에서는 가로 배치 */
@media (min-width: 768px) {
  .hero-container {
    grid-template-areas: "image content";
    grid-template-columns: 1fr 1fr;
    align-items: center;
  }

  .hero-image {
    height: 400px;
  }
}

/* 데스크톱에서는 더 넓은 이미지 */
@media (min-width: 1200px) {
  .hero-container {
    grid-template-columns: 1.5fr 1fr;
  }

  .hero-image {
    height: 500px;
  }
}
```

### 3. JavaScript를 활용한 동적 아트 디렉션

**동적 이미지 전환 시스템**:

```javascript
// utils/artDirection.js
class ArtDirectionManager {
  constructor() {
    this.breakpoints = {
      mobile: 768,
      tablet: 1024,
      desktop: 1025,
    };

    this.imageSets = new Map();
    this.currentBreakpoint = null;
    this.init();
  }

  init() {
    this.detectBreakpoint();
    this.setupEventListeners();
    this.applyArtDirection();
  }

  detectBreakpoint() {
    const width = window.innerWidth;

    if (width <= this.breakpoints.mobile) {
      this.currentBreakpoint = "mobile";
    } else if (width <= this.breakpoints.tablet) {
      this.currentBreakpoint = "tablet";
    } else {
      this.currentBreakpoint = "desktop";
    }
  }

  setupEventListeners() {
    let resizeTimer;

    window.addEventListener("resize", () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        const newBreakpoint = this.getCurrentBreakpoint();

        if (newBreakpoint !== this.currentBreakpoint) {
          this.currentBreakpoint = newBreakpoint;
          this.applyArtDirection();
        }
      }, 250);
    });

    // 방향 변경 감지
    window.addEventListener("orientationchange", () => {
      setTimeout(() => {
        this.detectBreakpoint();
        this.applyArtDirection();
      }, 100);
    });
  }

  getCurrentBreakpoint() {
    const width = window.innerWidth;

    if (width <= this.breakpoints.mobile) {
      return "mobile";
    } else if (width <= this.breakpoints.tablet) {
      return "tablet";
    } else {
      return "desktop";
    }
  }

  registerImageSet(elementId, imageSet) {
    this.imageSets.set(elementId, imageSet);
  }

  applyArtDirection() {
    this.imageSets.forEach((imageSet, elementId) => {
      const element = document.getElementById(elementId);
      if (element && imageSet[this.currentBreakpoint]) {
        this.switchImage(element, imageSet[this.currentBreakpoint]);
      }
    });
  }

  switchImage(element, imageConfig) {
    if (element.tagName === "IMG") {
      // img 요소인 경우
      element.src = imageConfig.src;
      if (imageConfig.srcset) {
        element.srcset = imageConfig.srcset;
      }
      if (imageConfig.sizes) {
        element.sizes = imageConfig.sizes;
      }
    } else if (element.tagName === "PICTURE") {
      // picture 요소인 경우
      const img = element.querySelector("img");
      if (img) {
        img.src = imageConfig.src;
        if (imageConfig.srcset) {
          img.srcset = imageConfig.srcset;
        }
        if (imageConfig.sizes) {
          img.sizes = imageConfig.sizes;
        }
      }
    }

    // CSS 클래스 추가로 스타일링 지원
    element.className = element.className.replace(
      /art-direction-\w+/g,
      `art-direction-${this.currentBreakpoint}`
    );
  }

  // 성능 최적화를 위한 이미지 프리로딩
  preloadImages() {
    this.imageSets.forEach((imageSet) => {
      Object.values(imageSet).forEach((config) => {
        if (config.src) {
          const link = document.createElement("link");
          link.rel = "preload";
          link.as = "image";
          link.href = config.src;
          document.head.appendChild(link);
        }
      });
    });
  }
}

// 사용 예시
const artDirectionManager = new ArtDirectionManager();

// 이미지 세트 등록
artDirectionManager.registerImageSet("hero-image", {
  mobile: {
    src: "hero-mobile.jpg",
    srcset: "hero-mobile-400w.jpg 400w, hero-mobile-800w.jpg 800w",
    sizes: "100vw",
  },
  tablet: {
    src: "hero-tablet.jpg",
    srcset: "hero-tablet-600w.jpg 600w, hero-tablet-1200w.jpg 1200w",
    sizes: "100vw",
  },
  desktop: {
    src: "hero-desktop.jpg",
    srcset: "hero-desktop-1200w.jpg 1200w, hero-desktop-1600w.jpg 1600w",
    sizes: "100vw",
  },
});

// 이미지 프리로딩
artDirectionManager.preloadImages();
```

**React 컴포넌트에서의 활용**:

```jsx
// components/ArtDirectionImage.jsx
import React, { useState, useEffect, useRef } from "react";

function ArtDirectionImage({ imageSets, alt, className = "" }) {
  const [currentBreakpoint, setCurrentBreakpoint] = useState("desktop");
  const [currentImage, setCurrentImage] = useState(imageSets.desktop);
  const imageRef = useRef(null);

  useEffect(() => {
    const updateBreakpoint = () => {
      const width = window.innerWidth;
      let breakpoint = "desktop";

      if (width <= 768) {
        breakpoint = "mobile";
      } else if (width <= 1024) {
        breakpoint = "tablet";
      }

      if (breakpoint !== currentBreakpoint) {
        setCurrentBreakpoint(breakpoint);
        setCurrentImage(imageSets[breakpoint]);
      }
    };

    updateBreakpoint();
    window.addEventListener("resize", updateBreakpoint);

    return () => window.removeEventListener("resize", updateBreakpoint);
  }, [currentBreakpoint, imageSets]);

  return (
    <picture className={`art-direction-image ${className}`}>
      {/* 모바일용 이미지 */}
      <source
        media="(max-width: 768px)"
        srcSet={imageSets.mobile.srcset}
        sizes={imageSets.mobile.sizes}
      />

      {/* 태블릿용 이미지 */}
      <source
        media="(max-width: 1024px)"
        srcSet={imageSets.tablet.srcset}
        sizes={imageSets.tablet.sizes}
      />

      {/* 데스크톱용 이미지 (폴백) */}
      <img
        ref={imageRef}
        src={currentImage.src}
        srcSet={currentImage.srcset}
        sizes={currentImage.sizes}
        alt={alt}
        className={`art-direction-img art-direction-${currentBreakpoint}`}
        loading="lazy"
      />
    </picture>
  );
}

// 사용 예시
function HeroSection() {
  const heroImageSets = {
    mobile: {
      src: "/images/hero-mobile.jpg",
      srcset:
        "/images/hero-mobile-400w.jpg 400w, /images/hero-mobile-800w.jpg 800w",
      sizes: "100vw",
    },
    tablet: {
      src: "/images/hero-tablet.jpg",
      srcset:
        "/images/hero-tablet-600w.jpg 600w, /images/hero-tablet-1200w.jpg 1200w",
      sizes: "100vw",
    },
    desktop: {
      src: "/images/hero-desktop.jpg",
      srcset:
        "/images/hero-desktop-1200w.jpg 1200w, /images/hero-desktop-1600w.jpg 1600w",
      sizes: "100vw",
    },
  };

  return (
    <section className="hero">
      <ArtDirectionImage
        imageSets={heroImageSets}
        alt="히어로 이미지 - 다양한 디바이스에 최적화"
        className="hero-image"
      />
      <div className="hero-content">
        <h1>아트 디렉션으로 최적화된 이미지</h1>
        <p>각 디바이스에 맞는 최적의 이미지 경험을 제공합니다.</p>
      </div>
    </section>
  );
}

export default HeroSection;
```

## 🚀 고급 아트 디렉션 기법

### 1. 컨텍스트 기반 아트 디렉션

**사용자 행동과 환경을 고려한 이미지 선택**:

```javascript
// utils/contextualArtDirection.js
class ContextualArtDirection {
  constructor() {
    this.context = {
      deviceType: this.detectDeviceType(),
      connectionSpeed: this.detectConnectionSpeed(),
      userPreferences: this.getUserPreferences(),
      timeOfDay: this.getTimeOfDay(),
      location: null,
    };

    this.init();
  }

  async init() {
    await this.detectLocation();
    this.applyContextualImages();
  }

  detectDeviceType() {
    const userAgent = navigator.userAgent;

    if (
      /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)
    ) {
      return "mobile";
    } else if (/iPad|Android/i.test(userAgent)) {
      return "tablet";
    } else {
      return "desktop";
    }
  }

  detectConnectionSpeed() {
    if ("connection" in navigator) {
      const connection = navigator.connection;

      if (
        connection.effectiveType === "slow-2g" ||
        connection.effectiveType === "2g"
      ) {
        return "slow";
      } else if (connection.effectiveType === "3g") {
        return "medium";
      } else {
        return "fast";
      }
    }

    return "unknown";
  }

  getUserPreferences() {
    // 사용자 설정에서 이미지 품질 선호도 가져오기
    const savedPreference = localStorage.getItem("imageQualityPreference");
    return savedPreference || "balanced";
  }

  getTimeOfDay() {
    const hour = new Date().getHours();

    if (hour >= 6 && hour < 12) {
      return "morning";
    } else if (hour >= 12 && hour < 18) {
      return "afternoon";
    } else if (hour >= 18 && hour < 22) {
      return "evening";
    } else {
      return "night";
    }
  }

  async detectLocation() {
    if ("geolocation" in navigator) {
      try {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            timeout: 5000,
            enableHighAccuracy: false,
          });
        });

        this.context.location = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        };
      } catch (error) {
        console.log("위치 정보를 가져올 수 없습니다:", error);
      }
    }
  }

  getOptimalImageSet(imageSets) {
    const { deviceType, connectionSpeed, userPreferences, timeOfDay } =
      this.context;

    // 연결 속도에 따른 이미지 품질 조정
    let quality = "high";
    if (connectionSpeed === "slow") {
      quality = "low";
    } else if (connectionSpeed === "medium") {
      quality = "medium";
    }

    // 사용자 선호도 반영
    if (userPreferences === "highQuality") {
      quality = "high";
    } else if (userPreferences === "fastLoading") {
      quality = "low";
    }

    // 시간대별 이미지 선택 (예: 야간 모드)
    let timeVariant = "";
    if (timeOfDay === "night") {
      timeVariant = "-dark";
    }

    // 디바이스별 최적 이미지 선택
    const deviceImage = imageSets[deviceType] || imageSets.desktop;

    return {
      ...deviceImage,
      quality,
      timeVariant,
      src: this.adjustImageUrl(deviceImage.src, quality, timeVariant),
    };
  }

  adjustImageUrl(baseUrl, quality, timeVariant) {
    let url = baseUrl;

    // 품질 조정
    if (quality === "low") {
      url = url.replace(/\.(jpg|png|webp)/, "-low.$1");
    } else if (quality === "medium") {
      url = url.replace(/\.(jpg|png|webp)/, "-medium.$1");
    }

    // 시간대별 변형
    if (timeVariant) {
      url = url.replace(/\.(jpg|png|webp)/, `${timeVariant}.$1`);
    }

    return url;
  }

  applyContextualImages() {
    const artDirectionElements = document.querySelectorAll(
      "[data-contextual-art-direction]"
    );

    artDirectionElements.forEach((element) => {
      const imageSetName = element.dataset.contextualArtDirection;
      const imageSets = window.imageSets[imageSetName];

      if (imageSets) {
        const optimalImage = this.getOptimalImageSet(imageSets);
        this.updateImage(element, optimalImage);
      }
    });
  }

  updateImage(element, imageConfig) {
    if (element.tagName === "IMG") {
      element.src = imageConfig.src;
      element.className = `contextual-image contextual-${imageConfig.quality}`;
    }
  }
}

// 사용 예시
const contextualArtDirection = new ContextualArtDirection();

// 전역 이미지 세트 정의
window.imageSets = {
  hero: {
    mobile: {
      src: "/images/hero-mobile.jpg",
      srcset:
        "/images/hero-mobile-400w.jpg 400w, /images/hero-mobile-800w.jpg 800w",
    },
    tablet: {
      src: "/images/hero-tablet.jpg",
      srcset:
        "/images/hero-tablet-600w.jpg 600w, /images/hero-tablet-1200w.jpg 1200w",
    },
    desktop: {
      src: "/images/hero-desktop.jpg",
      srcset:
        "/images/hero-desktop-1200w.jpg 1200w, /images/hero-desktop-1600w.jpg 1600w",
    },
  },
};
```

### 2. AI 기반 아트 디렉션

**머신러닝을 활용한 자동 이미지 최적화**:

```javascript
// utils/aiArtDirection.js
class AIArtDirection {
  constructor() {
    this.aiModel = null;
    this.imageAnalysisQueue = [];
    this.init();
  }

  async init() {
    try {
      // TensorFlow.js 모델 로드
      this.aiModel = await tf.loadLayersModel(
        "/models/art-direction-model.json"
      );
      console.log("AI 아트 디렉션 모델 로드 완료");
    } catch (error) {
      console.error("AI 모델 로드 실패:", error);
    }
  }

  async analyzeImage(imageElement) {
    if (!this.aiModel) {
      return null;
    }

    try {
      // 이미지를 텐서로 변환
      const tensor = tf.browser.fromPixels(imageElement);
      const resized = tf.image.resizeBilinear(tensor, [224, 224]);
      const normalized = resized.div(255.0);
      const batched = normalized.expandDims(0);

      // AI 모델로 이미지 분석
      const prediction = await this.aiModel.predict(batched).array();

      // 메모리 정리
      tensor.dispose();
      resized.dispose();
      normalized.dispose();
      batched.dispose();

      return this.interpretPrediction(prediction[0]);
    } catch (error) {
      console.error("이미지 분석 실패:", error);
      return null;
    }
  }

  interpretPrediction(prediction) {
    // AI 모델의 예측 결과를 해석
    const [composition, focus, style] = prediction;

    return {
      composition: this.getCompositionType(composition),
      focus: this.getFocusArea(focus),
      style: this.getStyleType(style),
      recommendedCrop: this.getRecommendedCrop(composition, focus),
    };
  }

  getCompositionType(value) {
    if (value < 0.33) return "portrait";
    if (value < 0.66) return "landscape";
    return "square";
  }

  getFocusArea(value) {
    if (value < 0.25) return "center";
    if (value < 0.5) return "left";
    if (value < 0.75) return "right";
    return "distributed";
  }

  getStyleType(value) {
    if (value < 0.33) return "minimal";
    if (value < 0.66) return "balanced";
    return "complex";
  }

  getRecommendedCrop(composition, focus) {
    // 구성과 초점을 기반으로 권장 크롭 영역 계산
    const crops = {
      portrait: {
        center: { x: 0.2, y: 0.1, width: 0.6, height: 0.8 },
        left: { x: 0.1, y: 0.1, width: 0.6, height: 0.8 },
        right: { x: 0.3, y: 0.1, width: 0.6, height: 0.8 },
      },
      landscape: {
        center: { x: 0.1, y: 0.2, width: 0.8, height: 0.6 },
        left: { x: 0.05, y: 0.2, width: 0.8, height: 0.6 },
        right: { x: 0.15, y: 0.2, width: 0.8, height: 0.6 },
      },
    };

    return crops[composition]?.[focus] || crops.portrait.center;
  }

  async optimizeImageForDevice(imageElement, deviceType, analysis) {
    if (!analysis) {
      return imageElement.src;
    }

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    // 디바이스별 최적 크기 설정
    const deviceSizes = {
      mobile: { width: 400, height: 600 },
      tablet: { width: 800, height: 600 },
      desktop: { width: 1200, height: 800 },
    };

    const targetSize = deviceSizes[deviceType];
    canvas.width = targetSize.width;
    canvas.height = targetSize.height;

    // AI 분석 결과를 기반으로 이미지 크롭 및 조정
    const crop = analysis.recommendedCrop;
    const sourceWidth = imageElement.naturalWidth;
    const sourceHeight = imageElement.naturalHeight;

    const cropX = crop.x * sourceWidth;
    const cropY = crop.y * sourceHeight;
    const cropWidth = crop.width * sourceWidth;
    const cropHeight = crop.height * sourceHeight;

    ctx.drawImage(
      imageElement,
      cropX,
      cropY,
      cropWidth,
      cropHeight,
      0,
      0,
      targetSize.width,
      targetSize.height
    );

    // 최적화된 이미지 URL 반환
    return canvas.toDataURL("image/webp", 0.8);
  }

  async processImageQueue() {
    while (this.imageAnalysisQueue.length > 0) {
      const { imageElement, deviceType, callback } =
        this.imageAnalysisQueue.shift();

      const analysis = await this.analyzeImage(imageElement);
      const optimizedUrl = await this.optimizeImageForDevice(
        imageElement,
        deviceType,
        analysis
      );

      if (callback) {
        callback(optimizedUrl, analysis);
      }
    }
  }

  queueImageAnalysis(imageElement, deviceType, callback) {
    this.imageAnalysisQueue.push({ imageElement, deviceType, callback });
    this.processImageQueue();
  }
}

// 사용 예시
const aiArtDirection = new AIArtDirection();

// 이미지 최적화 요청
document.querySelectorAll("[data-ai-optimize]").forEach((element) => {
  const deviceType = element.dataset.deviceType || "desktop";

  aiArtDirection.queueImageAnalysis(
    element,
    deviceType,
    (optimizedUrl, analysis) => {
      console.log("AI 최적화 완료:", analysis);
      element.src = optimizedUrl;
    }
  );
});
```

## 📊 성능 측정과 최적화

### 1. 아트 디렉션 성능 측정

**이미지 전환 성능 분석**:

```javascript
// utils/artDirectionPerformance.js
export const measureArtDirectionPerformance = () => {
  const metrics = {
    imageSwitchTimes: [],
    layoutShifts: [],
    userExperience: {},
  };

  // 이미지 전환 시간 측정
  const measureImageSwitch = (oldSrc, newSrc) => {
    const startTime = performance.now();

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const switchTime = performance.now() - startTime;
        metrics.imageSwitchTimes.push(switchTime);
        resolve(switchTime);
      };
      img.src = newSrc;
    });
  };

  // 레이아웃 시프트 측정
  if ("PerformanceObserver" in window) {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === "layout-shift") {
          metrics.layoutShifts.push(entry.value);
        }
      });
    });

    observer.observe({ entryTypes: ["layout-shift"] });
  }

  // 사용자 경험 메트릭 수집
  const collectUXMetrics = () => {
    metrics.userExperience = {
      viewportWidth: window.innerWidth,
      viewportHeight: window.innerHeight,
      devicePixelRatio: window.devicePixelRatio,
      connectionType: navigator.connection?.effectiveType || "unknown",
    };
  };

  // 초기 메트릭 수집
  collectUXMetrics();

  // 리사이즈 시 메트릭 업데이트
  window.addEventListener("resize", collectUXMetrics);

  return {
    metrics,
    measureImageSwitch,
    getAverageSwitchTime: () => {
      if (metrics.imageSwitchTimes.length === 0) return 0;
      return (
        metrics.imageSwitchTimes.reduce((a, b) => a + b, 0) /
        metrics.imageSwitchTimes.length
      );
    },
    getLayoutShiftScore: () => {
      if (metrics.layoutShifts.length === 0) return 0;
      return metrics.layoutShifts.reduce((a, b) => a + b, 0);
    },
  };
};
```

### 2. A/B 테스트를 통한 검증

**아트 디렉션 효과 검증**:

```javascript
// utils/artDirectionABTest.js
export const runArtDirectionABTest = () => {
  const isArtDirectionEnabled = Math.random() < 0.5; // 50% 확률

  const testConfig = {
    variant: isArtDirectionEnabled ? "art-direction" : "standard-responsive",
    startTime: performance.now(),
    metrics: {},
  };

  if (isArtDirectionEnabled) {
    enableArtDirection();
  } else {
    enableStandardResponsive();
  }

  // 성능 메트릭 수집
  const collectMetrics = () => {
    if ("PerformanceObserver" in window) {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === "largest-contentful-paint") {
            testConfig.metrics.lcp = entry.startTime;
          } else if (entry.entryType === "first-contentful-paint") {
            testConfig.metrics.fcp = entry.startTime;
          }
        });
      });

      observer.observe({
        entryTypes: ["largest-contentful-paint", "first-contentful-paint"],
      });
    }
  };

  // 페이지 로드 완료 시 테스트 결과 전송
  window.addEventListener("load", () => {
    testConfig.metrics.loadTime = performance.now() - testConfig.startTime;

    // 테스트 결과 전송
    sendABTestResults(testConfig);
  });

  collectMetrics();
  return testConfig.variant;
};

function enableArtDirection() {
  // 아트 디렉션 활성화
  document.querySelectorAll("[data-art-direction]").forEach((element) => {
    element.style.display = "block";
  });

  // 표준 반응형 이미지 숨김
  document.querySelectorAll("[data-standard-responsive]").forEach((element) => {
    element.style.display = "none";
  });
}

function enableStandardResponsive() {
  // 표준 반응형 이미지 활성화
  document.querySelectorAll("[data-standard-responsive]").forEach((element) => {
    element.style.display = "block";
  });

  // 아트 디렉션 이미지 숨김
  document.querySelectorAll("[data-art-direction]").forEach((element) => {
    element.style.display = "none";
  });
}

function sendABTestResults(testConfig) {
  // 분석 서버로 테스트 결과 전송
  navigator.sendBeacon("/api/ab-test-results", JSON.stringify(testConfig));
}
```

## ⚠️ 주의사항과 제한사항

### 1. 구현 시 고려사항

**성능과 사용자 경험의 균형**:

- **이미지 전환 지연**: 아트 디렉션으로 인한 이미지 전환 지연 최소화
- **메모리 사용량**: 여러 이미지 세트로 인한 메모리 사용량 관리
- **네트워크 부하**: 불필요한 이미지 다운로드 방지

**접근성 고려사항**:

```html
<!-- 스크린 리더를 위한 적절한 설명 -->
<picture>
  <source media="(max-width: 768px)" srcset="hero-mobile.jpg" />
  <source media="(min-width: 769px)" srcset="hero-desktop.jpg" />
  <img
    src="hero-desktop.jpg"
    alt="히어로 이미지 - 모바일에서는 세로 구도, 데스크톱에서는 가로 구도로 최적화"
  />
</picture>

<!-- 아트 디렉션 변경 사항 안내 -->
<div class="art-direction-info" aria-live="polite">
  <span class="sr-only">이미지가 화면 크기에 맞게 최적화되었습니다.</span>
</div>
```

### 2. 브라우저 호환성

**지원 브라우저**:

- **picture 요소**: Chrome 38+, Firefox 38+, Safari 9.1+, Edge 12+
- **srcset/sizes**: Chrome 34+, Firefox 38+, Safari 8+, Edge 12+

**폴백 전략**:

```html
<!-- 구형 브라우저를 위한 폴백 -->
<picture>
  <source srcset="hero.webp" type="image/webp" />
  <source srcset="hero.jpg" type="image/jpeg" />
  <img src="hero.jpg" alt="히어로 이미지" />
</picture>

<!-- JavaScript 폴백 -->
<script>
  if (!("HTMLPictureElement" in window)) {
    // picture 요소를 지원하지 않는 경우
    const pictures = document.querySelectorAll("picture");
    pictures.forEach((picture) => {
      const img = picture.querySelector("img");
      if (img) {
        picture.parentNode.insertBefore(img, picture);
        picture.remove();
      }
    });
  }
</script>
```

## 🎯 실제 적용 사례

### 1. E-commerce 사이트

**상품 이미지 아트 디렉션**:

```jsx
// components/ProductImage.jsx
import React from "react";

function ProductImage({ product, view = "grid" }) {
  const getImageSets = () => {
    const baseUrl = product.imageBaseUrl;

    return {
      mobile: {
        src: `${baseUrl}-mobile.jpg`,
        srcset: `${baseUrl}-mobile-400w.jpg 400w, ${baseUrl}-mobile-800w.jpg 800w`,
        sizes: view === "grid" ? "50vw" : "100vw",
      },
      tablet: {
        src: `${baseUrl}-tablet.jpg`,
        srcset: `${baseUrl}-tablet-600w.jpg 600w, ${baseUrl}-tablet-1200w.jpg 1200w`,
        sizes: view === "grid" ? "33vw" : "100vw",
      },
      desktop: {
        src: `${baseUrl}-desktop.jpg`,
        srcset: `${baseUrl}-desktop-800w.jpg 800w, ${baseUrl}-desktop-1200w.jpg 1200w`,
        sizes: view === "grid" ? "25vw" : "100vw",
      },
    };
  };

  const imageSets = getImageSets();

  return (
    <picture className={`product-image product-image-${view}`}>
      <source
        media="(max-width: 768px)"
        srcSet={imageSets.mobile.srcset}
        sizes={imageSets.mobile.sizes}
      />
      <source
        media="(max-width: 1024px)"
        srcSet={imageSets.tablet.srcset}
        sizes={imageSets.tablet.sizes}
      />
      <img
        src={imageSets.desktop.src}
        srcSet={imageSets.desktop.srcset}
        sizes={imageSets.desktop.sizes}
        alt={product.name}
        loading="lazy"
      />
    </picture>
  );
}

export default ProductImage;
```

### 2. 뉴스/블로그 사이트

**기사 썸네일 아트 디렉션**:

```jsx
// components/ArticleThumbnail.jsx
import React from "react";

function ArticleThumbnail({ article, layout = "list" }) {
  const getThumbnailSets = () => {
    const baseUrl = article.thumbnailBaseUrl;

    return {
      mobile: {
        src: `${baseUrl}-mobile.jpg`,
        srcset: `${baseUrl}-mobile-300w.jpg 300w, ${baseUrl}-mobile-600w.jpg 600w`,
        sizes: layout === "grid" ? "100vw" : "100vw",
      },
      tablet: {
        src: `${baseUrl}-tablet.jpg`,
        srcset: `${baseUrl}-tablet-400w.jpg 400w, ${baseUrl}-tablet-800w.jpg 800w`,
        sizes: layout === "grid" ? "50vw" : "100vw",
      },
      desktop: {
        src: `${baseUrl}-desktop.jpg`,
        srcset: `${baseUrl}-desktop-600w.jpg 600w, ${baseUrl}-desktop-1200w.jpg 1200w`,
        sizes: layout === "grid" ? "33vw" : "100vw",
      },
    };
  };

  const thumbnailSets = getThumbnailSets();

  return (
    <div className={`article-thumbnail article-thumbnail-${layout}`}>
      <picture>
        <source
          media="(max-width: 768px)"
          srcSet={thumbnailSets.mobile.srcset}
          sizes={thumbnailSets.mobile.sizes}
        />
        <source
          media="(max-width: 1024px)"
          srcSet={thumbnailSets.tablet.srcset}
          sizes={thumbnailSets.tablet.sizes}
        />
        <img
          src={thumbnailSets.desktop.src}
          srcSet={thumbnailSets.desktop.srcset}
          sizes={thumbnailSets.desktop.sizes}
          alt={article.title}
          loading="lazy"
        />
      </picture>
    </div>
  );
}

export default ArticleThumbnail;
```

## 📚 결론

아트 디렉션은 단순한 이미지 크기 조정을 넘어서, 각 디바이스와 사용자 상황에 최적화된 시각적 경험을 제공하는 고급 웹 최적화 기법입니다.

**성공적인 아트 디렉션 구현을 위한 체크리스트**:

- [ ] 디바이스별 이미지 구도 최적화
- [ ] HTML picture 요소 활용
- [ ] CSS 미디어 쿼리와 JavaScript 동적 전환
- [ ] 성능 측정 및 모니터링
- [ ] 접근성 가이드라인 준수
- [ ] 브라우저 호환성 및 폴백 전략

**아트 디렉션의 효과**:

- **사용자 경험**: 모든 디바이스에서 일관된 시각적 임팩트
- **성능**: 디바이스별 최적화된 이미지로 로딩 시간 단축
- **브랜드 일관성**: 다양한 화면에서도 브랜드 이미지 유지
- **접근성**: 작은 화면에서도 중요한 콘텐츠 가독성 향상

적절한 아트 디렉션을 통해 웹사이트의 시각적 품질을 크게 향상시키고, 모든 디바이스에서 최적의 사용자 경험을 제공할 수 있습니다.
