# 커맨드 (Command)

## 개요

커맨드(Command) 패턴은 요창자와 수신자를 분리하는 패턴입니다.

**요청(명령)을 객체로 캡슐화하여 보내는데 좀 더 유연한 기능 구현이 가능해집니다.**

## 프론트엔드 활용 아이디어

- **실행 취소/다시 실행**: 에디터, 그림판, 폼 편집
- **매크로/배치 작업**: 여러 명령을 묶어서 실행
- **이벤트 처리**: 사용자 액션을 명령 객체로 캡슐화

## 백엔드/전체 활용 아이디어

- **작업 큐**: 비동기 작업 처리, 재시도/취소
- **트랜잭션**: 데이터베이스 작업 롤백/커밋
- **API 버전 관리**: 명령 객체로 API 호환성 유지

## 구조

- Command(명령 인터페이스)
- ConcreteCommand(구체 명령)
- Invoker(명령 실행자)
- Receiver(명령 수행자)

## 장단점

- **장점**: 되돌리기/매크로/히스토리 용이, 결합도 감소
- **단점**: 클래스 수 증가

## 구현 팁

- 명령 객체는 불변으로 만들어 재사용성 확보
- 실행/취소 로직을 명령 객체 내부에 캡슐화

## JavaScript 예제 (주석 포함)

```javascript
class Light {
  on() {
    console.log("ON");
  }
  off() {
    console.log("OFF");
  }
}
class OnCommand {
  constructor(l) {
    this.l = l;
  }
  execute() {
    this.l.on();
  }
  undo() {
    this.l.off();
  }
}
class OffCommand {
  constructor(l) {
    this.l = l;
  }
  execute() {
    this.l.off();
  }
  undo() {
    this.l.on();
  }
}

class Remote {
  constructor() {
    this.history = [];
  }
  press(cmd) {
    cmd.execute();
    this.history.push(cmd);
  }
  undo() {
    const cmd = this.history.pop();
    cmd?.undo();
  }
}

const remote = new Remote();
const light = new Light();
remote.press(new OnCommand(light));
remote.press(new OffCommand(light));
remote.undo(); // 되돌리기 → ON
```
