# 빌더 (Builder)

## 개요

- **문제**: 생성자 파라미터 과다/순서 오류, 복잡한 조립 로직이 객체 외부에 난립
- **해법**: 생성 과정을 단계로 분리하고 순서를 Director가 통제하여 가독성과 안전성을 높임

## 프론트엔드 활용 아이디어

- **URL/QueryString 빌더**: 필터/정렬/페이지 파라미터 조립
- **FormData 빌더**: 멀티파트 업로드 구성
- **className/style 빌더**: 조건부 스타일 안전 조립

## 백엔드/전체 활용 아이디어

- **쿼리 빌더**: SQL 쿼리 단계적 구성
- **API 요청**: 복잡한 요청 페이로드 단계적 구성
- **설정 객체**: 옵션이 많은 설정 객체 생성

## 구조

- Builder(단계 API), ConcreteBuilder(단계 구현/결과 보유)
- Director(절차/순서 통제), Product(완성 결과)

## 장단점

- **장점**: 생성 절차와 결과 분리, 단계별 유효성 검증, 가독성 향상
- **단점**: 보일러플레이트 증가, 단순 객체에는 과도

## 구현 팁

- 불변 객체를 원하면 build() 후 내부 상태 초기화로 재사용 가능
- 필수 단계는 Director에서 강제

## JavaScript 예제 (주석 포함)

```javascript
class QueryBuilder {
  constructor() {
    this._select = [];
    this._from = "";
    this._where = [];
  }
  select(...cols) {
    this._select.push(...cols);
    return this;
  } // 체이닝 지원
  from(table) {
    this._from = table;
    return this;
  }
  where(cond) {
    this._where.push(cond);
    return this;
  }
  build() {
    // 최종 문자열 조립(부작용 없이 생성)
    const s = `SELECT ${this._select.join(", ") || "*"} FROM ${this._from}`;
    const w = this._where.length ? ` WHERE ${this._where.join(" AND ")}` : "";
    return s + w;
  }
}

// Director를 별도로 둘 수도 있으나 간단 예시는 생략
const sql = new QueryBuilder()
  .select("id", "name")
  .from("users")
  .where("active=1")
  .build();
console.log(sql);
```
