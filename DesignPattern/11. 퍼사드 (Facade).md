# 퍼사드 (Facade)

## 개요

- **문제**: 서브시스템이 복잡하여 사용자가 여러 모듈을 순서·규약에 맞게 호출해야 한다.
- **해법**: 단일 진입점(Facade)에서 쉬운 API를 노출하고 내부 조합을 캡슐화한다.언제 쓰나

## 프론트엔드 활용 아이디어

- 앱 초기화 퍼사드: 설정 로드 → 인증 복구 → 라우터 준비 → 렌더까지 일괄 처리
- 미디어 업로드 퍼사드: 리사이즈/압축/전송/진행률/취소 API 단일화
- 데이터 접근 퍼사드: 캐시(메모리/IndexedDB)/네트워크/동기화 경로 추상화
- 분석 퍼사드: 다양한 트래킹 SDK 호출을 공통 이벤트로 통합
- 초기화/정지 시퀀스가 복잡한 모듈 묶음
- 서드파티 라이브러리 사용 단순화

## 백엔드/전체 활용 아이디어

- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋

## 구조

- Facade(고수준 API)
- Subsystem Classes(실제 기능 제공)

## 장단점

- **장점**: 단순한 사용성, 결합도 감소, 변경 파급 최소화
- **단점**: 세밀 제어는 어려울 수 있음

## 구현 팁

- 퍼사드 아래로는 의존 방향이 내려가도록 유지(아키텍처 계층화)
- 내부 예외는 퍼사드에서 의미 있는 에러 모델로 변환

## JavaScript 예제 (주석 포함)

```javascript
class CPU {
  start() {
    console.log("CPU start");
  }
}
class Memory {
  load() {
    console.log("Memory load");
  }
}
class Disk {
  mount() {
    console.log("Disk mount");
  }
}

// Facade: 시작 시퀀스를 캡슐화
class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.mem = new Memory();
    this.disk = new Disk();
  }
  start() {
    // 순서·에러 처리 정책을 퍼사드가 보유
    this.cpu.start();
    this.mem.load();
    this.disk.mount();
  }
}

// 사용자는 단일 메서드로 복잡한 과정을 실행
new ComputerFacade().start();
```
