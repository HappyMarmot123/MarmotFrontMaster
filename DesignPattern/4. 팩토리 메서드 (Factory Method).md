# 팩토리 메서드 (Factory Method)

## 개요

- **문제**: 클라이언트가 생성할 구체 클래스를 알아야 하는 결합
- **해법**: 생성 책임을 하위 클래스로 위임하는 factoryMethod로 분리

## 프론트엔드 활용 아이디어

- **알림 채널 팩토리**: Toast/Modal/Notification API 선택 생성
- **데이터 소스 팩토리**: REST/GraphQL/IndexedDB 런타임 선택
- **차트 컴포넌트**: 시리즈/스케일 타입 생성 팩토리

## 백엔드/전체 활용 아이디어

- **로거 팩토리**: 환경별 로거 타입 선택
- **데이터베이스 연결**: 개발/테스트/프로덕션 환경별 연결 팩토리
- **외부 서비스**: 다양한 API 클라이언트 생성

## 구조

- Creator(factoryMethod 제공), ConcreteCreator(구현)
- Product/ConcreteProduct(생성 대상)

## 장단점

- **장점**: 개방-폐쇄 원칙 준수, 생성/사용 분리
- **단점**: 상속 계층 증가, 간접성

## 구현 팁

- Creator에 공통 템플릿 로직을 두고, 생성만 오버라이드
- 전략/심플 팩토리와 비교하여 선택

## JavaScript 예제 (주석 포함)

```javascript
class Logger {
  log(msg) {
    throw new Error("not impl");
  }
}
class ConsoleLogger extends Logger {
  log(msg) {
    console.log(msg);
  }
}
class JsonLogger extends Logger {
  log(msg) {
    console.log(JSON.stringify({ msg, ts: Date.now() }));
  }
}

// Creator: factoryMethod를 호출하는 공통 로직 보유
class LoggerCreator {
  createLogger() {
    throw new Error("not impl");
  }
  write(msg) {
    this.createLogger().log(msg);
  } // 공통 템플릿 로직
}

// ConcreteCreator: 실제 어떤 Logger를 만들지 결정
class SimpleLoggerCreator extends LoggerCreator {
  constructor(type = "console") {
    super();
    this.type = type;
  }
  createLogger() {
    return this.type === "json" ? new JsonLogger() : new ConsoleLogger();
  }
}

new SimpleLoggerCreator("json").write("hello");
```
