# 팩토리 메서드 (Factory Method)

## 개요

- **문제**: 클라이언트가 생성할 구체 클래스를 알아야 하는 결합
- **해법**: 생성 책임을 하위 클래스로 위임하는 factoryMethod로 분리

## 프론트엔드 활용 아이디어

- 알림 채널 팩토리(Toast/Modal/Notification API 선택 생성)
- 데이터 소스 팩토리(REST/GraphQL/IndexedDB) 런타임 선택
- 라우터 가드/전처리기 생성 훅 팩토리
- 차트 시리즈/스케일 타입 생성 팩토리
- 생성 대상이 바뀌거나 확장될 가능성이 클 때
- 생성 전후 훅(검증/로깅/풀링)이 필요한 경우


## 백엔드/전체 활용 아이디어
- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋
## 구조

- Creator(factoryMethod 제공), ConcreteCreator(구현)
- Product/ConcreteProduct(생성 대상)

## 장단점

- **장점**: 개방-폐쇄 원칙 준수, 생성/사용 분리
- **단점**: 상속 계층 증가, 간접성

## 구현 팁

- Creator에 공통 템플릿 로직을 두고, 생성만 오버라이드
- 전략/심플 팩토리와 비교하여 선택

## JavaScript 예제 (주석 포함)

```javascript
class Logger {
  log(msg) {
    throw new Error("not impl");
  }
}
class ConsoleLogger extends Logger {
  log(msg) {
    console.log(msg);
  }
}
class JsonLogger extends Logger {
  log(msg) {
    console.log(JSON.stringify({ msg, ts: Date.now() }));
  }
}

// Creator: factoryMethod를 호출하는 공통 로직 보유
class LoggerCreator {
  createLogger() {
    throw new Error("not impl");
  }
  write(msg) {
    this.createLogger().log(msg);
  } // 공통 템플릿 로직
}

// ConcreteCreator: 실제 어떤 Logger를 만들지 결정
class SimpleLoggerCreator extends LoggerCreator {
  constructor(type = "console") {
    super();
    this.type = type;
  }
  createLogger() {
    return this.type === "json" ? new JsonLogger() : new ConsoleLogger();
  }
}

new SimpleLoggerCreator("json").write("hello");
```
