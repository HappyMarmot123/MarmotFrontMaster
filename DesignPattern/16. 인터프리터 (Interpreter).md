# 인터프리터 (Interpreter)

## 개요

- **문제**: 간단한 문법의 언어/규칙을 해석·평가해야 한다.
- **해법**: 문법을 객체(추상 구문 트리)로 모델링하고 각 노드가 자신을 평가한다.

## 프론트엔드 활용 아이디어

- **쿼리 언어 해석**: GraphQL 쿼리 파서, 검색 필터 DSL
- **폼 검증**: 사용자 정의 검증 규칙, 조건부 필수 필드
- **템플릿 엔진**: 조건부 렌더링 규칙, 동적 스타일 계산

## 백엔드/전체 활용 아이디어

- **쿼리 파서**: SQL WHERE 절, NoSQL 쿼리 언어
- **비즈니스 규칙**: 워크플로우 조건, 정책 평가
- **설정 파일**: 환경별 설정 파싱, 동적 설정

## 구조

- AbstractExpression(추상 표현식)
- TerminalExpression(단말 표현식)
- NonTerminalExpression(비단말 표현식)
- Context(해석 컨텍스트)
- Client(해석기 사용)

## 장단점

- **장점**: 문법 확장 용이, 구조 명확, 새로운 표현식 추가 쉬움
- **단점**: 복잡한 문법은 클래스 폭발/성능 저하, 디버깅 어려움

## 구현 팁

- 복잡한 문법은 파서 생성기(ANTLR, Bison)와 조합 사용
- 메모이제이션으로 반복 계산 방지
- 방문자 패턴과 조합하여 다양한 해석 전략 지원

## JavaScript 예제 (주석 포함)

```javascript
// 표현식: number | (expr + expr) | (expr * expr)
class Num {
  constructor(v) {
    this.v = v;
  }
  eval() {
    return this.v;
  }
}
class Add {
  constructor(l, r) {
    this.l = l;
    this.r = r;
  }
  eval() {
    return this.l.eval() + this.r.eval();
  }
}
class Mul {
  constructor(l, r) {
    this.l = l;
    this.r = r;
  }
  eval() {
    return this.l.eval() * this.r.eval();
  }
}

// (2 + 3) * 4
const expr = new Mul(new Add(new Num(2), new Num(3)), new Num(4));
console.log(expr.eval()); // 20
```

## 실무 활용 예제: 검색 필터 DSL

```javascript
// 검색 필터 언어: field:value, field>value, field<value
class FilterExpression {
  constructor(field, operator, value) {
    this.field = field;
    this.operator = operator;
    this.value = value;
  }

  matches(item) {
    const itemValue = item[this.field];
    switch (this.operator) {
      case ":":
        return itemValue === this.value;
      case ">":
        return itemValue > this.value;
      case "<":
        return itemValue < this.value;
      case ">=":
        return itemValue >= this.value;
      case "<=":
        return itemValue <= this.value;
      case "~":
        return String(itemValue).includes(this.value);
      default:
        return false;
    }
  }
}

class AndExpression {
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }

  matches(item) {
    return this.left.matches(item) && this.right.matches(item);
  }
}

class OrExpression {
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }

  matches(item) {
    return this.left.matches(item) || this.right.matches(item);
  }
}

// 사용 예시
const users = [
  { name: "Alice", age: 25, role: "admin" },
  { name: "Bob", age: 30, role: "user" },
  { name: "Charlie", age: 35, role: "admin" },
];

// 필터: (role:admin AND age>25) OR name~Charlie
const filter = new OrExpression(
  new AndExpression(
    new FilterExpression("role", ":", "admin"),
    new FilterExpression("age", ">", 25)
  ),
  new FilterExpression("name", "~", "Charlie")
);

const filtered = users.filter((user) => filter.matches(user));
console.log(filtered); // [{ name: 'Charlie', age: 35, role: 'admin' }]
```
