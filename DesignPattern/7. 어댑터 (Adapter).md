# 어댑터 (Adapter)

## 개요

- **문제**: 레거시/외부 라이브러리의 인터페이스가 현재 애플리케이션이 기대하는 인터페이스와 다를 때 직접 사용할 수 없다.
- **해법**: 어댑터가 중간에서 변환 계층을 제공하여, 클라이언트는 기대 인터페이스만 의존하고 구현 교체가 가능해진다.

## 프론트엔드 활용 아이디어

- **API 래퍼 어댑터**: fetch/XHR/GraphQL 클라이언트를 공통 HttpClient 인터페이스로 통일
- **저장소 어댑터**: localStorage/SessionStorage/IndexedDB를 공통 Storage 인터페이스로 변환
- **외부 SDK 통합**: Google Analytics/Amplitude 등 이벤트 스키마 통합

## 백엔드/전체 활용 아이디어

- **레거시 시스템 통합**: 구형 API를 새로운 시스템에 맞게 변환
- **데이터베이스 드라이버**: 다양한 DB를 공통 인터페이스로 추상화
- **외부 API 클라이언트**: REST/SOAP/GraphQL 등 다양한 프로토콜 통합

## 구조

- Target(클라이언트 기대 인터페이스)
- Adaptee(호환되지 않는 인터페이스 보유)
- Adapter(Target을 구현하고 내부적으로 Adaptee에 위임)

## 장단점

- **장점**: 레거시 재사용, 결합도 감소, 점진적 마이그레이션 가능
- **단점**: 객체 수 증가, 간접 호출로 디버깅 경로 길어짐

## 구현 팁

- 어댑터를 도입할 때 Target을 명확히 정의(메서드 시그니처, 에러 모델)
- 변환 비용이 큰 경우 캐싱·배치 처리 고려

## JavaScript 예제 (주석 포함)

```javascript
// Target: 클라이언트가 기대하는 인터페이스
class HttpClient {
  // 표준화된 GET 메서드
  get(url) {
    throw new Error("Not implemented");
  }
}

// Adaptee: 레거시/외부 라이브러리 - 시그니처가 다름
class LegacyFetcher {
  // fetchJson(url): Promise<any>
  fetchJson(url) {
    return fetch(url).then((res) => {
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    });
  }
}

// Adapter: Target을 구현하고 내부적으로 Adaptee를 사용
class LegacyFetcherAdapter extends HttpClient {
  constructor(legacy) {
    super();
    this.legacy = legacy; // 구성(Composition)을 통한 위임
  }
  // 클라이언트는 get만 알면 됨
  get(url) {
    // 필요 시 헤더/에러 모델/응답 스키마 변환도 수행
    return this.legacy.fetchJson(url);
  }
}

// 사용 예: 의존 역전 원칙을 지키며 교체 용이
const client = new LegacyFetcherAdapter(new LegacyFetcher());
client
  .get("/api/users") // Target 인터페이스만 의존
  .then((data) => {
    // data 후처리(스키마 정규화 등)도 어댑터에서 할 수 있음
    console.log("users:", data);
  })
  .catch((err) => {
    // 표준화된 에러 처리 경로 확보
    console.error("request failed:", err.message);
  });
```
