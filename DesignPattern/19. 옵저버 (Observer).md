# 옵저버 (Observer)

## 개요

- **문제**: 한 객체의 상태 변화에 여러 의존자가 자동으로 반응해야 한다.
- **해법**: 발행-구독 모델로 Subject가 변화를 통지하고 Observer가 이를 수신한다.

## 언제 쓰나

## 프론트엔드 활용 아이디어

- 전역 상태 스토어 구독(Flux/Redux 패턴)
- ResizeObserver/IntersectionObserver로 반응형 UI
- 실시간 데이터 스트림(WebSocket/SSE) 구독
- DOM MutationObserver로 동적 콘텐츠 감지
- 폼 의존 필드 자동 갱신(Subject → Observers)

- UI 이벤트, 데이터 바인딩, 모델-뷰 동기화


## 백엔드/전체 활용 아이디어
- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋
## 장단점

- **장점**: 느슨한 결합, 동적 구독/해지
- **단점**: 순환 통지, 메모리 누수(구독 해지 누락) 위험

## 구현 팁

- 해지(unsubscribe) 전략을 명확히(스코프/라이프사이클)
- 통지 폭주 시 배치/디바운스 적용

## JavaScript 예제 (주석 포함)

```javascript
class Subject {
  constructor() {
    this.observers = new Set();
  }
  subscribe(o) {
    this.observers.add(o);
  }
  unsubscribe(o) {
    this.observers.delete(o);
  }
  notify(data) {
    this.observers.forEach((o) => o.update(data));
  }
}
class LoggerObserver {
  update(d) {
    console.log("log:", d);
  }
}
class MetricsObserver {
  update(d) {
    console.log("metric:", d.length);
  }
}

const subject = new Subject();
subject.subscribe(new LoggerObserver());
subject.subscribe(new MetricsObserver());
subject.notify("EVENT");
```

