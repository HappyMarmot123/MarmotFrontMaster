# 프록시 (Proxy)

## 개요

- **문제**: 대상 객체 접근에 제어/부가 기능(캐싱, 로깅, 권한, 지연 로딩)이 필요하다.
- **해법**: 동일 인터페이스의 대리자를 두고, 요청을 가로채 정책을 적용한 후 실제 객체에 위임한다.

## 프론트엔드 활용 아이디어

- **가상 프록시**: 이미지 지연 로딩, 컴포넌트 지연 렌더링
- **보호 프록시**: 권한 기반 접근 제어, 폼 검증
- **캐싱 프록시**: API 응답 캐싱, 컴포넌트 메모이제이션

## 백엔드/전체 활용 아이디어

- **원격 프록시**: 마이크로서비스 간 통신, 외부 API 래핑
- **로깅 프록시**: API 호출 로깅, 성능 모니터링
- **보안 프록시**: 인증/권한 검사, 요청 필터링

## 종류

- 가상 프록시(지연 로딩), 보호 프록시(권한), 원격 프록시(네트워크), 캐싱 프록시, 로깅 프록시

## 구조

- Subject(공통 인터페이스)
- RealSubject(실제 객체)
- Proxy(대리자, 접근 제어)

## 장단점

- **장점**: 횡단 관심사 분리, 클라이언트 변경 최소화
- **단점**: 간접 호출로 지연/복잡성 증가

## 구현 팁

- JavaScript의 Proxy 객체나 ES6 Proxy 활용
- 프록시 체인에서 순서와 우선순위 고려

## JavaScript 예제 (주석 포함)

```javascript
class ApiService {
  async fetchUser(id) {
    console.log("API: fetch", id);
    // 네트워크 호출 가정
    return { id, name: "user" + id };
  }
}

// 캐싱 프록시: 동일 요청 결과를 메모리에 캐시
class ApiProxy {
  constructor(real) {
    this.real = real;
    this.cache = new Map();
  }
  async fetchUser(id) {
    if (this.cache.has(id)) return this.cache.get(id); // 캐시 히트
    const data = await this.real.fetchUser(id); // 원 호출
    this.cache.set(id, data);
    return data;
  }
}

const svc = new ApiProxy(new ApiService());
svc.fetchUser(1).then(console.log); // 실제 호출
svc.fetchUser(1).then(console.log); // 캐시 반환
```
