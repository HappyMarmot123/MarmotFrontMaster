# 싱글톤 (Singleton)

## 개요

- **문제**: 전역적으로 단일 인스턴스가 필요(설정/레지스트리/풀)하며, 중복 생성을 방지해야 함
- **해법**: 생성자를 감추고 정적 접근 메서드로 단일 인스턴스 제공

## 프론트엔드 활용 아이디어

- 전역 설정/Feature Flag 스토어
- 이벤트 버스/미들웨어 레지스트리
- 인증 토큰/세션 스토리지 관리자
- 테마/언어 전역 상태 저장소(컨텍스트 대체)
- 설정 관리, 커넥션 풀, 이벤트 버스

## 백엔드/전체 활용 아이디어

- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋

## 장단점

- **장점**: 전역 일관성, 자원 절약
- **단점**: 테스트 어렵고(전역 상태), 순서 의존/숨은 의존 증가

## 구현 팁

- 의존성 주입으로 싱글톤을 감싸 테스트 용이성 확보
- 멀티스레드 환경에선 동기화 고려(브라우저 JS는 단일 스레드)

## JavaScript 예제 (주석 포함)

```javascript
class Config {
  static #instance;
  constructor() {
    // 생성자 보호: 이미 인스턴스가 있으면 그걸 반환
    if (Config.#instance) return Config.#instance;
    this.values = new Map();
    Config.#instance = this;
  }
  static getInstance() {
    return this.#instance ?? new Config();
  }
  get(k) {
    return this.values.get(k);
  }
  set(k, v) {
    this.values.set(k, v);
  }
}

// 사용: 항상 동일 인스턴스
const a = Config.getInstance();
const b = Config.getInstance();
console.log(a === b); // true
a.set("env", "prod");
console.log(b.get("env")); // 'prod'
```
