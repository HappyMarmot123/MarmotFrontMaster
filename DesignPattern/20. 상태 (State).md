# 상태 (State)

## 개요

- **문제**: 상태별 분기 if-else가 증가하며 유지보수가 어려워진다.
- **해법**: 상태를 객체로 캡슐화하고, 컨텍스트가 현재 상태에 위임한다.

## 언제 쓰나

## 프론트엔드 활용 아이디어

- UI 상태 머신(마법사 플로우/로그인 흐름/XState 응용)
- 플레이어 재생/일시정지/버퍼링 상태 전이
- 요청 상태(idle/loading/success/error)로 버튼/스피너 제어
- 애니메이션/전환 상태 관리
- 접근 권한 상태에 따른 화면 전환

- 워크플로(초안→검토→발행), 미디어 플레이어, 주문 상태


## 백엔드/전체 활용 아이디어
- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋
## 장단점

- **장점**: 조건문 제거, 상태별 책임 분리, 확장 쉬움
- **단점**: 클래스 수 증가, 전이 설계 필요

## JavaScript 예제 (주석 포함)

```javascript
class Draft {
  publish(ctx) {
    console.log("to review");
    ctx.state = new Review();
  }
}
class Review {
  publish(ctx) {
    console.log("to published");
    ctx.state = new Published();
  }
}
class Published {
  publish(ctx) {
    console.log("already published");
  }
}

class Article {
  constructor() {
    this.state = new Draft();
  }
  publish() {
    this.state.publish(this);
  } // 현재 상태에 위임
}

const a = new Article();
a.publish(); // to review
a.publish(); // to published
a.publish(); // already published
```

