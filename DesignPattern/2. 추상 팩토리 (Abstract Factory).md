# 추상 팩토리 (Abstract Factory)

## 개요

- **문제**: 서로 관련된 여러 객체(제품군)를 일관되게 생성해야 하나, 클라이언트가 구체 클래스를 직접 알아서는 안 된다.
- **해법**: 제품군 생성을 캡슐화한 팩토리 인터페이스를 두고, 구체 팩토리를 교체하여 제품군을 통째로 바꾼다.

## 프론트엔드 활용 아이디어

- **테마별 UI 컴포넌트 팩토리**: 라이트/다크 테마 버튼·모달 일관 생성
- **플랫폼별 위젯**: Web/Desktop/Mobile 제품군 교체
- **국제화(i18n) 포맷터**: 날짜/통화/숫자 포맷터 패밀리

## 백엔드/전체 활용 아이디어

- **데이터 저장소 추상화**: 관계형/NoSQL/파일 스토리지 교체
- **외부 시스템 통합**: API 클라이언트, 메시지 브로커 교체
- **환경별 설정**: 개발/스테이징/프로덕션 환경별 팩토리

## 구조

- AbstractFactory(제품군 생성 인터페이스)
- ConcreteFactory(구체 제품군 생성)
- AbstractProduct/ConcreteProduct(제품 인터페이스/구현)
- Client(추상 타입에만 의존)

## 장단점

- **장점**: 일관성 있는 제품군 생성, 구체 클래스 은닉, 교체 용이
- **단점**: 제품 종류 추가가 어려움(모든 팩토리/인터페이스 수정)

## 구현 팁

- 제품군 간 일관성 규칙을 인터페이스 수준에서 강제
- IoC 컨테이너로 팩토리 바인딩을 환경별로 주입

## JavaScript 예제 (주석 포함)

```javascript
// 추상 제품: 버튼, 체크박스
class Button {
  render() {}
}
class Checkbox {
  toggle() {}
}

// 구체 제품: Windows 구현
class WinButton extends Button {
  render() {
    console.log("WinButton");
  }
}
class WinCheckbox extends Checkbox {
  toggle() {
    console.log("WinCheckbox");
  }
}

// 구체 제품: Mac 구현
class MacButton extends Button {
  render() {
    console.log("MacButton");
  }
}
class MacCheckbox extends Checkbox {
  toggle() {
    console.log("MacCheckbox");
  }
}

// 추상 팩토리: 제품군 생성 API
class WidgetFactory {
  createButton() {
    throw new Error("not impl");
  }
  createCheckbox() {
    throw new Error("not impl");
  }
}

// 구체 팩토리: Windows 제품군 생성
class WinFactory extends WidgetFactory {
  createButton() {
    return new WinButton();
  }
  createCheckbox() {
    return new WinCheckbox();
  }
}

// 구체 팩토리: Mac 제품군 생성
class MacFactory extends WidgetFactory {
  createButton() {
    return new MacButton();
  }
  createCheckbox() {
    return new MacCheckbox();
  }
}

// 클라이언트: 추상 팩토리에만 의존(구체 구현은 주입으로 교체)
function renderDialog(factory) {
  const btn = factory.createButton();
  const chk = factory.createCheckbox();
  btn.render(); // 구체 구현에 상관없이 동일 호출
  chk.toggle();
}

renderDialog(new WinFactory());
renderDialog(new MacFactory());
```
