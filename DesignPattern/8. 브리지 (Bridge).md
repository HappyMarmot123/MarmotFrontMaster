# 브리지 (Bridge)

## 개요

- **문제**: 추상화(기능)와 구현(플랫폼/렌더러 등)을 곱집합으로 확장하면 클래스 폭발 발생
- **해법**: 추상화 계층과 구현 계층을 분리(브리지)하여 서로 독립 확장

## 프론트엔드 활용 아이디어

- 렌더러 브리지: React/Vue/Canvas/SVG 렌더러 교체
- 네트워크 브리지: REST/GraphQL/WebSocket 전송 구현 교체
- 저장 브리지: 메모리/로컬/원격 저장 구현을 추상화(오프라인 우선)
- 알림 브리지: 브라우저 Notification/Toast/Modal 구현 교체
- UI 위젯 × 렌더러(SVG/Canvas) 조합
- 파일 시스템 API × OS 구현
- 네트워크 전송 × 프로토콜 구현

## 백엔드/전체 활용 아이디어

- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋

## 구조

- Abstraction(고수준 API) → Implementor(구현 인터페이스)에 위임
- RefinedAbstraction(기능 확장)
- ConcreteImplementor(구체 구현체)

## 장단점

- **장점**: 독립 확장, 배포 영향 축소, 클래스 폭발 방지
- **단점**: 간접성 증가로 복잡도 상승

## 구현 팁

- Abstraction은 구현체 생명주기 관리(주입, 교체) 책임을 갖게 함
- 성능 민감 경로는 호출 비용을 측정해 인라인 최적화 고려

## JavaScript 예제 (주석 포함)

```javascript
// Implementor: 렌더러 인터페이스
class Renderer {
  drawCircle(x, y, r) {
    throw new Error("Not implemented");
  }
}

// ConcreteImplementor: SVG 렌더러
class SvgRenderer extends Renderer {
  drawCircle(x, y, r) {
    // 실제로는 DOM API로 SVG 요소 생성/속성 설정
    console.log(`<circle cx="${x}" cy="${y}" r="${r}"/>`);
  }
}

// ConcreteImplementor: Canvas 렌더러
class CanvasRenderer extends Renderer {
  drawCircle(x, y, r) {
    // 실제 CanvasRenderingContext2D 사용 가정
    console.log(`ctx.arc(${x}, ${y}, ${r}, 0, Math.PI * 2)`);
  }
}

// Abstraction: 도형
class Shape {
  constructor(renderer) {
    this.renderer = renderer; // 브리지(구현체) 주입
  }
}

// RefinedAbstraction: 원
class Circle extends Shape {
  constructor(renderer, x, y, r) {
    super(renderer);
    this.x = x;
    this.y = y;
    this.r = r;
  }
  draw() {
    // 구현체 호출에 위임
    this.renderer.drawCircle(this.x, this.y, this.r);
  }
}

// 사용: 추상화×구현의 조합을 런타임에 선택 가능
new Circle(new SvgRenderer(), 10, 10, 5).draw();
new Circle(new CanvasRenderer(), 20, 20, 8).draw();
```
