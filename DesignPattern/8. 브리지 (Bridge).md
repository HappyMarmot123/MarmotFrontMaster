# 브리지 (Bridge)

## 개요

- **문제**: 추상화(기능)와 구현(플랫폼/렌더러 등)을 곱집합으로 확장하면 클래스 폭발 발생
- **해법**: 추상화 계층과 구현 계층을 분리(브리지)하여 서로 독립 확장

## 프론트엔드 활용 아이디어

- **렌더러 브리지**: React/Vue/Canvas/SVG 렌더러 교체
- **네트워크 브리지**: REST/GraphQL/WebSocket 전송 구현 교체
- **저장소 브리지**: 메모리/로컬/원격 저장 구현을 추상화

## 백엔드/전체 활용 아이디어

- **데이터베이스 드라이버**: 다양한 DB 엔진을 공통 인터페이스로 추상화
- **파일 시스템**: 로컬/클라우드/네트워크 스토리지 구현 교체
- **메시징 시스템**: 큐/이벤트/웹훅 등 다양한 전송 방식 지원

## 구조

- Abstraction(고수준 API) → Implementor(구현 인터페이스)에 위임
- RefinedAbstraction(기능 확장)
- ConcreteImplementor(구체 구현체)

## 장단점

- **장점**: 독립 확장, 배포 영향 축소, 클래스 폭발 방지
- **단점**: 간접성 증가로 복잡도 상승

## 구현 팁

- Abstraction은 구현체 생명주기 관리(주입, 교체) 책임을 갖게 함
- 성능 민감 경로는 호출 비용을 측정해 인라인 최적화 고려

## JavaScript 예제 (주석 포함)

```javascript
// Implementor: 렌더러 인터페이스
class Renderer {
  drawCircle(x, y, r) {
    throw new Error("Not implemented");
  }
}

// ConcreteImplementor: SVG 렌더러
class SvgRenderer extends Renderer {
  drawCircle(x, y, r) {
    // 실제로는 DOM API로 SVG 요소 생성/속성 설정
    console.log(`<circle cx="${x}" cy="${y}" r="${r}"/>`);
  }
}

// ConcreteImplementor: Canvas 렌더러
class CanvasRenderer extends Renderer {
  drawCircle(x, y, r) {
    // 실제 CanvasRenderingContext2D 사용 가정
    console.log(`ctx.arc(${x}, ${y}, ${r}, 0, Math.PI * 2)`);
  }
}

// Abstraction: 도형
class Shape {
  constructor(renderer) {
    this.renderer = renderer; // 브리지(구현체) 주입
  }
}

// RefinedAbstraction: 원
class Circle extends Shape {
  constructor(renderer, x, y, r) {
    super(renderer);
    this.x = x;
    this.y = y;
    this.r = r;
  }
  draw() {
    // 구현체 호출에 위임
    this.renderer.drawCircle(this.x, this.y, this.r);
  }
}

// 사용: 추상화×구현의 조합을 런타임에 선택 가능
new Circle(new SvgRenderer(), 10, 10, 5).draw();
new Circle(new CanvasRenderer(), 20, 20, 8).draw();
```
