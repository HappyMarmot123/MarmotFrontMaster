# 컴포지트 (Composite)

## 개요

- **문제**: 부분-전체(트리) 구조에서 단일(Leaf)과 복합(Composite)을 동일하게 다루고 싶다.
- **해법**: 공통 인터페이스(Component)를 정의하고, 복합 객체는 자식들을 보관해 동일 연산을 위임/집계한다.

## 프론트엔드 활용 아이디어

- UI 구성요소 트리(레이아웃, 메뉴, 드롭다운) 일관 렌더
- 접근 제어 메뉴(권한별 노드 노출/비노출)를 트리 필터로 처리
- Canvas/SVG 장면 그래프를 그룹 단위로 이동/변환
- 폼 섹션/필드 그룹을 동일 인터페이스로 순회/검증
- UI 트리(레이아웃/뷰 계층)
- 파일 시스템(디렉토리/파일)
- 그래픽 장면 그래프

## 백엔드/전체 활용 아이디어

- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋

## 구조

- Component(공통 연산)
- Leaf(실제 작업 수행)
- Composite(자식 관리, 연산 위임/집계)

## 장단점

- **장점**: 클라이언트 코드 단순화, 확장 용이
- **단점**: 타입 제약 약화, 자원/라이프사이클 관리 복잡성

## 구현 팁

- 변경 가능 트리라면 add/remove 책임·소유권을 명확히
- 불변 트리를 원하면 생성 시 조립만 허용하고 이후 변경 금지

## JavaScript 예제 (주석 포함)

```javascript
class Component {
  render() {
    throw new Error("Not implemented");
  }
}

// Leaf: 말단 노드(실제 콘텐츠 렌더)
class Text extends Component {
  constructor(content) {
    super();
    this.content = content;
  }
  render() {
    return this.content;
  }
}

// Composite: 자식 노드 집계/위임
class Group extends Component {
  constructor() {
    super();
    this.children = [];
  }
  add(child) {
    this.children.push(child);
  }
  render() {
    // 모든 자식의 render 결과를 결합
    return this.children.map((c) => c.render()).join("");
  }
}

// 사용: 트리 조립
const root = new Group();
root.add(new Text("<h1>Hello</h1>"));
const body = new Group();
body.add(new Text("<p>Composite</p>"));
root.add(body);

console.log(root.render()); // <h1>Hello</h1><p>Composite</p>
```
