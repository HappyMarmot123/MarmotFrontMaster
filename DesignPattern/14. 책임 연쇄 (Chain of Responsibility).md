# 책임 연쇄 (Chain of Responsibility)

## 개요

- **문제**: 누가 요청을 처리해야 할지 컴파일 타임에 고정하고 싶지 않다.
- **해법**: 핸들러를 체인으로 연결해 조건에 맞는 핸들러가 처리할 때까지 전달한다.

## 프론트엔드 활용 아이디어

- **폼 검증 체인**: 유효성 검사 규칙을 순차적으로 적용
- **이벤트 처리**: 이벤트 버블링/캡처링 체인
- **미들웨어**: React/Express 미들웨어 체인

## 백엔드/전체 활용 아이디어

- **인증/권한 체인**: 로그인 → 권한 → 역할 검사
- **로깅/모니터링**: 요청 로깅 → 성능 측정 → 알림
- **에러 처리**: 에러 타입별 핸들러 체인

## 구조

- Handler(처리자 인터페이스)
- ConcreteHandler(구체 처리자)
- Client(체인 구성/사용)

## 장단점

- **장점**: 발신자/수신자 분리, 핸들러 추가/순서 변경 용이
- **단점**: 처리되지 않을 수 있음, 추적 난이도

## 구현 팁

- 체인 순서가 중요할 때는 명시적으로 순서 관리
- 무한 루프 방지를 위한 체인 깊이 제한 고려

## JavaScript 예제 (주석 포함)

```javascript
class Handler {
  setNext(next) {
    this.next = next;
    return next;
  }
  handle(req) {
    return this.next?.handle(req);
  }
}
class AuthHandler extends Handler {
  handle(req) {
    if (!req.user) return "401 Unauthorized";
    return super.handle(req);
  }
}
class RoleHandler extends Handler {
  handle(req) {
    if (req.user.role !== "admin") return "403 Forbidden";
    return super.handle(req);
  }
}
class FinalHandler extends Handler {
  handle(req) {
    return `ok: ${req.action}`;
  }
}

// 체인 구성: Auth → Role → Final
const chain = new AuthHandler();
chain.setNext(new RoleHandler()).setNext(new FinalHandler());

console.log(chain.handle({ action: "delete" })); // 401
console.log(chain.handle({ user: { role: "user" }, action: "delete" })); // 403
console.log(chain.handle({ user: { role: "admin" }, action: "delete" })); // ok
```
