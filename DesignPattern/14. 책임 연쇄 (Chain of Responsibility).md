# 책임 연쇄 (Chain of Responsibility)

## 개요

- **문제**: 누가 요청을 처리해야 할지 컴파일 타임에 고정하고 싶지 않다.
- **해법**: 핸들러를 체인으로 연결해 조건에 맞는 핸들러가 처리할 때까지 전달한다.

## 장단점

- **장점**: 발신자/수신자 분리, 핸들러 추가/순서 변경 용이
- **단점**: 처리되지 않을 수 있음, 추적 난이도

## JavaScript 예제 (주석 포함)

```javascript
class Handler {
  setNext(next) {
    this.next = next;
    return next;
  }
  handle(req) {
    return this.next?.handle(req);
  }
}
class AuthHandler extends Handler {
  handle(req) {
    if (!req.user) return "401 Unauthorized";
    return super.handle(req);
  }
}
class RoleHandler extends Handler {
  handle(req) {
    if (req.user.role !== "admin") return "403 Forbidden";
    return super.handle(req);
  }
}
class FinalHandler extends Handler {
  handle(req) {
    return `ok: ${req.action}`;
  }
}

// 체인 구성: Auth → Role → Final
const chain = new AuthHandler();
chain.setNext(new RoleHandler()).setNext(new FinalHandler());

console.log(chain.handle({ action: "delete" })); // 401
console.log(chain.handle({ user: { role: "user" }, action: "delete" })); // 403
console.log(chain.handle({ user: { role: "admin" }, action: "delete" })); // ok
```

