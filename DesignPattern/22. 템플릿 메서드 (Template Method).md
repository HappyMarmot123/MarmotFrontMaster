# 템플릿 메서드 (Template Method)

## 개요

- **문제**: 공통 절차는 같고 일부 단계만 다를 때 중복 코드가 많아진다.
- **해법**: 상위 클래스가 알고리즘 골격을 정의하고, 하위 클래스가 단계만 재정의

## 언제 쓰나

## 프론트엔드 활용 아이디어

- 내보내기 파이프라인(CSV/JSON/PDF) 공통 골격 + 포맷별 직렬화 단계
- 이미지 처리 파이프라인(불러오기 → 정규화 → 리사이즈 → 저장)
- 빌드 파이프라인(전처리 → 번들 → 압축 → 배포) 템플릿화
- 양식 제출(정규화 → 검증 → 직렬화 → 전송 → 후처리)

- 파이프라인/빌드/내보내기(export)/파서 루틴


## 백엔드/전체 활용 아이디어
- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋
## 장단점

- **장점**: 코드 재사용/일관성, 훅으로 확장 포인트 제공
- **단점**: 상속 결합, 하위 클래스 남용 가능

## JavaScript 예제 (주석 포함)

```javascript
class DataExporter {
  export(data) {
    const normalized = this.normalize(data); // 공통 단계
    const serialized = this.serialize(normalized); // 가변 단계
    this.save(serialized); // 공통 단계
  }
  normalize(d) {
    return d;
  }
  serialize() {
    throw new Error("override");
  }
  save() {
    console.log("saved");
  }
}
class CsvExporter extends DataExporter {
  serialize(d) {
    return d.map((r) => Object.values(r).join(",")).join("\n");
  }
}
class JsonExporter extends DataExporter {
  serialize(d) {
    return JSON.stringify(d);
  }
}

new CsvExporter().export([
  { a: 1, b: 2 },
  { a: 3, b: 4 },
]);
new JsonExporter().export([
  { a: 1, b: 2 },
  { a: 3, b: 4 },
]);
```

