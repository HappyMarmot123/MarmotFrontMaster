# 메멘토 (Memento)

## 개요

- **문제**: 객체의 내부 상태를 외부에서 캡슐화를 깨지 않고 저장/복원하고 싶다.
- **해법**: 상태 스냅샷(Memento)을 별도 객체로 만들어 Caretaker가 보관한다.

## 프론트엔드 활용 아이디어

- **실행 취소/다시 실행**: 에디터, 그림판, 폼 편집
- **상태 히스토리**: 사용자 액션 기록, 브라우저 뒤로가기
- **폼 데이터**: 임시 저장, 자동 복구

## 백엔드/전체 활용 아이디어

- **데이터베이스 트랜잭션**: 롤백/커밋, 체크포인트
- **워크플로우**: 단계별 상태 저장, 진행 상황 복구
- **설정 관리**: 설정 변경 히스토리, 이전 버전 복원

## 구조

- Originator(상태 생성/복원)
- Memento(상태 스냅샷)
- Caretaker(메멘토 관리)

## 장단점

- **장점**: 캡슐화 유지, 되돌리기/히스토리 구현 용이
- **단점**: 메모리 사용 증가, 스냅샷 관리 비용

## 구현 팁

- 메멘토 객체는 불변으로 만들어 상태 변경 방지
- 메모리 효율을 위해 스냅샷 수 제한 및 압축 고려

## JavaScript 예제 (주석 포함)

```javascript
class Editor {
  constructor() {
    this.text = "";
  }
  type(str) {
    this.text += str;
  }
  // 현재 상태를 메멘토로 캡슐화
  save() {
    return new Memento(this.text);
  }
  // 메멘토에서 상태 복원
  restore(m) {
    this.text = m.state;
  }
}

// 메멘토: 불변 스냅샷
class Memento {
  constructor(state) {
    this.state = state;
    Object.freeze(this);
  }
}

// Caretaker: 메멘토 저장/관리
class History {
  constructor() {
    this.stack = [];
  }
  push(m) {
    this.stack.push(m);
  }
  pop() {
    return this.stack.pop();
  }
}

const ed = new Editor();
const hist = new History();
ed.type("Hello");
hist.push(ed.save()); // 스냅샷 저장
ed.type(" World"); // 변경
ed.restore(hist.pop()); // 복원
console.log(ed.text); // Hello
```
