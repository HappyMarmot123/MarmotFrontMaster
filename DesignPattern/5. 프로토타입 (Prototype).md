# 프로토타입 (Prototype)

## 개요

- **문제**: 생성 비용이 큰 객체를 반복 생성하거나, 런타임에 새로운 타입을 유연하게 확장하고 싶다.
- **해법**: 원형 객체를 복제(clone)하여 새로운 인스턴스를 만든다.

## 프론트엔드 활용 아이디어

- DOM 템플릿 노드/카드 컴포넌트 복제 후 데이터만 바인딩
- 캔버스 도형/스프라이트 프로토타입 복제
- 기본 폼 상태/설정 템플릿 복제해 초기값 구성
- 에디터 블록/문단 템플릿 복제
- 파싱 결과/DOM 스니펫/설정 템플릿을 복제
- 게임 오브젝트/문서 요소 복제


## 백엔드/전체 활용 아이디어
- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋
## 장단점

- **장점**: 생성 비용 절감, 런타임 확장 유연성
- **단점**: 깊은/얕은 복사, 순환 참조 처리 어려움

## 구현 팁

- JSON 깊은 복사는 한계가 있으므로 구조화된 클론(StructuredClone) 고려
- clone 시 불변성 정책을 정의

## JavaScript 예제 (주석 포함)

```javascript
class DocumentProto {
  constructor(title, meta) {
    this.title = title;
    this.meta = meta;
  }
  clone() {
    // 간단한 깊은 복사(중첩 객체를 안전하게 복제)
    return new DocumentProto(this.title, JSON.parse(JSON.stringify(this.meta)));
  }
}

const original = new DocumentProto("Spec", { tags: ["a", "b"], ver: 1 });
const copy = original.clone();
copy.meta.tags.push("c");
console.log(original.meta.tags); // ['a','b'] (원본 영향 없음)
console.log(copy.meta.tags); // ['a','b','c']
```
