# 프로토타입 (Prototype)

## 📖 개요

프로토타입 패턴은 **기존 객체를 복제하여 새로운 객체를 생성**하는 패턴입니다. `new` 키워드를 사용하여 객체를 직접 생성하는 대신, 이미 만들어진 **'원형(prototype)' 객체**를 복사(clone)하여 새로운 객체를 만드는 방식입니다. 이 패턴은 객체 생성 비용이 크거나, 객체를 직접 생성하기 어려운 경우에 유용합니다.

게임을 예시로 들면, 본인의 능력치를 그대로 복사한 분신이 생기는 것, 그러나 생긴 이후엔 분신과 본체의 체력 감소는 각각 이루어져야 한다. 만약 체력이 서로 동기화된 상태라면? 그것은 **얕은 복사** 상태, 프로토타입으로 복제한 객체가 원본(프로토타입)에 영향을 주지 않으려면 **깊은 복사(Deep Copy)**를 사용해야 합니다.

## 💡 핵심 원리

- **원형 객체 복제**: 기존 객체를 템플릿으로 사용하여 새로운 객체 생성
- **깊은 복사 vs 얕은 복사**: 중첩된 객체의 참조 문제 해결
- **생성 비용 절감**: 복잡한 초기화 과정을 건너뛰고 기존 객체 복사
- **런타임 확장**: 동적으로 객체 구조 변경 가능

## ✅ 장점

- **생성 비용 절감**: 복잡한 초기화 과정 생략
- **런타임 확장**: 객체 구조를 동적으로 변경 가능
- **메모리 효율성**: 공통 속성을 가진 객체들을 효율적으로 생성
- **유연성**: 객체 생성과 사용을 분리

## ❌ 단점

- **복사 복잡성**: 깊은 복사 시 순환 참조 처리 어려움
- **메모리 사용량**: 큰 객체 복사 시 메모리 사용량 증가
- **성능 오버헤드**: 복잡한 객체 구조 복사 시 성능 저하 가능

## 🎯 사용 시기

- 객체 생성 비용이 클 때
- 런타임에 객체 구조를 변경해야 할 때
- 기본 템플릿에서 다양한 변형을 만들 때
- 객체의 상태를 독립적으로 관리해야 할 때

## 🚀 실용적 예제

### 1. 게임 캐릭터 프로토타입 (바닐라 자바스크립트)

```javascript
// 깊은 복사 유틸리티 함수
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((item) => deepClone(item));

  const cloned = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  return cloned;
}

// 게임 캐릭터 프로토타입
class GameCharacter {
  constructor(name, stats) {
    this.name = name;
    this.stats = stats;
  }

  clone() {
    return deepClone(this);
  }

  takeDamage(damage) {
    this.stats.health -= damage;
  }
}

// 사용 예시
const original = new GameCharacter("용사", { health: 100, mana: 50 });
const cloned = original.clone();
cloned.name = "용사의 분신";

// 독립성 테스트
original.takeDamage(20);
cloned.takeDamage(30);
```

### 2. 설정 템플릿 프로토타입 (Lodash 사용)

```javascript
// 설정 템플릿 프로토타입
class ConfigTemplate {
  constructor(name, settings, environment) {
    this.name = name;
    this.settings = settings;
    this.environment = environment;
    this.metadata = { version: "1.0.0", lastModified: new Date() };
  }

  cloneWithLodash() {
    if (typeof _ !== "undefined" && _.cloneDeep) {
      return _.cloneDeep(this);
    }
    return JSON.parse(JSON.stringify(this));
  }

  applyEnvironment(env) {
    if (this.environment[env]) {
      Object.assign(this.settings, this.environment[env]);
    }
  }
}

// 사용 예시
const baseConfig = new ConfigTemplate(
  "Production",
  {
    database: { host: "localhost", port: 5432 },
    api: { port: 3000 },
  },
  {
    development: { database: { host: "dev-db" }, api: { port: 3001 } },
    staging: { database: { host: "staging-db" }, api: { port: 3002 } },
  }
);

const devConfig = baseConfig.cloneWithLodash();
devConfig.name = "Development";
devConfig.applyEnvironment("development");

console.log("개발 환경 호스트:", devConfig.settings.database.host); // dev-db
```

### 🔧 구현 팁

### 1. **깊은 복사 방법 선택**

- **바닐라 JS**: `JSON.parse(JSON.stringify())` - 간단하지만 제한적
- **Lodash**: `_.cloneDeep()` - 안전하고 완전한 깊은 복사
- **Structured Clone API**: `structuredClone()` - 최신 브라우저 지원

### 2. **순환 참조 처리**

```javascript
function deepCloneWithCircular(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== "object") return obj;
  if (hash.has(obj)) return hash.get(obj);

  const cloned = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloned);

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepCloneWithCircular(obj[key], hash);
    }
  }

  return cloned;
}
```
