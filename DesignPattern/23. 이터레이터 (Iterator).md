# 이터레이터 (Iterator)

## 개요

- **문제**: 컬렉션 내부 표현을 노출하지 않고 표준 방식으로 순회하고 싶다.
- **해법**: 이터레이터 객체가 컬렉션을 캡슐화하고 순회 프로토콜을 제공한다.

## 프론트엔드 활용 아이디어

- **컴포넌트 순회**: React 컴포넌트 트리 탐색, DOM 노드 순회
- **데이터 스트리밍**: 실시간 데이터 청크 처리, 무한 스크롤
- **폼 처리**: 동적 폼 필드 순회, 유효성 검사 체인

## 백엔드/전체 활용 아이디어

- **데이터베이스 커서**: 대용량 결과셋 스트리밍
- **파일 처리**: 대용량 파일 청크 단위 읽기
- **메시지 큐**: 메시지 스트림 순차 처리

## 구조

- Iterator(순회 인터페이스)
- ConcreteIterator(구체 순회 구현)
- Aggregate(컬렉션 인터페이스)
- ConcreteAggregate(구체 컬렉션)
- Client(순회 사용자)

## 장단점

- **장점**: 내부 캡슐화, 다양한 순회 전략 교체 가능, 메모리 효율적 처리
- **단점**: 단순 컬렉션에 오버헤드, 복잡한 순회 로직 구현 어려움

## 구현 팁

- JavaScript의 Symbol.iterator와 for...of 루프 활용
- 제너레이터 함수로 메모리 효율적인 이터레이터 구현
- 커스텀 이터레이터에서 에러 처리와 리소스 정리 고려

## JavaScript 예제 (주석 포함)

```javascript
// 커스텀 이터레이터: 배열을 순회
class ArrayIterator {
  constructor(arr) {
    this.arr = arr;
    this.idx = 0;
  }
  next() {
    // next()는 {value, done} 반환
    return this.idx < this.arr.length
      ? { value: this.arr[this.idx++], done: false }
      : { done: true };
  }
  // for...of 지원을 위해 이터러블 프로토콜 구현
  [Symbol.iterator]() {
    return this;
  }
}

const it = new ArrayIterator(["a", "b", "c"]);
for (const x of it) console.log(x);
```

## 실무 활용 예제: 페이지네이션 이터레이터

```javascript
// API 응답을 페이지 단위로 순회하는 이터레이터
class PaginationIterator {
  constructor(fetchPage, pageSize = 10) {
    this.fetchPage = fetchPage;
    this.pageSize = pageSize;
    this.currentPage = 0;
    this.currentItems = [];
    this.currentIndex = 0;
    this.hasMore = true;
  }

  async next() {
    // 현재 페이지의 아이템을 모두 소진했으면 다음 페이지 로드
    if (this.currentIndex >= this.currentItems.length) {
      if (!this.hasMore) {
        return { done: true };
      }

      try {
        const response = await this.fetchPage(this.currentPage, this.pageSize);
        this.currentItems = response.items;
        this.hasMore = response.hasMore;
        this.currentPage++;
        this.currentIndex = 0;

        if (this.currentItems.length === 0) {
          return { done: true };
        }
      } catch (error) {
        console.error("페이지 로드 실패:", error);
        return { done: true };
      }
    }

    return {
      value: this.currentItems[this.currentIndex++],
      done: false,
    };
  }

  [Symbol.asyncIterator]() {
    return this;
  }
}

// 사용 예시
async function processAllUsers() {
  const userIterator = new PaginationIterator(async (page, size) => {
    // API 호출 시뮬레이션
    const response = await fetch(`/api/users?page=${page}&size=${size}`);
    const data = await response.json();
    return {
      items: data.users,
      hasMore: data.hasMore,
    };
  });

  for await (const user of userIterator) {
    console.log("사용자 처리:", user.name);
    // 각 사용자에 대한 비즈니스 로직 처리
  }
}

// 제너레이터를 활용한 이터레이터
function* rangeIterator(start, end, step = 1) {
  for (let i = start; i <= end; i += step) {
    yield i;
  }
}

// 무한 시퀀스 이터레이터
function* fibonacciIterator() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

// 사용 예시
const range = rangeIterator(1, 10, 2);
for (const num of range) {
  console.log(num); // 1, 3, 5, 7, 9
}

const fib = fibonacciIterator();
let count = 0;
for (const num of fib) {
  if (count++ >= 10) break;
  console.log(num); // 피보나치 수열의 처음 10개
}
```
