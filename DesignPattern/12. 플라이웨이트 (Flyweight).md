# 플라이웨이트 (Flyweight)

## 개요

- **문제**: 수십만 개의 유사 객체를 생성하면 메모리/생성 비용이 폭증한다.
- **해법**: 공유 가능한 내부 상태(intrinsic)를 분리해 풀에서 재사용하고, 외부 상태(extrinsic)는 호출 시 인자로 전달한다.

## 프론트엔드 활용 아이디어

- 아이콘/이미지 스프라이트 글리프 공유로 메모리 절약
- 대규모 리스트(virtualized list) 아이템 셀 스타일/레이아웃 공유
- 지도 타일/히트맵 셀 공유 객체 캐시
- 에디터 문자 서브셋 글리프 캐싱
- 텍스트 렌더링(문자 글리프), 타일 맵, 파티클, 아이콘 캐시

## 백엔드/전체 활용 아이디어

- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋

## 구조

- Flyweight(공유 상태 보유), ConcreteFlyweight(구현)
- FlyweightFactory(풀/캐시 관리)
- Client(외부 상태를 보유해 호출 시 전달)

## 장단점

- **장점**: 메모리 절약, 생성 비용 감소
- **단점**: 상태 분리로 설계 복잡도/동시성 고려 필요

## 구현 팁

- 캐시 크기 상한과 제거 정책(LRU) 고려
- 불변 공유 객체로 만들어 안전성 확보

## JavaScript 예제 (주석 포함)

```javascript
// 공유 객체: 문자 글리프. 상태(문자)는 불변
class Glyph {
  constructor(char) {
    this.char = char;
    Object.freeze(this);
  }
  // 외부 상태(x,y)는 매 호출 시 인자로 전달
  draw(x, y) {
    console.log(`draw '${this.char}' at ${x},${y}`);
  }
}

// 팩토리: 글리프 풀 관리(캐싱)
class GlyphFactory {
  constructor() {
    this.pool = new Map();
  }
  get(char) {
    if (!this.pool.has(char)) this.pool.set(char, new Glyph(char));
    return this.pool.get(char);
  }
  size() {
    return this.pool.size;
  }
}

// 사용: 동일 문자 재사용 → 메모리 절약
const factory = new GlyphFactory();
"hello world".split("").forEach((ch, i) => factory.get(ch).draw(i, 0));
console.log("pool size:", factory.size()); // 고유 문자 개수만큼
```
