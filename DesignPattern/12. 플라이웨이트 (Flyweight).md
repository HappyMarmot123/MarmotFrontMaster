# 플라이웨이트 (Flyweight)

## 개요

- **문제**: 수십만 개의 유사 객체를 생성하면 메모리/생성 비용이 폭증한다.
- **해법**: 공유 가능한 내부 상태(intrinsic)를 분리해 풀에서 재사용하고, 외부 상태(extrinsic)는 호출 시 인자로 전달한다.

## 프론트엔드 활용 아이디어

- **아이콘/이미지 스프라이트**: 글리프 공유로 메모리 절약
- **대규모 리스트**: 가상화된 리스트 아이템 스타일/레이아웃 공유
- **지도 타일**: 히트맵 셀 공유 객체 캐시

## 백엔드/전체 활용 아이디어

- **문자열 풀**: 자주 사용되는 문자열 객체 재사용
- **데이터베이스 커넥션**: 커넥션 풀을 통한 객체 재사용
- **캐시 시스템**: 공통 데이터 객체 공유

## 구조

- Flyweight(공유 상태 보유), ConcreteFlyweight(구현)
- FlyweightFactory(풀/캐시 관리)
- Client(외부 상태를 보유해 호출 시 전달)

## 장단점

- **장점**: 메모리 절약, 생성 비용 감소
- **단점**: 상태 분리로 설계 복잡도/동시성 고려 필요

## 구현 팁

- 캐시 크기 상한과 제거 정책(LRU) 고려
- 불변 공유 객체로 만들어 안전성 확보

## JavaScript 예제 (주석 포함)

```javascript
// 공유 객체: 문자 글리프. 상태(문자)는 불변
class Glyph {
  constructor(char) {
    this.char = char;
    Object.freeze(this);
  }
  // 외부 상태(x,y)는 매 호출 시 인자로 전달
  draw(x, y) {
    console.log(`draw '${this.char}' at ${x},${y}`);
  }
}

// 팩토리: 글리프 풀 관리(캐싱)
class GlyphFactory {
  constructor() {
    this.pool = new Map();
  }
  get(char) {
    if (!this.pool.has(char)) this.pool.set(char, new Glyph(char));
    return this.pool.get(char);
  }
  size() {
    return this.pool.size;
  }
}

// 사용: 동일 문자 재사용 → 메모리 절약
const factory = new GlyphFactory();
"hello world".split("").forEach((ch, i) => factory.get(ch).draw(i, 0));
console.log("pool size:", factory.size()); // 고유 문자 개수만큼
```
