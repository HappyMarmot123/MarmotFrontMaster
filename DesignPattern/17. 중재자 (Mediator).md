# 중재자 (Mediator)

## 개요

- **문제**: 다수의 객체가 서로 직접 참조하며 상호작용하면 의존 그래프가 얽히고 변경 전파가 커진다.
- **해법**: 중재자(허브)가 상호작용 규칙을 캡슐화하고, 참여자들은 중재자만 의존한다.

## 언제 쓰나

## 프론트엔드 활용 아이디어

- **컴포넌트 이벤트 버스**: 폼 위젯 간 상호작용 조정
- **채팅/콜라보 툴**: 사용자 상태/존재감/타이핑 표시 중재
- **모달/토스트 관리자**: 중복 오버레이 충돌 방지

## 백엔드/전체 활용 아이디어

- **마이크로서비스 통신**: 서비스 간 메시지 라우팅
- **이벤트 버스**: 시스템 간 이벤트 발행/구독
- **워크플로우 엔진**: 단계별 작업 조정

## 구조

- Mediator(규칙/조정 인터페이스), ConcreteMediator(구현)
- Colleague(참여자), ConcreteColleague(구현)

## 장단점

- **장점**: 결합도 감소, 상호작용 로직 중앙화
- **단점**: 중재자 비대화 위험(거대한 클래스)

## 구현 팁

- 중재자를 역할별로 분할(채널/토픽)해 단일 책임 유지
- 이벤트 기반(발행-구독)으로 확장성 확보

## JavaScript 예제 (주석 포함)

```javascript
// Mediator: 채팅방(허브)
class ChatRoom {
  constructor() {
    this.users = new Map();
  }
  join(user) {
    this.users.set(user.name, user);
    user.room = this;
  }
  send(from, to, msg) {
    this.users.get(to)?.receive(from, msg);
  }
}
// Colleague: 사용자
class User {
  constructor(name) {
    this.name = name;
  }
  send(to, msg) {
    this.room.send(this.name, to, msg);
  }
  receive(from, msg) {
    console.log(`[${from} -> ${this.name}] ${msg}`);
  }
}

const room = new ChatRoom();
const a = new User("Alice");
const b = new User("Bob");
room.join(a);
room.join(b);
a.send("Bob", "Hi!");
```
