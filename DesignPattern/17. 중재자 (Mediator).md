# 중재자 (Mediator)

## 개요

- **문제**: 다수의 객체가 서로 직접 참조하며 상호작용하면 의존 그래프가 얽히고 변경 전파가 커진다.
- **해법**: 중재자(허브)가 상호작용 규칙을 캡슐화하고, 참여자들은 중재자만 의존한다.

## 언제 쓰나

## 프론트엔드 활용 아이디어

- 컴포넌트 이벤트 버스(폼 위젯 간 상호작용 조정)
- 채팅/콜라보 툴의 룸 중재자(사용자 상태/존재감/타이핑 표시)
- 모달/토스트 관리자: 중복 오버레이 충돌 방지
- 드래그앤드롭 중재자: 소스-타깃 간 계약 조정
- 마이크로프론트엔드 간 메시지 허브

- 채팅방/이벤트 버스/폼 위젯 간 동기화
- 다수 컴포넌트 간 교차 영향이 클 때


## 백엔드/전체 활용 아이디어
- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋
## 구조

- Mediator(규칙/조정 인터페이스), ConcreteMediator(구현)
- Colleague(참여자), ConcreteColleague(구현)

## 장단점

- **장점**: 결합도 감소, 상호작용 로직 중앙화
- **단점**: 중재자 비대화 위험(거대한 클래스)

## 구현 팁

- 중재자를 역할별로 분할(채널/토픽)해 단일 책임 유지
- 이벤트 기반(발행-구독)으로 확장성 확보

## JavaScript 예제 (주석 포함)

```javascript
// Mediator: 채팅방(허브)
class ChatRoom {
  constructor() {
    this.users = new Map();
  }
  join(user) {
    this.users.set(user.name, user);
    user.room = this;
  }
  send(from, to, msg) {
    this.users.get(to)?.receive(from, msg);
  }
}
// Colleague: 사용자
class User {
  constructor(name) {
    this.name = name;
  }
  send(to, msg) {
    this.room.send(this.name, to, msg);
  }
  receive(from, msg) {
    console.log(`[${from} -> ${this.name}] ${msg}`);
  }
}

const room = new ChatRoom();
const a = new User("Alice");
const b = new User("Bob");
room.join(a);
room.join(b);
a.send("Bob", "Hi!");
```

