# 전략 (Strategy)

## 개요

- **문제**: 알고리즘 변형(정렬, 경로, 요금)을 if-else로 분기하면 확장이 어렵다.
- **해법**: 알고리즘을 전략 객체로 캡슐화하고 컨텍스트가 위임한다.

## 언제 쓰나

## 프론트엔드 활용 아이디어

- Service Worker 캐싱 전략 교체(cache-first/network-first/stale-while-revalidate)
- 리스트 정렬/필터 전략 교체(이름/날짜/랭크 등)
- 이미지 소스 선택 전략(srcset/sizes 대응 가로세로/해상도)
- 가격 포맷/로케일 전략(국가별 통화/세금 처리)
- A/B 테스트 변형 선택 전략

- 런타임에 알고리즘을 교체, A/B 실험, 정책 주입


## 백엔드/전체 활용 아이디어
- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋
## 장단점

- **장점**: 조건문 제거, 테스트 용이, 확장 쉬움
- **단점**: 클래스 증가, 선택 로직 필요

## JavaScript 예제 (주석 포함)

```javascript
class BubbleSort {
  sort(a) {
    const arr = [...a];
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length - 1; j++) {
        if (arr[j] > arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
    return arr;
  }
}
class QuickSort {
  sort(a) {
    return [...a].sort((x, y) => x - y);
  }
}
class Sorter {
  constructor(strategy) {
    this.strategy = strategy;
  }
  setStrategy(s) {
    this.strategy = s;
  }
  sort(a) {
    return this.strategy.sort(a);
  }
}

const sorter = new Sorter(new BubbleSort());
console.log(sorter.sort([3, 2, 1]));
sorter.setStrategy(new QuickSort());
console.log(sorter.sort([3, 2, 1]));
```

