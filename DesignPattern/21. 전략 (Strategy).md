# 전략 (Strategy)

## 개요

- **문제**: 알고리즘 변형(정렬, 경로, 요금)을 if-else로 분기하면 확장이 어렵다.
- **해법**: 알고리즘을 전략 객체로 캡슐화하고 컨텍스트가 위임한다.

## 언제 쓰나

## 프론트엔드 활용 아이디어

- **캐싱 전략**: Service Worker cache-first/network-first/stale-while-revalidate
- **정렬/필터**: 리스트 정렬/필터 전략 교체(이름/날짜/랭크)
- **가격 포맷**: 국가별 통화/세금 처리 전략

## 백엔드/전체 활용 아이디어

- **결제 전략**: 다양한 결제 수단 처리
- **알고리즘 선택**: 정렬, 검색, 라우팅 알고리즘 교체
- **A/B 테스트**: 실험 변형 선택 전략

## 장단점

- **장점**: 조건문 제거, 테스트 용이, 확장 쉬움
- **단점**: 클래스 증가, 선택 로직 필요

## JavaScript 예제 (주석 포함)

```javascript
class BubbleSort {
  sort(a) {
    const arr = [...a];
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length - 1; j++) {
        if (arr[j] > arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
    return arr;
  }
}
class QuickSort {
  sort(a) {
    return [...a].sort((x, y) => x - y);
  }
}
class Sorter {
  constructor(strategy) {
    this.strategy = strategy;
  }
  setStrategy(s) {
    this.strategy = s;
  }
  sort(a) {
    return this.strategy.sort(a);
  }
}

const sorter = new Sorter(new BubbleSort());
console.log(sorter.sort([3, 2, 1]));
sorter.setStrategy(new QuickSort());
console.log(sorter.sort([3, 2, 1]));
```
