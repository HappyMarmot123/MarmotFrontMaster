# 컴파운드 (Compound) 패턴

## 📖 개요

**컴파운드 패턴**은 여러 디자인 패턴을 조합하여 복잡한 문제를 해결하는 고급 디자인 패턴입니다. 단일 패턴으로는 해결할 수 없는 복잡한 상황에서 여러 패턴의 장점을 결합하여 더 유연하고 확장 가능한 솔루션을 제공합니다.

**컴파운드 패턴이 중요한 이유:**

- **복잡성 관리**: 단일 패턴의 한계를 넘어서 복잡한 시스템을 체계적으로 설계
- **유연성 향상**: 여러 패턴의 장점을 결합하여 더 적응력 있는 구조 생성
- **재사용성 증대**: 검증된 패턴들을 조합하여 안정적이고 재사용 가능한 솔루션 제공
- **확장성 확보**: 시스템의 성장에 따라 새로운 패턴을 추가하거나 기존 패턴을 수정 가능

## 🏗️ 구조

```
Client
├── Pattern A (예: Strategy)
│   ├── ConcreteStrategy1
│   └── ConcreteStrategy2
├── Pattern B (예: Observer)
│   ├── Subject
│   └── Observer
└── Pattern C (예: Factory)
    ├── ConcreteFactory1
    └── ConcreteFactory2
```

## 💡 프론트엔드 활용 아이디어

### 1. **상태 관리 + 옵저버 + 전략 패턴**

```javascript
// 상태 관리 시스템 (Strategy + Observer + Singleton)
class StateManager {
  constructor() {
    this.state = {};
    this.observers = [];
    this.strategies = new Map();
  }

  // 전략 패턴: 상태 변경 전략
  setStrategy(key, strategy) {
    this.strategies.set(key, strategy);
  }

  // 옵저버 패턴: 상태 변경 알림
  subscribe(observer) {
    this.observers.push(observer);
  }

  updateState(key, value) {
    const strategy = this.strategies.get(key);
    if (strategy) {
      this.state[key] = strategy.execute(value);
    }
    this.notifyObservers(key, this.state[key]);
  }

  notifyObservers(key, value) {
    this.observers.forEach((observer) => observer.update(key, value));
  }
}

// 사용 예시
const stateManager = new StateManager();
stateManager.setStrategy("user", new UserValidationStrategy());
stateManager.subscribe(new UIUpdater());
```

### 2. **컴포넌트 팩토리 + 데코레이터 + 컴포지트**

```javascript
// 컴포넌트 팩토리 (Factory + Decorator + Composite)
class ComponentFactory {
  createComponent(type, props) {
    let component = this.createBaseComponent(type, props);

    // 데코레이터 패턴: 기능 추가
    if (props.withLoading) {
      component = new LoadingDecorator(component);
    }
    if (props.withError) {
      component = new ErrorBoundaryDecorator(component);
    }

    return component;
  }

  createBaseComponent(type, props) {
    switch (type) {
      case "button":
        return new Button(props);
      case "input":
        return new Input(props);
      case "form":
        return new Form(props);
      default:
        throw new Error(`Unknown component type: ${type}`);
    }
  }
}

// 사용 예시
const factory = new ComponentFactory();
const button = factory.createComponent("button", {
  text: "Submit",
  withLoading: true,
  withError: true,
});
```

### 3. **라우터 + 미들웨어 + 전략 패턴**

```javascript
// 라우터 시스템 (Strategy + Chain of Responsibility + Factory)
class Router {
  constructor() {
    this.routes = new Map();
    this.middlewares = [];
    this.strategies = new Map();
  }

  // 전략 패턴: 라우팅 전략
  setStrategy(path, strategy) {
    this.strategies.set(path, strategy);
  }

  // 책임 연쇄 패턴: 미들웨어 체인
  use(middleware) {
    this.middlewares.push(middleware);
  }

  route(path, handler) {
    this.routes.set(path, handler);
  }

  navigate(path, context) {
    // 미들웨어 체인 실행
    let index = 0;
    const next = () => {
      if (index < this.middlewares.length) {
        this.middlewares[index++](context, next);
      } else {
        // 라우팅 전략 실행
        const strategy = this.strategies.get(path);
        const handler = this.routes.get(path);
        if (strategy && handler) {
          strategy.execute(handler, context);
        }
      }
    };
    next();
  }
}
```

## 🔧 백엔드/전체 활용 아이디어

### 1. **API 게이트웨이 + 전략 + 옵저버**

```javascript
// API 게이트웨이 (Strategy + Observer + Facade)
class APIGateway {
  constructor() {
    this.routes = new Map();
    this.strategies = new Map();
    this.observers = [];
    this.cache = new Map();
  }

  // 전략 패턴: 인증 전략
  setAuthStrategy(type, strategy) {
    this.strategies.set(type, strategy);
  }

  // 옵저버 패턴: 요청 모니터링
  subscribe(observer) {
    this.observers.push(observer);
  }

  async handleRequest(req, res) {
    const route = this.routes.get(req.path);
    if (!route) {
      return res.status(404).json({ error: "Route not found" });
    }

    // 인증 전략 실행
    const authStrategy = this.strategies.get(route.authType);
    if (authStrategy && !authStrategy.authenticate(req)) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    // 옵저버들에게 요청 알림
    this.notifyObservers("request", { path: req.path, method: req.method });

    // 라우트 핸들러 실행
    return route.handler(req, res);
  }
}
```

### 2. **데이터 처리 파이프라인 + 템플릿 + 전략**

```javascript
// 데이터 처리 파이프라인 (Template + Strategy + Chain)
class DataPipeline {
  constructor() {
    this.steps = [];
    this.strategies = new Map();
  }

  // 전략 패턴: 데이터 변환 전략
  setStrategy(type, strategy) {
    this.strategies.set(type, strategy);
  }

  // 템플릿 메서드 패턴: 파이프라인 실행
  async process(data) {
    let result = data;

    for (const step of this.steps) {
      const strategy = this.strategies.get(step.type);
      if (strategy) {
        result = await strategy.execute(result, step.config);
      }
    }

    return result;
  }

  addStep(type, config) {
    this.steps.push({ type, config });
  }
}

// 사용 예시
const pipeline = new DataPipeline();
pipeline.setStrategy("filter", new DataFilterStrategy());
pipeline.setStrategy("transform", new DataTransformStrategy());
pipeline.setStrategy("validate", new DataValidationStrategy());

pipeline.addStep("filter", { field: "status", value: "active" });
pipeline.addStep("transform", { format: "json" });
pipeline.addStep("validate", { schema: "userSchema" });
```

### 3. **이벤트 시스템 + 메멘토 + 옵저버**

```javascript
// 이벤트 시스템 (Observer + Memento + Command)
class EventSystem {
  constructor() {
    this.events = new Map();
    this.observers = [];
    this.history = [];
    this.maxHistory = 100;
  }

  // 옵저버 패턴: 이벤트 구독
  subscribe(eventType, observer) {
    if (!this.events.has(eventType)) {
      this.events.set(eventType, []);
    }
    this.events.get(eventType).push(observer);
  }

  // 메멘토 패턴: 이벤트 히스토리 저장
  saveState() {
    const memento = {
      timestamp: Date.now(),
      events: Array.from(this.events.entries()),
    };

    this.history.push(memento);
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
  }

  // 커맨드 패턴: 이벤트 실행
  emit(eventType, data) {
    this.saveState();

    const observers = this.events.get(eventType) || [];
    observers.forEach((observer) => observer.update(eventType, data));
  }

  // 상태 복원
  restoreState(timestamp) {
    const memento = this.history.find((h) => h.timestamp === timestamp);
    if (memento) {
      this.events = new Map(memento.events);
    }
  }
}
```

## 🎯 구현 팁

### 1. **패턴 조합의 원칙**

- **단일 책임**: 각 패턴이 명확한 역할을 가지도록 설계
- **의존성 최소화**: 패턴 간의 결합도를 낮게 유지
- **확장성 고려**: 새로운 패턴을 쉽게 추가할 수 있는 구조 설계

### 2. **성능 최적화**

- **지연 초기화**: 필요한 시점에 패턴 인스턴스 생성
- **캐싱**: 자주 사용되는 패턴 조합 결과 캐싱
- **비동기 처리**: I/O 작업이 많은 패턴은 비동기로 처리

### 3. **테스트 전략**

- **단위 테스트**: 각 패턴을 독립적으로 테스트
- **통합 테스트**: 패턴 조합의 동작 검증
- **모킹**: 의존성을 가진 패턴들을 모킹하여 테스트

## 🚀 실무 활용 예제

### **React 상태 관리 시스템**

```javascript
// Redux + React Context + Observer 패턴 조합
class CompoundStateManager {
  constructor() {
    this.store = new Map();
    this.observers = new Map();
    this.middlewares = [];
  }

  // 전략 패턴: 상태 변경 전략
  setStateStrategy(key, strategy) {
    this.store.set(key, strategy);
  }

  // 옵저버 패턴: 상태 변경 구독
  subscribe(key, callback) {
    if (!this.observers.has(key)) {
      this.observers.set(key, []);
    }
    this.observers.get(key).push(callback);
  }

  // 미들웨어 패턴: 상태 변경 전처리
  use(middleware) {
    this.middlewares.push(middleware);
  }

  // 상태 업데이트
  updateState(key, newState) {
    const strategy = this.store.get(key);
    if (strategy) {
      // 미들웨어 체인 실행
      let processedState = newState;
      this.middlewares.forEach((middleware) => {
        processedState = middleware(processedState, key);
      });

      // 전략 실행
      const finalState = strategy.execute(processedState);
      this.store.set(key, finalState);

      // 옵저버들에게 알림
      const callbacks = this.observers.get(key) || [];
      callbacks.forEach((callback) => callback(finalState));
    }
  }
}

// 사용 예시
const stateManager = new CompoundStateManager();

// 상태 전략 설정
stateManager.setStateStrategy("user", new UserStateStrategy());
stateManager.setStateStrategy("cart", new CartStateStrategy());

// 미들웨어 추가
stateManager.use((state, key) => {
  console.log(`State change: ${key}`, state);
  return state;
});

// 구독
stateManager.subscribe("user", (userState) => {
  console.log("User state updated:", userState);
});
```

컴파운드 패턴은 복잡한 시스템을 체계적으로 설계할 때 매우 유용한 접근 방법입니다. 여러 패턴의 장점을 결합하여 더 강력하고 유연한 솔루션을 만들 수 있으며, 이는 현대적인 웹 애플리케이션 개발에서 필수적인 기술입니다.
