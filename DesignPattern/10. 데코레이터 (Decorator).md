# 데코레이터 (Decorator)

## 개요

- **문제**: 상속으로 기능을 조합하면 클래스 폭발·경직화가 발생한다.
- **해법**: 합성으로 기능을 감싸며 동적으로 책임을 더한다.

## 프론트엔드 활용 아이디어

- **fetch 래퍼**: 로깅/리트라이/캐싱 데코레이터 조합
- **폼 컨트롤**: 밸리데이션/마스킹/디바운스 기능 데코레이팅
- **컴포넌트**: 접근 제어/측정/에러 경계 기능 주입

## 백엔드/전체 활용 아이디어

- **미들웨어 체인**: 로깅/인증/캐싱/로드밸런싱
- **데이터베이스**: 트랜잭션/로깅/캐싱 레이어
- **API 엔드포인트**: 권한/속도 제한/로깅 기능 추가

## 구조

- Component(공통 인터페이스)
- ConcreteComponent(기본 기능)
- Decorator(Component 보유, 위임)
- ConcreteDecorator(전/후처리로 기능 확장)

## 장단점

- **장점**: 단일 책임, 조합 유연성, 닫힌-열린 원칙 준수
- **단점**: 디버깅 난이도, 구성 파악 어려움

## 구현 팁

- 데코레이터 체인이 길어지면 로깅으로 추적 가능성 확보
- 성능 민감 경로는 중복 전/후처리 최소화

## JavaScript 예제 (주석 포함)

```javascript
class Coffee {
  cost() {
    return 1000;
  }
  desc() {
    return "Coffee";
  }
}

// 공통 데코레이터: 기본 위임 로직 제공
class Decorator extends Coffee {
  constructor(base) {
    super();
    this.base = base;
  }
  cost() {
    return this.base.cost();
  }
  desc() {
    return this.base.desc();
  }
}

// 구체 데코레이터: 기능을 누적
class Milk extends Decorator {
  cost() {
    return super.cost() + 300;
  } // 가격 가산
  desc() {
    return super.desc() + ", Milk";
  } // 설명 추가
}
class Sugar extends Decorator {
  cost() {
    return super.cost() + 100;
  }
  desc() {
    return super.desc() + ", Sugar";
  }
}

let drink = new Coffee(); // 기본
// 런타임 조합 순서에 따라 결과가 달라질 수 있음
drink = new Milk(drink);
drink = new Sugar(drink);
console.log(drink.desc(), drink.cost()); // Coffee, Milk, Sugar 1400
```
