# 데코레이터 (Decorator)

## 개요

- **문제**: 상속으로 기능을 조합하면 클래스 폭발·경직화가 발생한다.
- **해법**: 합성으로 기능을 감싸며 동적으로 책임을 더한다.

## 프론트엔드 활용 아이디어

- fetch 래퍼에 로깅/리트라이/캐싱 데코레이터 조합
- 폼 컨트롤에 밸리데이션/마스킹/디바운스 기능 데코레이팅
- 컴포넌트에 접근 제어/측정/에러 경계 기능 주입
- 캔버스 드로잉에 스냅/그리드/가이드라인 기능 추가
- 일부 객체에만 옵션 기능을 부여(로깅, 캐싱, 리트라이)
- 런타임 조합이 필요한 기능(가격 정책, 미들웨어)

## 백엔드/전체 활용 아이디어

- API 계층: 외부/레거시 시스템 통합, 스키마 변환, 버전 호환
- 도메인/서비스 계층: 비즈니스 규칙 캡슐화, 전략 교체, 상태 전이, 이벤트 발행
- 데이터 계층: 저장소 추상화(관계형/NoSQL/파일/오브젝트 스토리지), 커넥션/트랜잭션 관리
- 마이크로서비스/메시징: 큐/토픽 기반 통합, 사가/워크플로, 리트라이/백오프
- 관측성/보안: 로깅/추적/메트릭, 접근 제어/정책/감사, 캐싱/레이트리밋

## 구조

- Component(공통 인터페이스)
- ConcreteComponent(기본 기능)
- Decorator(Component 보유, 위임)
- ConcreteDecorator(전/후처리로 기능 확장)

## 장단점

- **장점**: 단일 책임, 조합 유연성, 닫힌-열린 원칙 준수
- **단점**: 디버깅 난이도, 구성 파악 어려움

## 구현 팁

- 데코레이터 체인이 길어지면 로깅으로 추적 가능성 확보
- 성능 민감 경로는 중복 전/후처리 최소화

## JavaScript 예제 (주석 포함)

```javascript
class Coffee {
  cost() {
    return 1000;
  }
  desc() {
    return "Coffee";
  }
}

// 공통 데코레이터: 기본 위임 로직 제공
class Decorator extends Coffee {
  constructor(base) {
    super();
    this.base = base;
  }
  cost() {
    return this.base.cost();
  }
  desc() {
    return this.base.desc();
  }
}

// 구체 데코레이터: 기능을 누적
class Milk extends Decorator {
  cost() {
    return super.cost() + 300;
  } // 가격 가산
  desc() {
    return super.desc() + ", Milk";
  } // 설명 추가
}
class Sugar extends Decorator {
  cost() {
    return super.cost() + 100;
  }
  desc() {
    return super.desc() + ", Sugar";
  }
}

let drink = new Coffee(); // 기본
// 런타임 조합 순서에 따라 결과가 달라질 수 있음
drink = new Milk(drink);
drink = new Sugar(drink);
console.log(drink.desc(), drink.cost()); // Coffee, Milk, Sugar 1400
```
