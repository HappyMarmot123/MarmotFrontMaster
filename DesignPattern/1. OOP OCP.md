# 객체 지향 프로그래밍 (Object-Oriented Programming)

## 📖 개요

**객체 지향 프로그래밍(OOP)**은 현대 소프트웨어 개발의 핵심 패러다임 중 하나입니다. 데이터와 그 데이터를 조작하는 메서드를 하나의 단위(객체)로 묶어 프로그램을 구성하는 방식으로, 코드의 재사용성, 유지보수성, 확장성을 크게 향상시킵니다.

## 🔍 객체 지향 프로그래밍의 핵심 개념

### 1. 클래스(Class)와 객체(Object)

**클래스**는 객체를 생성하기 위한 템플릿으로, 객체가 가져야 할 속성과 메서드를 정의합니다.

**객체**는 클래스의 인스턴스로, 실제 메모리에 할당되어 동작하는 실체입니다.

### 2. 객체 지향의 4대 원칙

#### 캡슐화(Encapsulation)

- **데이터 은닉**: 객체의 내부 상태를 외부로부터 숨김
- **정보 은닉**: 구현 세부사항을 외부에 노출하지 않음
- **접근 제어**: public, private, protected 등의 접근 제한자 사용

#### 상속(Inheritance)

- **코드 재사용**: 기존 클래스의 기능을 새로운 클래스에서 재사용
- **계층 구조**: 부모-자식 관계를 통한 클래스 계층 구조 형성
- **다형성 기반**: 상속을 통한 다형성 구현

#### 다형성(Polymorphism)

- **인터페이스 통일**: 동일한 인터페이스를 통해 다양한 객체 조작
- **오버라이딩**: 자식 클래스에서 부모 클래스의 메서드 재정의
- **오버로딩**: 동일한 이름의 메서드를 다른 매개변수로 정의

#### 추상화(Abstraction)

- **복잡성 감소**: 복잡한 시스템을 단순한 모델로 표현
- **핵심 기능**: 중요한 기능만 추출하여 인터페이스로 정의
- **구현 분리**: 추상화된 인터페이스와 구체적인 구현을 분리

## 🧱 OCP (Open-Closed Principle)

OCP는 소프트웨어 개체(클래스, 모듈, 함수 등)가 확장에는 열려(Open) 있고 변경에는 닫혀(Closed) 있어야 한다는 원칙입니다. 즉, 기존 코드를 수정하지 않고도 새로운 요구사항을 기능 추가(확장)로 해결할 수 있어야 합니다.

### 왜 중요한가?

- 변경 범위를 최소화하여 회귀 버그를 줄입니다.
- 공통 규약(추상화)에 의존함으로써 기능을 플러그인처럼 교체·추가할 수 있습니다.
- 테스트 용이성 및 유지보수성이 향상됩니다.

### 냄새 나는 설계(나쁜 예)

요구사항이 추가될 때마다 조건문을 수정해야 하는 구조는 OCP를 위반합니다.

```javascript
// 결제 타입이 늘어날 때마다 이 함수 자체를 수정해야 함 (OCP 위반)
function pay(amount, method) {
  if (method === "card") {
    // ... 카드 결제 로직
  } else if (method === "paypal") {
    // ... 페이팔 결제 로직
  } else if (method === "crypto") {
    // ... 암호화폐 결제 로직
  } else {
    throw new Error("지원하지 않는 결제 방식");
  }
}
```

### OCP 준수(좋은 예)

공통 인터페이스(추상화)에 의존하고, 구체 구현을 추가로 제공하여 기능을 확장합니다. 기존 코드는 수정하지 않습니다.

```javascript
// 공통 인터페이스(프로토콜)
class PaymentStrategy {
  pay(amount) {
    throw new Error("pay를 구현해야 합니다.");
  }
}

class CardPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[CARD] ${amount}원 결제`);
  }
}

class PaypalPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[PAYPAL] ${amount}원 결제`);
  }
}

// 새로운 방식 추가 시, 기존 코드 수정 없이 클래스만 추가
class CryptoPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[CRYPTO] ${amount}원 결제`);
  }
}

class PaymentProcessor {
  constructor(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }
  setStrategy(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }
  process(amount) {
    this.paymentStrategy.pay(amount);
  }
}

// 사용
const processor = new PaymentProcessor(new CardPayment());
processor.process(10000);
processor.setStrategy(new PaypalPayment());
processor.process(20000);
```

### 적용 가이드

- 규칙: “변하는 것”과 “변하지 않는 것”을 분리하고, 변하는 축을 추상화로 캡슐화합니다.
- 의존성 방향: 구체 구현이 아닌 추상화(인터페이스/추상 클래스/프로토콜)에 의존합니다.
- 확장 포인트: 팩토리, 전략 패턴, 템플릿 메서드, 의존성 주입(DI), 플러그인 아키텍처를 활용합니다.

### 안티패턴

- 거대한 if/switch 분기
- 열거형(enum) 값 추가할 때마다 로직 곳곳을 수정
- 추상화 없이 구체 구현에 직접 의존

### 테스트 관점

- 기존 테스트를 깨지 않고 새 구현체에 대한 테스트만 추가하면 됩니다.
- 계약(Contract) 테스트로 인터페이스 준수 여부를 검증하세요.

### 요약

- 변화에 유연하게 대응하려면 “수정”보다 “확장”을 설계하세요.
- 추상화에 의존하고, 구체 구현은 교체 가능하게 만드세요.
